================================================================================
FUTURE FEATURES TODO - MultistateModels.jl
================================================================================
Created: 2025-11-29
Updated: 2025-06-28
Branch: SIR

================================================================================
VALIDATION TASKS (Priority)
================================================================================

✅ Validate Observation/Subject Weights (2025-06-28)
   - Verified SubjectWeights propagation through MCEM (mcem_mll, mcem_ase, mcem_mll_sir)
   - Tested weighted vs duplicated data equivalence
   - Confirmed subject-level scaling in loglik_markov
   - Tests in MultistateModelsTests/unit/test_subject_weights.jl
   
   - Verified ObservationWeights in panel and exact data (loglik_markov)
   - Tests in MultistateModelsTests/unit/test_observation_weights_emat.jl

✅ Validate Emission Matrices (2025-06-28)
   - Verified CensoringPatterns construction of emat (obstype > 2, stateto=0)
   - Verified EmissionMatrix direct specification and validation
   - Tested forward algorithm with censored observations
   - Verified censored likelihood = log(sum of allowed state probabilities)
   - Tests in MultistateModelsTests/unit/test_observation_weights_emat.jl

================================================================================
COMPLETED FEATURES (as of 2025-12-16)
================================================================================

✅ Phase-Type Markov Surrogates
   - Titman-Sharples importance sampling for semi-Markov MCEM
   - User-configurable number of phases, Coxian structure options
   - Mixed hazard types (PT + non-PT from same state) supported
   - API consolidated: only :unstructured and :sctp options
   - See src/phasetype.jl

✅ SIR (Sampling Importance Resampling)
   - Multinomial resampling (:sir) and Latin Hypercube (:lhs)
   - 2.3x speedup on log-likelihood computation in M-step
   - Variance reduction: SIR variance 0.6× of LHS
   - See src/sir.jl

✅ SQUAREM Acceleration for MCEM
   - Quasi-Newton acceleration reducing iterations to convergence
   - Usage: fit(model; acceleration=:squarem)

✅ Spline Hazards (M-splines)
   - RuntimeSplineHazard with automatic knot placement
   - Monotonicity constraints, natural boundary conditions
   - See src/smooths.jl, src/hazards.jl

✅ Memory Allocation Reduction (Phase 4 optimization)
   - PathWorkspace and TVCIntervalWorkspace for thread-local storage
   - 2.3× speedup, 60% allocation reduction in draw_paths

✅ Variance Estimation Infrastructure
   - IJ/JK sandwich estimators with LOO methods
   - See docs/src/optimization.md

✅ Test Infrastructure
   - Moved to standalone repo: https://github.com/fintzij/MultistateModelsTests.jl
   - 1,235+ unit tests passing
   - Comprehensive phase-type, SIR, and MLL consistency tests


================================================================================
FEATURE: SPLINE FUNCTIONS ON COVARIATES
================================================================================

Status: Not started
Priority: HIGH

MOTIVATION:
- Allow flexible, non-linear covariate effects
- Common in survival analysis (e.g., age effects often non-linear)
- Natural extension of current spline hazard infrastructure

DESIGN IDEAS:
```julia
# Option 1: Formula-based syntax (like R's mgcv)
h12 = Hazard(@formula(0 ~ 1 + s(age) + treatment), :wei, 1, 2)

# Option 2: Explicit spline covariate term
h12 = Hazard(@formula(0 ~ 1 + treatment), :wei, 1, 2;
             spline_covars = [SplineCovariate(:age, degree=3, nknots=5)])
```

KEY QUESTIONS:
- How to integrate with StatsModels.jl formula interface?
- Should share infrastructure with RuntimeSplineHazard?
- Need automatic knot placement based on covariate distribution
- Penalization for smooth covariate effects?

IMPLEMENTATION NOTES:
- Reuse BSplines.jl infrastructure from hazard splines
- Knots placed at quantiles of covariate distribution
- May need to extend extract_covar_names() and covariate handling

REFERENCES:
- Wood (2017) GAMs: An Introduction with R, 2nd ed
- survPen (Fauvernier et al. 2019) - supports spline covariates


================================================================================
FEATURE: STRATIFIED HAZARDS
================================================================================

Status: Not started
Priority: MEDIUM

MOTIVATION:
- Common need: separate baseline hazards by group (e.g., sex, site, treatment arm)
- Covariate effects often assumed shared across strata
- Currently requires duplicating hazard specifications manually
- Stratified Cox model is standard in survival analysis

DESIGN IDEAS:
```julia
# Option 1: strata() term in formula
h12 = Hazard(@formula(0 ~ 1 + age + strata(sex)), :wei, 1, 2)
# Creates separate shape/scale for each sex level, shared age coefficient

# Option 2: Explicit strata argument
h12 = Hazard(@formula(0 ~ 1 + age), :wei, 1, 2; strata = :sex)

# Option 3: StratifiedHazard wrapper
h12 = StratifiedHazard(
    Hazard(@formula(0 ~ 1 + age), :wei, 1, 2),
    strata = :sex
)
```

SEMANTICS:
- Separate baseline hazard parameters for each stratum
- Shared covariate coefficients across strata
- Model: h_k(t|x) = h_{0k}(t) * exp(β'x) where k indexes stratum
- Equivalent to fitting separate baselines but constrained β

PARAMETER STRUCTURE:
```julia
# For Weibull with 2 strata (M/F) and 1 covariate:
# params = [shape_M, log_scale_M, shape_F, log_scale_F, β_age]
#          ├── baseline (stratum M) ──┤├── baseline (stratum F) ──┤├─ shared ─┤
```

KEY QUESTIONS:
1. How to handle spline baselines with stratification?
   - Separate knots per stratum, or shared knots with different coefficients?
2. Should stratification be at hazard level or model level?
3. How to report/display stratified estimates?
4. Reference coding for strata (which level gets "first" baseline)?

IMPLEMENTATION NOTES:
- Extends n_baseparams() to return n_baseparams * n_strata
- Need stratum indicator column in data
- Parameter indexing: baseline_offset = (stratum_idx - 1) * n_baseparams
- Covariate design matrix unchanged
- Likelihood contribution: use stratum-appropriate baseline for each subject

DATA REQUIREMENTS:
- Strata variable must be categorical/integer
- Each subject belongs to exactly one stratum (time-constant)
- Strata need not have equal sample sizes

USE CASES:
- Multi-center trials: separate baselines by site, shared treatment effect
- Competing risks by subgroup: stratify illness-death by sex
- Historical controls: separate baselines for RCT vs registry, shared β

RELATED TO:
- Frailty models (random baselines vs fixed strata)
- Interaction terms (can achieve similar effect but less interpretable)
- Spline covariates (stratification is discrete version of smooth baseline variation)

REFERENCES:
- Therneau & Grambsch (2000) Modeling Survival Data, Ch 4.2
- Cox (1972) original stratified Cox model
- R survival::coxph with strata() term


================================================================================
FEATURE: PENALIZED SPLINES (NEXT PRIORITY)
================================================================================

Status: Planning complete, implementation deferred
Priority: HIGH (after basic splines work)

MOTIVATION:
- MSMs are uniquely sensitive to knot placement
- Need automatic smoothing to reduce sensitivity
- Want to avoid manual knot selection entirely if possible

KEY REFERENCES:
1. Murray et al. (2016) PMC4811615 - Low-rank thin plate splines for survival
2. survPen (Fauvernier et al. 2019) - Multidimensional penalized splines
3. Wood (2020) - Neighborhood cross-validation

PENALTY OPTIONS:
1. P-SPLINE: λ * θ' D' D θ (D = differencing matrix)
2. SHARED SMOOTHING: All transitions share same λ
3. JOINT TOTAL HAZARD: Penalize wigglyness of total cumulative hazard

SMOOTHING PARAMETER SELECTION:
- LAML (default): Laplace approximate marginal likelihood
- GCV/LCV: Leave-one-out cross-validation
- NCV: Neighborhood cross-validation (Wood 2020)

IMPLEMENTATION PLAN:
[ ] PenaltyTerm abstract type
[ ] PSplinePenalty struct: λ, D (differencing), order
[ ] build_difference_matrix(order, n)
[ ] penalized_loglik(θ, model, penalties)
[ ] LAML criterion and gradient
[ ] Nested optimization (inner: β, outer: λ)


================================================================================
FEATURE: CUSTOM HAZARD FUNCTIONS
================================================================================

Status: Not started
Priority: HIGH (prerequisite for neural hazards)

DESIGN: Two paths available

Path 1: CustomHazard (user provides functions)
```julia
h = CustomHazard(
    hazard_fn = (t, θ, x) -> θ[1] * θ[2] * t^(θ[2]-1),
    cumhaz_fn = (t, θ, x) -> θ[1] * t^θ[2],
    n_params = 2,
    statefrom = 1, stateto = 2
)
```

Path 2: SymbolicHazard (automatic cumhaz derivation via Symbolics.jl)
```julia
@variables t θ[1:2]
h = SymbolicHazard(
    hazard = θ[1] * θ[2] * t^(θ[2]-1),
    statefrom = 1, stateto = 2
)
```

TARGET FORMS:
- Log-logistic
- Generalized gamma
- Bathtub curves
- Log-normal (numerical cumhaz)


================================================================================
FEATURE: SCIML/AD ECOSYSTEM COMPATIBILITY
================================================================================

Status: Extension points documented
Priority: HIGH (foundation for neural hazards)

ROADMAP:

Phase 1: DifferentiationInterface.jl wrapper
[ ] Add DifferentiationInterface as dependency
[ ] Create ADBackend config: :forwarddiff, :enzyme, :zygote
[ ] Wrap likelihood gradient calls
[ ] Benchmark backends

Phase 2: ChainRules for Zygote
[ ] rrule for matrix exponential
[ ] rrule for emission matrix operations

Phase 3: NeuralHazard integration
[ ] Add Lux.jl as weak dependency
[ ] Define NeuralHazard struct
[ ] Gauss-Legendre quadrature for cumhaz
[ ] Pre-training from Nelson-Aalen


================================================================================
FEATURE: ODE-BASED HAZARDS
================================================================================

Status: Extension points documented
Priority: Low

CURRENT EXTENSION POINTS:
- is_separable trait (all current hazards return true)
- BatchedODEData struct ready for SciML

TODO:
[ ] ODEHazard <: _SemiMarkovHazard
[ ] is_separable(::ODEHazard) = false
[ ] Adjoint methods: :BacksolveAdjoint, :QuadratureAdjoint


================================================================================
FEATURE: GLOBAL SENSITIVITY ANALYSIS
================================================================================

Status: Not implemented
Priority: Medium

MOTIVATION:
- Understand which parameters most influence state occupation
- Diagnose overparameterized models
- Prior elicitation guidance

TODO:
[ ] GlobalSensitivity.jl integration
[ ] sensitivity_analysis(model; output=:loglik, method=Sobol())
[ ] Support: Sobol(), Morris(), eFAST()


================================================================================
REFERENCES
================================================================================

Phase-Type:
- Titman & Sharples (2010) Biometrics 66(3):742-752

Splines & Flexible Hazards:
- Jackson (2023) survextrap: BMC Med Res Meth 23:282
- Fauvernier et al. (2019) survPen: JRSS-C 68:1415-1453
- Murray et al. (2016) Bayesian Anal 11(2):381-402

P-Splines & Smoothing:
- Eilers & Marx (1996) Stat Sci 11(2):89-121
- Wood (2011) JRSS-B 73(1):3-36
- Wood et al. (2016) JASA 111:1548-1575
- Wood (2020) Biometrics - NCV

Neural ODEs:
- Chen et al. (2018) NeurIPS
- Rackauckas et al. (2020) arXiv:2001.04385

AD/SciML:
- Moses & Churavy (2020) - Enzyme.jl
- Innes (2018) - Zygote.jl


================================================================================
CONSIDERATION: OPTIMIZATION/IDENTIFIABILITY WARNINGS
================================================================================

Status: Not started
Priority: LOW
Added: 2025-12-15

MOTIVATION:
- Phase-type models with many phases/destinations may have identifiability issues
- Users may not realize when parameters are poorly identified

POTENTIAL WARNINGS TO ADD:
1. Singular or near-singular covariance matrix after optimization
2. Optimization fails to converge (already may exist, but verify)
3. Hessian has negative eigenvalues (non-PSD)
4. Very large standard errors relative to estimates

DESIGN CONSIDERATIONS:
- Should be opt-in or opt-out?
- Info vs warning level?
- How to detect "near-singular" (condition number threshold?)

NOTES:
- Don't want to overwhelm users with false positives
- May be better as a post-fit diagnostic function rather than automatic warning
================================================================================
FEATURE: NUMERICAL STABILITY IMPROVEMENTS
================================================================================
Added: 2025-12-15

MOTIVATION:
- Phase-type and complex multistate models can suffer from numerical overflow/underflow
- Matrix exponentials of large intensity matrices can lose precision
- Forward algorithm probabilities can underflow for long observation intervals
- Cumulative hazards can overflow for high-rate transitions

AREAS TO EXPLORE:
1. Log-scale forward algorithm (log-sum-exp trick) for likelihood computation
2. Uniformization for matrix exponentials instead of direct expm()
3. Scaling and squaring improvements for matrix exponentials
4. Log-probability tracking through TPM computations
5. Numerical safeguards in phase-type density calculations

SPECIFIC CONCERNS:
- exp(Q*dt) can overflow/underflow for large rates or long intervals
- Forward algorithm multiplies many small probabilities
- Phase-type density π'exp(Sτ)r involves potentially very small exp(Sτ) entries

REFERENCES:
- Sherlock et al. (2021) for uniformization in HMMs
- Sidje (1998) Expokit for matrix exponential algorithms
- Log-domain forward-backward algorithms in HMM literature