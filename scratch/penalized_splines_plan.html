<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>penalized_splines_plan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="penalized_splines_plan_files/libs/clipboard/clipboard.min.js"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/popper.min.js"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="penalized_splines_plan_files/libs/quarto-html/anchor.min.js"></script>
<link href="penalized_splines_plan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="penalized_splines_plan_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="penalized_splines_plan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="penalized_splines_plan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="penalized_splines_plan_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="implementation-plan-penalized-splines-for-multistatemodels.jl" class="level1">
<h1>Implementation Plan: Penalized Splines for MultistateModels.jl</h1>
<section id="status-implementation-ready" class="level2">
<h2 class="anchored" data-anchor-id="status-implementation-ready">Status: Implementation (Ready)</h2>
<p>See <code>penalized_splines_literature_review.md</code> for detailed methodology.</p>
<hr>
</section>
<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>Implement penalized B-splines in <code>MultistateModels.jl</code>: 1. <strong>Baseline hazard smoothing</strong>: Penalized splines for <span class="math inline">\(\log h_{rs}(t)\)</span> 2. <strong>Covariate splines</strong>: Smooth nonlinear covariate effects via <code>s(covariate)</code> syntax 3. <strong>Shared-origin tensor products</strong>: Borrow strength across competing risks from same origin state 4. <strong>Covariate tensor products</strong>: Interactions between covariates <code>te(age, bmi)</code> and time-varying effects <code>te(age, t)</code></p>
</section>
<section id="key-design-decisions" class="level2">
<h2 class="anchored" data-anchor-id="key-design-decisions">Key Design Decisions</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 27%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Decision</th>
<th style="text-align: left;">Choice</th>
<th style="text-align: left;">Rationale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">What to penalize</td>
<td style="text-align: left;">Log-hazards <span class="math inline">\(\log h_{rs}(t)\)</span></td>
<td style="text-align: left;">Quadratic in <span class="math inline">\(\theta\)</span>; standard approach</td>
</tr>
<tr class="even">
<td style="text-align: left;">Penalty type</td>
<td style="text-align: left;">Derivative-based (Wood 2016)</td>
<td style="text-align: left;">Adapts to uneven knots from <code>place_interior_knots()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty order</td>
<td style="text-align: left;"><span class="math inline">\(m = 2\)</span> (curvature), user-configurable</td>
<td style="text-align: left;">Standard; penalizes roughness</td>
</tr>
<tr class="even">
<td style="text-align: left;">Smoothing selection</td>
<td style="text-align: left;">NCV criterion via <code>PIJCVState</code> infrastructure</td>
<td style="text-align: left;">Accounts for within-subject correlation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Secondary method</td>
<td style="text-align: left;">REML (DEFERRED)</td>
<td style="text-align: left;">May add as benchmark later; NCV sufficient for initial release</td>
</tr>
<tr class="even">
<td style="text-align: left;">Error handling</td>
<td style="text-align: left;"><code>ArgumentError</code> for user input</td>
<td style="text-align: left;">Package convention</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty storage</td>
<td style="text-align: left;"><code>PenaltyConfig</code> struct (not in hazard)</td>
<td style="text-align: left;">Keep hazard types immutable</td>
</tr>
<tr class="even">
<td style="text-align: left;">Initial scope</td>
<td style="text-align: left;">Markov + exact data only</td>
<td style="text-align: left;">MCEM compatibility deferred</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="tensor-product-api-design" class="level2">
<h2 class="anchored" data-anchor-id="tensor-product-api-design">Tensor Product API Design</h2>
<section id="three-distinct-use-cases" class="level3">
<h3 class="anchored" data-anchor-id="three-distinct-use-cases">Three Distinct Use Cases</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 35%">
<col style="width: 17%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Use Case</th>
<th style="text-align: left;">API</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Shared-origin baselines</strong></td>
<td style="text-align: left;">Model-level kwarg</td>
<td style="text-align: left;">Multiple competing risk baselines from same state</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Covariate interactions</strong></td>
<td style="text-align: left;"><code>te(x1, x2)</code> in formula</td>
<td style="text-align: left;">Smooth interaction surface between covariates</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Time-varying effects</strong></td>
<td style="text-align: left;"><code>te(x, t)</code> in formula</td>
<td style="text-align: left;">Covariate effect that changes over time</td>
</tr>
</tbody>
</table>
</section>
<section id="shared-origin-tensor-products-baseline-hazards" class="level3">
<h3 class="anchored" data-anchor-id="shared-origin-tensor-products-baseline-hazards">1. Shared-Origin Tensor Products (Baseline Hazards)</h3>
<p>For competing risks from state <span class="math inline">\(r\)</span> to destinations <span class="math inline">\(\{s_1, \ldots, s_D\}\)</span>, borrow strength across the <span class="math inline">\(D\)</span> baseline hazards.</p>
<p><strong>API (model-level)</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple: list of origin states to apply tensor structure</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(h12, h13, h14, h21;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> [<span class="fl">1</span>]  <span class="co"># State 1's baselines share structure</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Explicit: per-origin configuration</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(<span class="op">...</span>;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span> <span class="op">=&gt;</span> <span class="fu">SharedOriginConfig</span>(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            dest_penalty <span class="op">=</span> <span class="op">:</span>ridge,      <span class="co"># :ridge, :difference, or Matrix</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            monotone_time <span class="op">=</span> <span class="cn">false</span>,      <span class="co"># Monotone in time?</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            increasing <span class="op">=</span> <span class="cn">true</span>           <span class="co"># Direction if monotone</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Not specified in hazard formulas</strong> — this is a model-level structural choice.</p>
</section>
<section id="covariate-covariate-interactions" class="level3">
<h3 class="anchored" data-anchor-id="covariate-covariate-interactions">2. Covariate × Covariate Interactions</h3>
<p>Smooth interaction surface between two covariates:</p>
<p><strong>API (formula-level)</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Full tensor product (includes main effects implicitly)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Main effects + pure interaction</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> <span class="fu">s</span>(bmi) <span class="op">+</span> <span class="fu">ti</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Semantics</strong>: - <code>te(x1, x2)</code>: Full tensor product surface <span class="math inline">\(f(x_1, x_2)\)</span> - <code>ti(x1, x2)</code>: Interaction only (excludes main effects, requires separate <code>s(x1) + s(x2)</code>)</p>
</section>
<section id="time-varying-covariate-effects" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-covariate-effects">3. Time-Varying Covariate Effects</h3>
<p>Covariate effect that changes smoothly over time:</p>
<p><strong>API (formula-level)</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Time-varying effect of age (requires :sp family for time basis)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Age effect varies over time, plus linear treatment effect</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t) <span class="op">+</span> trt), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Note</strong>: <code>te(x, t)</code> requires <code>:sp</code> family because it needs a time basis for the baseline.</p>
</section>
<section id="api-summary-table" class="level3">
<h3 class="anchored" data-anchor-id="api-summary-table">API Summary Table</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 15%">
<col style="width: 18%">
<col style="width: 27%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Level</th>
<th style="text-align: left;">Family</th>
<th style="text-align: left;">Parameters</th>
<th style="text-align: left;">λ count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>shared_origin_tensor=[r]</code></td>
<td style="text-align: left;">Model</td>
<td style="text-align: left;"><code>:sp</code> required</td>
<td style="text-align: left;"><span class="math inline">\(K_t \times D\)</span></td>
<td style="text-align: left;">2 (<span class="math inline">\(\lambda_t\)</span>, <span class="math inline">\(\lambda_d\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>s(x)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\(K_x\)</span></td>
<td style="text-align: left;">1 per term</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>te(x1, x2)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\(K_1 \times K_2\)</span></td>
<td style="text-align: left;">2 (<span class="math inline">\(\lambda_1\)</span>, <span class="math inline">\(\lambda_2\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>te(x, t)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;"><code>:sp</code> only</td>
<td style="text-align: left;"><span class="math inline">\(K_x \times K_t\)</span></td>
<td style="text-align: left;">2 (<span class="math inline">\(\lambda_x\)</span>, <span class="math inline">\(\lambda_t\)</span>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ti(x1, x2)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\((K_1-1) \times (K_2-1)\)</span></td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="statsmodels.jl-integration" class="level2">
<h2 class="anchored" data-anchor-id="statsmodels.jl-integration">StatsModels.jl Integration</h2>
<section id="how-custom-terms-work" class="level3">
<h3 class="anchored" data-anchor-id="how-custom-terms-work">How Custom Terms Work</h3>
<p>StatsModels.jl allows custom term types via the <code>AbstractTerm</code> interface. Our smooth terms (<code>s()</code>, <code>te()</code>, <code>ti()</code>) are <strong>not</strong> standard Julia functions—they are term constructors that return custom <code>AbstractTerm</code> subtypes.</p>
<p><strong>Term dispatch mechanism</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># When StatsModels parses @formula(0 ~ s(age) + trt):</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. It sees s(age) as a FunctionTerm</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. We intercept via apply_schema() to convert to SmoothTerm</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. SmoothTerm handles its own model matrix construction</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Registration (in smooth_terms.jl)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: Second argument must be schema::StatsModels.Schema, not just `schema`</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(s)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>) <span class="op">=</span> </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">SmoothTerm</span>(ft.args[<span class="fl">1</span>].sym, <span class="fu">get_k</span>(ft), <span class="fu">get_penalty_order</span>(ft), <span class="op">:</span>natural)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="five-interaction-patterns" class="level3">
<h3 class="anchored" data-anchor-id="five-interaction-patterns">Five Interaction Patterns</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 16%">
<col style="width: 32%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pattern</th>
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Interpretation</th>
<th style="text-align: left;">Implementation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Smooth main effect</strong></td>
<td style="text-align: left;"><code>s(age)</code></td>
<td style="text-align: left;">Nonlinear <span class="math inline">\(f(\text{age})\)</span></td>
<td style="text-align: left;"><code>SmoothTerm</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Varying coefficient</strong></td>
<td style="text-align: left;"><code>s(age, by=trt)</code></td>
<td style="text-align: left;"><span class="math inline">\(\text{trt} \cdot f(\text{age})\)</span></td>
<td style="text-align: left;">⚠️ <strong>DEFERRED</strong> (future work)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Linear × smooth</strong></td>
<td style="text-align: left;"><code>s(age) * trt</code></td>
<td style="text-align: left;"><span class="math inline">\(f(\text{age}) + \text{trt} \cdot f(\text{age})\)</span></td>
<td style="text-align: left;">Automatic via StatsModels <code>*</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Smooth × smooth</strong></td>
<td style="text-align: left;"><code>te(age, bmi)</code></td>
<td style="text-align: left;">Tensor product <span class="math inline">\(f(\text{age}, \text{bmi})\)</span></td>
<td style="text-align: left;"><code>TensorTerm</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Time-varying effect</strong></td>
<td style="text-align: left;"><code>te(age, t)</code></td>
<td style="text-align: left;"><span class="math inline">\(f(\text{age}, t)\)</span> modifying baseline</td>
<td style="text-align: left;">Special: uses <code>:sp</code> time basis</td>
</tr>
</tbody>
</table>
</section>
<section id="the-special-role-of-t-time" class="level3">
<h3 class="anchored" data-anchor-id="the-special-role-of-t-time">The Special Role of <code>t</code> (Time)</h3>
<p>In <code>te(age, t)</code>, the symbol <code>t</code> is <strong>not a data column</strong>—it refers to the baseline hazard’s time axis. This requires special handling:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># te(age, t) with :sp family means:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># - age dimension: B-spline basis from data (like s(age))</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># - time dimension: SHARES the :sp family's time basis</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Implementation check in model construction:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">validate_tensor_term</span>(term<span class="op">::</span><span class="dt">TensorTerm</span>, hazard<span class="op">::</span><span class="dt">SplineHazard</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">:</span>t <span class="kw">in</span> term.vars</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        hazard.family <span class="op">==</span> <span class="op">:</span>sp <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">"te(..., t) requires :sp family (time basis needed)"</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Why this matters</strong>: The time basis is defined by the <code>:sp</code> hazard’s knots, degree, and boundary conditions. A <code>te(age, t)</code> term reuses this basis rather than creating a new one.</p>
</section>
<section id="varying-coefficient-models-future-work" class="level3">
<h3 class="anchored" data-anchor-id="varying-coefficient-models-future-work">Varying Coefficient Models — FUTURE WORK</h3>
<blockquote class="blockquote">
<p><strong>⚠️ SCOPE: EXPLICITLY DEFERRED</strong></p>
<p>Varying coefficient models (smooth effects that vary by categorical variable) are documented here for future reference but are NOT in the initial implementation scope. The <code>by</code> argument is not included in Phase 5’s SmoothTerm struct.</p>
</blockquote>
<p>The <code>by</code> argument (future) would allow smooth effects that vary by a categorical variable:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Future syntax (NOT IMPLEMENTED):</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Effect of age differs by treatment arm</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age, by<span class="op">=</span>trt)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Future implementation would use:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># B_smooth = B_age ⊗ indicator_trt  (block diagonal for each trt level)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="standard-operator-vs-te" class="level3">
<h3 class="anchored" data-anchor-id="standard-operator-vs-te">Standard <code>*</code> Operator vs <code>te()</code></h3>
<p>StatsModels’ <code>*</code> operator creates main effects + interaction. For smooth terms:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 28%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Expansion</th>
<th style="text-align: left;">Penalty structure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>s(age) * trt</code></td>
<td style="text-align: left;"><code>s(age) + s(age):trt</code></td>
<td style="text-align: left;">One λ for main, one for interaction</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>s(age) * s(bmi)</code></td>
<td style="text-align: left;"><strong>Not supported</strong></td>
<td style="text-align: left;">Use <code>s(age) + s(bmi) + ti(age, bmi)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>te(age, bmi)</code></td>
<td style="text-align: left;">Full tensor (no decomposition)</td>
<td style="text-align: left;">Two λ (one per margin)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ti(age, bmi)</code></td>
<td style="text-align: left;">Pure interaction</td>
<td style="text-align: left;">Two λ, constrained to sum to zero</td>
</tr>
</tbody>
</table>
<p><strong>Key constraint</strong>: <code>s(x) * s(y)</code> is <strong>not</strong> valid. Smooth × smooth requires explicit <code>te()</code> or <code>ti()</code>.</p>
</section>
<section id="baseline-intensity-interactions" class="level3">
<h3 class="anchored" data-anchor-id="baseline-intensity-interactions">Baseline Intensity Interactions</h3>
<p>For <code>:sp</code> family hazards, the baseline is already a spline. Interactions with the baseline:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 31%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Meaning</th>
<th style="text-align: left;">Parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>@formula(0 ~ 1)</code> with <code>:sp</code></td>
<td style="text-align: left;">Baseline spline only</td>
<td style="text-align: left;"><span class="math inline">\(K_t\)</span> coefficients</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>@formula(0 ~ trt)</code> with <code>:sp</code></td>
<td style="text-align: left;">Baseline + proportional hazards</td>
<td style="text-align: left;"><span class="math inline">\(K_t + 1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>@formula(0 ~ te(trt, t))</code></td>
<td style="text-align: left;">Treatment × time interaction</td>
<td style="text-align: left;"><span class="math inline">\(K_t \times 2\)</span> (binary trt)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>@formula(0 ~ te(age, t))</code></td>
<td style="text-align: left;">Continuous × time</td>
<td style="text-align: left;"><span class="math inline">\(K_{age} \times K_t\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: <code>te(trt, t)</code> with binary treatment is equivalent to <code>s(t, by=trt)</code> (separate time curves per arm).</p>
</section>
<section id="implementation-phases-for-statsmodels-integration" class="level3">
<h3 class="anchored" data-anchor-id="implementation-phases-for-statsmodels-integration">Implementation Phases for StatsModels Integration</h3>
<blockquote class="blockquote">
<p><strong>Problem: StatsModels.jl <span class="citation" data-cites="formula">@formula</span> Doesn’t Support Kwargs</strong> (R5-1)</p>
<p>StatsModels.jl’s <code>@formula</code> macro <strong>rejects keyword arguments</strong>. Both <code>s(age, k=5)</code> and <code>s(age; k=5)</code> throw <code>ArgumentError: non-call expression encountered</code>.</p>
<p><strong>Solution</strong>: MultistateModels.jl shadows the <code>@formula</code> macro with a version that preprocesses smooth terms before calling <code>StatsModels.@formula</code>. This gives users the natural kwargs syntax while maintaining full StatsModels compatibility.</p>
</blockquote>
<p><strong>User-facing API</strong> (natural kwargs syntax):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">MultistateModels</span>  <span class="co"># Our @formula shadows StatsModels.@formula</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># These just work!</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age; k<span class="op">=</span><span class="fl">5</span>) <span class="op">+</span> trt), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>h13 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age; k<span class="op">=</span><span class="fl">8</span>, penalty_order<span class="op">=</span><span class="fl">3</span>) <span class="op">+</span> <span class="fu">s</span>(bmi; k<span class="op">=</span><span class="fl">5</span>)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">3</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>h14 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, bmi; k<span class="op">=</span>(<span class="fl">8</span>, <span class="fl">6</span>))), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">4</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>h15 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">ti</span>(x1, x2; k<span class="op">=</span>(<span class="fl">5</span>, <span class="fl">4</span>))), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">5</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Standard formulas still work</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>h16 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> x1 <span class="op">+</span> x2 <span class="op">+</span> x1 <span class="op">&amp;</span> x2), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">6</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Phase 0 additions</strong> — Shadowed <code>@formula</code> Macro:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># File: src/construction/formula.jl (NEW)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">StatsModels</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define callable function objects for smooth terms</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> s <span class="kw">end</span>   <span class="co"># Smooth term: s(var; k=10, penalty_order=2)</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> te <span class="kw">end</span>  <span class="co"># Full tensor product: te(v1, v2; k=(10,10))</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> ti <span class="kw">end</span>  <span class="co"># Pure interaction: ti(v1, v2; k=(10,10))</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="st">    transform_smooth_terms(ex)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="st">Recursively transform smooth term calls in expression `ex` from kwargs syntax</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="st">to positional syntax. For example:</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="st">- `s(age; k=5, penalty_order=3)` → `s(age, 5, 3)`</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="st">- `te(x1, x2; k=(8, 6))` → `te(x1, x2, 8, 6)`</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="st">This preprocessing enables kwargs in @formula despite StatsModels.jl limitations.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">transform_smooth_terms</span>(ex)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ex isa <span class="dt">Expr</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ex.head <span class="op">==</span> <span class="op">:</span>call <span class="op">&amp;&amp;</span> ex.args[<span class="fl">1</span>] <span class="kw">in</span> [<span class="op">:</span>s, <span class="op">:</span>te, <span class="op">:</span>ti]</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">transform_smooth_call</span>(ex)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">Expr</span>(ex.head, [<span class="fu">transform_smooth_terms</span>(arg) for arg <span class="kw">in</span> ex.args]<span class="op">...</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ex</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="st">    transform_smooth_call(ex)</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="st">Transform a single smooth term call from kwargs to positional:</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="st">- `s(var; k=5, penalty_order=2)` → `s(var, 5, 2)`</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="st">- `te(v1, v2; k=(8, 6))` → `te(v1, v2, 8, 6)`</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="st">- `ti(v1, v2; k=(5, 4))` → `ti(v1, v2, 5, 4)`</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">transform_smooth_call</span>(ex)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    func <span class="op">=</span> ex.args[<span class="fl">1</span>]</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    positional <span class="op">=</span> <span class="dt">Any</span>[func]</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>    kwargs <span class="op">=</span> <span class="fu">Dict</span><span class="dt">{Symbol, Any}</span>()</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Separate positional args from kwargs</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> arg <span class="kw">in</span> ex.args[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>]</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arg isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> arg.head <span class="op">==</span> <span class="op">:</span>parameters</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Kwargs after semicolon: s(x; k=5)</span></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> kwarg <span class="kw">in</span> arg.args</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> kwarg isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> kwarg.head <span class="op">==</span> <span class="op">:</span>kw</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>                    kwargs[kwarg.args[<span class="fl">1</span>]] <span class="op">=</span> kwarg.args[<span class="fl">2</span>]</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">end</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> arg isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> arg.head <span class="op">==</span> <span class="op">:</span>kw</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Direct kwarg (shouldn't happen in @formula, but handle anyway)</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>            kwargs[arg.args[<span class="fl">1</span>]] <span class="op">=</span> arg.args[<span class="fl">2</span>]</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Positional argument (variable name)</span></span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, arg)</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert kwargs to positional based on function type</span></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> func <span class="op">==</span> <span class="op">:</span>s</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># s(var, k, penalty_order) - defaults: k=10, penalty_order=2</span></span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(positional, <span class="fu">get</span>(kwargs, <span class="op">:</span>k, <span class="fl">10</span>))</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(positional, <span class="fu">get</span>(kwargs, <span class="op">:</span>penalty_order, <span class="fl">2</span>))</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elseif</span> func <span class="kw">in</span> [<span class="op">:</span>te, <span class="op">:</span>ti]</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>        <span class="co"># te/ti(v1, v2, k1, k2, penalty_order) - defaults: k=(10, 10), penalty_order=2</span></span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="fu">get</span>(kwargs, <span class="op">:</span>k, <span class="fl">10</span>)</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>        penalty_order <span class="op">=</span> <span class="fu">get</span>(kwargs, <span class="op">:</span>penalty_order, <span class="fl">2</span>)</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> k isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> k.head <span class="op">==</span> <span class="op">:</span>tuple</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, k.args[<span class="fl">1</span>])</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, k.args[<span class="fl">2</span>])</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Single value applies to both dimensions</span></span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, k)</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, k)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(positional, penalty_order)</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">Expr</span>(<span class="op">:</span>call, positional<span class="op">...</span>)</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a><span class="st">    @formula(ex)</span></span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a><span class="st">Enhanced formula macro that supports kwargs in smooth terms.</span></span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a><span class="st">This macro shadows `StatsModels.@formula` to preprocess smooth term calls,</span></span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a><span class="st">converting kwargs to positional arguments before passing to StatsModels.</span></span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a><span class="st"># Supported smooth term syntax:</span></span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a><span class="st">- `s(var)` — smooth with defaults (k=10, penalty_order=2)</span></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a><span class="st">- `s(var; k=5)` — custom number of basis functions</span></span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a><span class="st">- `s(var; k=5, penalty_order=3)` — custom penalty order</span></span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a><span class="st">- `te(v1, v2)` — full tensor product with defaults</span></span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a><span class="st">- `te(v1, v2; k=(8, 6))` — tensor with custom dimensions</span></span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a><span class="st">- `ti(v1, v2; k=(5, 4))` — pure interaction tensor</span></span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a><span class="st"># Examples</span></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a><span class="st">```julia</span></span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a><span class="st"># Smooth with kwargs (our extension)</span></span>
<span id="cb8-105"><a href="#cb8-105" aria-hidden="true" tabindex="-1"></a><span class="st">h1 = Hazard(@formula(0 ~ s(age; k=5) + trt), :sp, 1, 2)</span></span>
<span id="cb8-106"><a href="#cb8-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-107"><a href="#cb8-107" aria-hidden="true" tabindex="-1"></a><span class="st"># Tensor product with tuple k</span></span>
<span id="cb8-108"><a href="#cb8-108" aria-hidden="true" tabindex="-1"></a><span class="st">h2 = Hazard(@formula(0 ~ te(age, bmi; k=(8, 6))), :sp, 1, 3)</span></span>
<span id="cb8-109"><a href="#cb8-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-110"><a href="#cb8-110" aria-hidden="true" tabindex="-1"></a><span class="st"># Standard formula (unchanged behavior)</span></span>
<span id="cb8-111"><a href="#cb8-111" aria-hidden="true" tabindex="-1"></a><span class="st">h3 = Hazard(@formula(0 ~ x1 + x2), :wei, 1, 4)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>““” macro formula(ex) transformed = transform_smooth_terms(ex) return :(StatsModels.@formula($transformed)) end</p>
</section>
</section>
</section>
<section id="export-our-versions-shadows-statsmodels-exports" class="level1">
<h1>Export our versions (shadows StatsModels exports)</h1>
<p>export <span class="citation" data-cites="formula">@formula</span>, s, te, ti</p>
<pre><code>
**After preprocessing**, FunctionTerm structure:
```julia
# User writes: @formula(0 ~ s(age; k=5, penalty_order=3))
# After transform: s(age, 5, 3)
# FunctionTerm has:
#   ft.f === s
#   ft.args[1].sym === :age          (Term)
#   ft.args[2].n === 5               (ConstantTerm{Int64})
#   ft.args[3].n === 3               (ConstantTerm{Int64})</code></pre>
<p><strong>Phase 5 additions</strong> — <code>apply_schema</code> dispatch (uses positional args from preprocessing):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Define s, te, ti as callables (done in formula.jl above)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Intercept FunctionTerm{typeof(s)} during schema application</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: Second argument must be schema::StatsModels.Schema for dispatch to work</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(s)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract variable name from first positional argument</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> ft.args[<span class="fl">1</span>].sym</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract k and penalty_order from positional args (set by preprocessing)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">2</span> ? ft.args[<span class="fl">2</span>].n <span class="op">:</span> <span class="fl">10</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">3</span> ? ft.args[<span class="fl">3</span>].n <span class="op">:</span> <span class="fl">2</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate variable exists in schema</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">haskey</span>(schema, ft.args[<span class="fl">1</span>]) <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">"Variable </span><span class="sc">$</span>var<span class="st"> not found in data"</span>))</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check that variable is continuous, not categorical (R10-5)</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    term_type <span class="op">=</span> schema.schema[ft.args[<span class="fl">1</span>]]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    term_type isa CategoricalTerm <span class="op">&amp;&amp;</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">"s(</span><span class="sc">$</span>var<span class="st">) requires a continuous variable. "</span> <span class="op">*</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Variable '</span><span class="sc">$</span>var<span class="st">' is categorical. Use factor coding instead."</span>))</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">SmoothTerm</span>(var, k, penalty_order, <span class="op">:</span>none)  <span class="co"># R10-1: :none is safe default</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Generate model matrix columns for SmoothTerm</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">modelcols</span>(term<span class="op">::</span><span class="dt">SmoothTerm</span>, d<span class="op">::</span><span class="dt">NamedTuple</span>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> d[term.var]  <span class="co"># Extract column from data NamedTuple</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build B-spline basis from data quantiles</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> <span class="fu">build_smooth_basis</span>(x, term.k)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> <span class="fu">evaluate_basis</span>(basis, x)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Center for identifiability (sum-to-zero constraint)</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    B_centered <span class="op">=</span> B <span class="op">.-</span> <span class="fu">mean</span>(B, dims<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_centered</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Required: coefnames for output display</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">coefnames</span>(term<span class="op">::</span><span class="dt">SmoothTerm</span>)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="st">"s(</span><span class="sc">$</span>(term.var)<span class="st">)[</span><span class="sc">$</span>i<span class="st">]"</span> for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>term.k]</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Phase 6 additions for <code>te()</code>/<code>ti()</code></strong> (uses positional args from preprocessing):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: Second argument must be schema::StatsModels.Schema for dispatch to work</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(te)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract two variable names</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    var1 <span class="op">=</span> ft.args[<span class="fl">1</span>].sym</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    var2 <span class="op">=</span> ft.args[<span class="fl">2</span>].sym</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate variables exist in schema</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">haskey</span>(schema, ft.args[<span class="fl">1</span>]) <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">"Variable </span><span class="sc">$</span>var1<span class="st"> not found in data"</span>))</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">haskey</span>(schema, ft.args[<span class="fl">2</span>]) <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">"Variable </span><span class="sc">$</span>var2<span class="st"> not found in data"</span>))</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># k values from positional args (set by preprocessing)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Macro transforms: te(v1, v2; k=(8,6)) → te(v1, v2, 8, 6, 2)</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">3</span> ? ft.args[<span class="fl">3</span>].n <span class="op">:</span> <span class="fl">10</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">4</span> ? ft.args[<span class="fl">4</span>].n <span class="op">:</span> <span class="fl">10</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">5</span> ? ft.args[<span class="fl">5</span>].n <span class="op">:</span> <span class="fl">2</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">TensorTerm</span>((var1, var2), (k1, k2), penalty_order, (<span class="cn">false</span>, <span class="cn">false</span>), (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">false</span>)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: Second argument must be schema::StatsModels.Schema for dispatch to work</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(ti)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    var1 <span class="op">=</span> ft.args[<span class="fl">1</span>].sym</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    var2 <span class="op">=</span> ft.args[<span class="fl">2</span>].sym</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate variables exist in schema</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">haskey</span>(schema, ft.args[<span class="fl">1</span>]) <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">"Variable </span><span class="sc">$</span>var1<span class="st"> not found in data"</span>))</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">haskey</span>(schema, ft.args[<span class="fl">2</span>]) <span class="op">||</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(<span class="st">"Variable </span><span class="sc">$</span>var2<span class="st"> not found in data"</span>))</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">3</span> ? ft.args[<span class="fl">3</span>].n <span class="op">:</span> <span class="fl">10</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">4</span> ? ft.args[<span class="fl">4</span>].n <span class="op">:</span> <span class="fl">10</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> <span class="fu">length</span>(ft.args) <span class="op">&gt;=</span> <span class="fl">5</span> ? ft.args[<span class="fl">5</span>].n <span class="op">:</span> <span class="fl">2</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ti() is interaction-only (excludes main effects)</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">TensorTerm</span>((var1, var2), (k1, k2), penalty_order, (<span class="cn">false</span>, <span class="cn">false</span>), (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">true</span>)</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Model matrix for tensor terms</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">modelcols</span>(term<span class="op">::</span><span class="dt">TensorTerm</span>, d<span class="op">::</span><span class="dt">NamedTuple</span>; time_basis<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">:</span>t <span class="kw">in</span> term.vars</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Special case: time dimension uses hazard's basis</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        time_basis <span class="op">===</span> <span class="cn">nothing</span> <span class="op">&amp;&amp;</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>            <span class="st">"te(..., t) requires time_basis from :sp hazard"</span>))</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... implementation details ...</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Standard case: build separate bases for both variables</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ... implementation details ...</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
<section id="part-1-baseline-hazard-penalties" class="level2">
<h2 class="anchored" data-anchor-id="part-1-baseline-hazard-penalties">Part 1: Baseline Hazard Penalties</h2>
<section id="individual-transition-penalties" class="level3">
<h3 class="anchored" data-anchor-id="individual-transition-penalties">1.1 Individual Transition Penalties</h3>
<p><span class="math display">\[\mathcal{P}_{ind}(\theta) = \sum_{(r,s)} \lambda_{rs} \theta_{rs}^T S_{rs} \theta_{rs}\]</span></p>
<p>where <span class="math inline">\(S_{rs}\)</span> is the Wood (2016) derivative-based penalty matrix.</p>
</section>
<section id="shared-origin-tensor-product-penalties-replacing-total-hazard-penalty" class="level3">
<h3 class="anchored" data-anchor-id="shared-origin-tensor-product-penalties-replacing-total-hazard-penalty">1.2 Shared-Origin Tensor Product Penalties (Replacing Total Hazard Penalty)</h3>
<p>For competing risks from state <span class="math inline">\(r\)</span> to destinations <span class="math inline">\(\{s_1, \ldots, s_D\}\)</span>, use tensor product structure:</p>
<p><span class="math display">\[\log h_{r,d}(t) = f_r(t, d) = \sum_{i=1}^{K_t} \sum_{j=1}^{D} \beta_{ij} B_i(t) \mathbf{1}_{d=j}\]</span></p>
<p><strong>Penalty structure (ANOVA decomposition)</strong>: <span class="math display">\[\mathcal{P}_{tensor}(\boldsymbol{\beta}) = \lambda_t \boldsymbol{\beta}^T (I_D \otimes S_t) \boldsymbol{\beta} + \lambda_d \boldsymbol{\beta}^T (S_d \otimes I_{K_t}) \boldsymbol{\beta}\]</span></p>
<p>where: - <span class="math inline">\(S_t\)</span>: Time smoothness penalty (Wood’s algorithm) - <span class="math inline">\(S_d\)</span>: Destination penalty (ridge by default, shrinks destinations toward each other) - <span class="math inline">\(\lambda_t\)</span>: Smoothing for time dimension - <span class="math inline">\(\lambda_d\)</span>: Smoothing across destinations</p>
<p><strong>Advantages over ad-hoc total hazard penalty</strong>: - Shrinks destinations toward each other (not toward sum) - Clean probabilistic interpretation (random effects on destinations) - Borrows strength for sparse transitions - Subsumes total hazard penalty as special case</p>
<hr>
</section>
</section>
<section id="part-2-covariate-splines" class="level2">
<h2 class="anchored" data-anchor-id="part-2-covariate-splines">Part 2: Covariate Splines</h2>
<section id="target-api" class="level3">
<h3 class="anchored" data-anchor-id="target-api">2.1 Target API</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Smooth nonlinear covariate effects</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> trt), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age, k<span class="op">=</span><span class="fl">5</span>) <span class="op">+</span> <span class="fu">s</span>(bmi, k<span class="op">=</span><span class="fl">3</span>)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">2.2 Implementation</h3>
<p><strong>Formula parsing</strong>: Intercept <code>s()</code> terms from StatsModels formula</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SmoothTerm <span class="op">&lt;:</span><span class="dt"> StatsModels.AbstractTerm</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    var<span class="op">::</span><span class="dt">Symbol           </span><span class="co"># Variable name</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">::</span><span class="dt">Int                </span><span class="co"># Number of basis functions</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    penalty_order<span class="op">::</span><span class="dt">Int    </span><span class="co"># Derivative order for penalty (default 2)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    extrapolation<span class="op">::</span><span class="dt">Symbol </span><span class="co"># :none (default), :linear, :constant (R10-1: :none is safe default)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># </span><span class="al">NOTE</span><span class="co">: `by` field REMOVED from initial scope. Varying coefficients are future work.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Model matrix construction</strong>: 1. <strong>Validation</strong>: Check <code>n_unique(x) &gt;= k</code>. If <code>n_unique &lt; k</code>, throw informative error (R11-2). 2. Build B-spline basis for covariate from data quantiles 3. Evaluate basis at each observation 4. Center for identifiability (sum-to-zero constraint)</p>
<p><strong>Penalty</strong>: Independent <span class="math inline">\(\lambda_j\)</span> per smooth term: <span class="math display">\[\mathcal{P}_{cov}(\gamma) = \sum_{j} \lambda_j \gamma_j^T S_j \gamma_j\]</span></p>
</section>
<section id="identifiability" class="level3">
<h3 class="anchored" data-anchor-id="identifiability">2.3 Identifiability</h3>
<p>Smooth + intercept non-identifiable without constraints. Use <strong>sum-to-zero</strong> via centering: <span class="math display">\[\sum_i s(x_i) = 0\]</span></p>
</section>
<section id="basis-centering-and-prediction" class="level3">
<h3 class="anchored" data-anchor-id="basis-centering-and-prediction">2.4 Basis Centering and Prediction</h3>
<section id="critical-distinction-basis-centering-vs-covariate-scaling" class="level4">
<h4 class="anchored" data-anchor-id="critical-distinction-basis-centering-vs-covariate-scaling">Critical Distinction: Basis Centering vs Covariate Scaling</h4>
<p>There are two separate preprocessing concerns often conflated:</p>
<ol type="1">
<li><strong>Basis centering</strong>: Subtracting column means from the B-spline design matrix for identifiability</li>
<li><strong>Covariate scaling</strong>: Standardizing covariate values before basis construction</li>
</ol>
<p>These serve different purposes and should be evaluated independently.</p>
</section>
<section id="basis-centering-required-for-identifiability" class="level4">
<h4 class="anchored" data-anchor-id="basis-centering-required-for-identifiability">Basis Centering: REQUIRED for Identifiability</h4>
<p>Centering the basis matrix <span class="math inline">\(\tilde{B} = B - \bar{B}\)</span> ensures: - Sum-to-zero constraint: <span class="math inline">\(\sum_i f(x_i) = 0\)</span> - Identifiability with intercept - Coefficients <span class="math inline">\(\tilde{\gamma}\)</span> are interpretable as deviations</p>
<p><strong>This is non-negotiable</strong> — without it, the smooth intercept and model intercept are aliased.</p>
</section>
<section id="covariate-scaling-honest-assessment" class="level4">
<h4 class="anchored" data-anchor-id="covariate-scaling-honest-assessment">Covariate Scaling: HONEST ASSESSMENT</h4>
<p>After examining how established packages handle this:</p>
<p><strong>What MixedModels.jl does</strong>: Nothing. The package uses raw model matrices directly via <code>FeMat</code> and <code>FeTerm</code> structures with no preprocessing of fixed effects covariates. The optimization operates on the original scale.</p>
<p><strong>What survival (R’s coxph) does</strong>: A nuanced approach. - Computes column means: <code>means = colMeans(X)</code> - Does NOT modify the design matrix during fitting - Centers the <em>linear predictor</em> post-hoc: <code>lp = X %*% coef - sum(coef * means)</code> - Leaves binary (0/1) variables uncentered via <code>nocenter</code> argument (default <code>c(-1, 0, 1)</code>)</p>
<p>Key insight from survival’s <a href="https://github.com/therneau/survival/blob/master/R/coxph.fit.R">coxph.fit.R</a>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>zero.one <span class="ot">&lt;-</span> <span class="fu">apply</span>(x, <span class="dv">2</span>, <span class="cf">function</span>(z) <span class="fu">all</span>(z <span class="sc">%in%</span> nocenter))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Binary indicators are left alone</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Arguments FOR covariate scaling:</strong> - Better penalty comparability across terms with different units (the mgcv rationale) - Improved numerical conditioning when covariates have very different scales</p>
<p><strong>Arguments AGAINST covariate scaling:</strong> 1. <strong>Complexity cost</strong>: Requires storing scale factors, transforming for prediction, back-transforming for interpretation 2. <strong>Not done by major packages</strong>: Neither MixedModels.jl nor survival preprocess covariates this way 3. <strong>Optimizer handles it</strong>: Modern optimizers (BFGS, Newton) adapt to parameter scales via Hessian 4. <strong>Interpretation burden</strong>: Users expect coefficients on natural scale 5. <strong>Asymmetric treatment</strong>: Would need special handling for binary/categorical (survival’s <code>nocenter</code> pattern)</p>
<p><strong>Recommendation: Do NOT scale covariates.</strong></p>
<p>The penalty comparability argument (mgcv’s rationale) is valid for automatic smoothness selection, but: - Our cross-validation and AIC approaches for λ selection are scale-invariant - The added complexity isn’t justified given what successful packages do - Better to let users handle extreme scale mismatches explicitly if needed</p>
</section>
<section id="why-not-scale-time" class="level4">
<h4 class="anchored" data-anchor-id="why-not-scale-time">Why NOT Scale Time?</h4>
<p>Time scaling would: - Break consistency with existing <code>compute_hazard()</code>, <code>cumulative_incidence()</code> APIs - Require transforming boundary knots and all time-related outputs - Complicate interpretation (hazard per scaled-time-unit?)</p>
<p>The existing <code>:sp</code> family works on original time scale. Covariate splines should match.</p>
</section>
<section id="storage-requirements" class="level4">
<h4 class="anchored" data-anchor-id="storage-requirements">Storage Requirements</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SmoothTermInfo</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    term<span class="op">::</span><span class="dt">SmoothTerm              </span><span class="co"># Original term specification</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    breakpoints<span class="op">::</span><span class="dt">Vector{Float64}  </span><span class="co"># Breakpoints for BSplineBasis (R10-4: knots only, reconstruct basis)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    order<span class="op">::</span><span class="dt">Int                    </span><span class="co"># BSpline order (4 for cubic)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    centering_vec<span class="op">::</span><span class="dt">Vector{Float64}  </span><span class="co"># Column means of B-spline basis matrix (R4-4)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                                    <span class="co"># Dimension: k (number of basis functions)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>                                    <span class="co"># centering_vec[j] = (1/n) Σᵢ Bⱼ(xᵢ) for j=1,...,k</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                                    <span class="co"># Used for prediction: B̃(x) = B(x) - centering_vec</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    x_range<span class="op">::</span><span class="dt">Tuple{Float64, Float64}  </span><span class="co"># (min, max) for plotting and extrapolation checks</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Reconstruct basis on demand (cheap operation):</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">get_basis</span>(info<span class="op">::</span><span class="dt">SmoothTermInfo</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">BSplineBasis</span>(<span class="fu">BSplineOrder</span>(info.order), info.breakpoints)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Note: Since we’re not scaling covariates, the struct is simpler. If users have extreme scale mismatches causing numerical issues, they can pre-transform their data.</p>
</section>
<section id="prediction-at-new-covariate-values" class="level4">
<h4 class="anchored" data-anchor-id="prediction-at-new-covariate-values">Prediction at New Covariate Values</h4>
<p>To evaluate <span class="math inline">\(f(x_{new})\)</span> at new covariate values:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">evaluate_smooth</span>(info<span class="op">::</span><span class="dt">SmoothTermInfo</span>, x_new<span class="op">::</span><span class="dt">Real</span>, γ̃<span class="op">::</span><span class="dt">Vector{Float64}</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check extrapolation (R10-1: fail by default)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    x_min, x_max <span class="op">=</span> info.x_range</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x_new <span class="op">&lt;</span> x_min <span class="op">||</span> x_new <span class="op">&gt;</span> x_max</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        info.term.extrapolation <span class="op">==</span> <span class="op">:</span>none <span class="op">&amp;&amp;</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Value x=</span><span class="sc">$</span>x_new<span class="st"> outside training range [</span><span class="sc">$</span>x_min<span class="st">, </span><span class="sc">$</span>x_max<span class="st">]. "</span> <span class="op">*</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>            <span class="st">"Set extrapolation=:linear or :constant to allow extrapolation."</span>))</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Handle other extrapolation modes...</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Reconstruct basis (cheap operation)</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> <span class="fu">get_basis</span>(info)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Evaluate basis at covariate location</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    B_new <span class="op">=</span> [<span class="fu">evaluate</span>(basis, i, x_new) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(basis)]  <span class="co"># k-vector</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Apply centering offset</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    B_centered <span class="op">=</span> B_new <span class="op">.-</span> info.centering_vec</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Compute smooth value</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">dot</span>(B_centered, γ̃)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="uncentered-coefficients" class="level4">
<h4 class="anchored" data-anchor-id="uncentered-coefficients">Uncentered Coefficients</h4>
<p>Sometimes we want interpretable coefficients on the original basis (e.g., for comparison with other software):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">uncenter_coefficients</span>(γ̃<span class="op">::</span><span class="dt">Vector{Float64}</span>, info<span class="op">::</span><span class="dt">SmoothTermInfo</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Centered: f(x) = (B(x) - B̄)' γ̃</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Uncentered: f(x) = B(x)' γ - c</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># where γ = γ̃ and c = B̄' γ̃</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    γ <span class="op">=</span> γ̃  <span class="co"># Coefficients are the same</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    intercept_adjustment <span class="op">=</span> <span class="fu">dot</span>(info.centering_vec, γ̃)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (coefficients<span class="op">=</span>γ, intercept_adjustment<span class="op">=</span>intercept_adjustment)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Note</strong>: The intercept absorbs the centering constant, so <code>model_intercept_effective = model_intercept - intercept_adjustment</code>.</p>
<hr>
</section>
</section>
</section>
<section id="part-3-post-processing-and-prediction" class="level2">
<h2 class="anchored" data-anchor-id="part-3-post-processing-and-prediction">Part 3: Post-Processing and Prediction</h2>
<section id="smooth-function-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="smooth-function-evaluation">3.1 Smooth Function Evaluation</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="st">    smooth_effect(fitted, term::Symbol, x_values; ci_level=0.95, n_samples=1000)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="st">Evaluate a smooth term at specified covariate values with confidence intervals.</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="st"># Returns</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="st">DataFrame with columns: x, estimate, lower, upper, se</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">smooth_effect</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, term<span class="op">::</span><span class="dt">Symbol</span>, x_values; </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                       ci_level<span class="op">=</span><span class="fl">0.95</span>, n_samples<span class="op">=</span><span class="fl">1000</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get smooth term info</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    info <span class="op">=</span> fitted.smooth_terms[term]</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get coefficients and vcov for this term</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    γ̃ <span class="op">=</span> <span class="fu">extract_smooth_coefficients</span>(fitted, term)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    V_γ <span class="op">=</span> <span class="fu">extract_smooth_vcov</span>(fitted, term)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Evaluate at each x value</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    estimates <span class="op">=</span> [<span class="fu">evaluate_smooth</span>(info, x, γ̃) for x <span class="kw">in</span> x_values]</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulation-based CIs (Bayesian posterior)</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> <span class="fu">rand</span>(<span class="fu">MvNormal</span>(γ̃, V_γ), n_samples)</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    ci_matrix <span class="op">=</span> <span class="fu">zeros</span>(<span class="fu">length</span>(x_values), n_samples)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i, x) <span class="kw">in</span> <span class="fu">enumerate</span>(x_values)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n_samples</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            ci_matrix[i, j] <span class="op">=</span> <span class="fu">evaluate_smooth</span>(info, x, samples[<span class="op">:</span>, j])</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    lower <span class="op">=</span> [<span class="fu">quantile</span>(ci_matrix[i, <span class="op">:</span>], (<span class="fl">1</span> <span class="op">-</span> ci_level)<span class="op">/</span><span class="fl">2</span>) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(x_values)]</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    upper <span class="op">=</span> [<span class="fu">quantile</span>(ci_matrix[i, <span class="op">:</span>], <span class="fl">1</span> <span class="op">-</span> (<span class="fl">1</span> <span class="op">-</span> ci_level)<span class="op">/</span><span class="fl">2</span>) for i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu">length</span>(x_values)]</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    se <span class="op">=</span> <span class="fu">std</span>.(<span class="fu">eachrow</span>(ci_matrix))</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">DataFrame</span>(x<span class="op">=</span>x_values, estimate<span class="op">=</span>estimates, se<span class="op">=</span>se, lower<span class="op">=</span>lower, upper<span class="op">=</span>upper)</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="integration-with-existing-predict-interface" class="level3">
<h3 class="anchored" data-anchor-id="integration-with-existing-predict-interface">3.2 Integration with Existing Predict Interface</h3>
<p>Extend <code>compute_hazard()</code> and <code>compute_cumulative_hazard()</code> to handle new covariate values:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="st">    compute_hazard(t, fitted, hazard; covariates=nothing, subj=1)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="st">Extended: if `covariates` is provided as a NamedTuple, use those values</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="st">instead of looking up from subject data.</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compute_hazard</span>(t, fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, hazard<span class="op">::</span><span class="dt">Symbol</span>; </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>                        covariates<span class="op">=</span><span class="cn">nothing</span>, subj<span class="op">=</span><span class="fl">1</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="fu">isnothing</span>(covariates)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Original behavior: look up from data</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">compute_hazard_from_data</span>(t, fitted, hazard, subj)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># New: evaluate with specified covariate values</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">compute_hazard_at_covariates</span>(t, fitted, hazard, covariates)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="effective-degrees-of-freedom-per-term" class="level3">
<h3 class="anchored" data-anchor-id="effective-degrees-of-freedom-per-term">3.3 Effective Degrees of Freedom per Term</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="st">    effective_df(fitted, term::Symbol)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="st">Compute effective degrees of freedom for a smooth term.</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">effective_df</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, term<span class="op">::</span><span class="dt">Symbol</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># edf_j = tr(S_j^{-1} H_λ,j)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># where H_λ,j is the penalized Hessian block for term j</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="st">    smooth_summary(fitted)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="st">Summary table of all smooth terms with edf, p-values, etc.</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">smooth_summary</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>)</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Similar to mgcv's summary.gam() output</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="plotting-support" class="level3">
<h3 class="anchored" data-anchor-id="plotting-support">3.4 Plotting Support</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="st">    plot_smooth(fitted, term::Symbol; ci_level=0.95, n_points=100)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="st">Generate plot data for a smooth term (returns data, not plot object).</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">plot_smooth</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, term<span class="op">::</span><span class="dt">Symbol</span>; </span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                     ci_level<span class="op">=</span><span class="fl">0.95</span>, n_points<span class="op">=</span><span class="fl">100</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    info <span class="op">=</span> fitted.smooth_terms[term]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate evaluation grid on original scale</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    x_grid <span class="op">=</span> <span class="fu">range</span>(info.x_range[<span class="fl">1</span>], info.x_range[<span class="fl">2</span>], length<span class="op">=</span>n_points)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">smooth_effect</span>(fitted, term, <span class="fu">collect</span>(x_grid); ci_level<span class="op">=</span>ci_level)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
<section id="part-4-general-tensor-product-splines" class="level2">
<h2 class="anchored" data-anchor-id="part-4-general-tensor-product-splines">Part 4: General Tensor Product Splines</h2>
<section id="target-api-1" class="level3">
<h3 class="anchored" data-anchor-id="target-api-1">4.1 Target API</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Time-varying covariate effect</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Pure interaction (excluding main effects)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> <span class="fu">s</span>(t) <span class="op">+</span> <span class="fu">ti</span>(age, t)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="basis-construction" class="level3">
<h3 class="anchored" data-anchor-id="basis-construction">4.2 Basis Construction</h3>
<p>For <code>te(x1, x2)</code>: <span class="math display">\[f(x_1, x_2) = \sum_{i,j} \beta_{ij} B_{1i}(x_1) B_{2j}(x_2)\]</span></p>
<p><strong>Efficient evaluation</strong> (avoid forming full Kronecker product):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">eval_tensor_term</span>(beta_mat, B1_vals, B2_vals)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># O(n * k1 * k2) instead of O(n * k1² * k2²)</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">sum</span>((B1_vals <span class="op">*</span> beta_mat) <span class="op">.*</span> B2_vals, dims<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="monotone-tensor-products" class="level3">
<h3 class="anchored" data-anchor-id="monotone-tensor-products">4.3 Monotone Tensor Products</h3>
<p>Tensor products can enforce monotonicity in one or both dimensions:</p>
<p><strong>API</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Monotone increasing in time only</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t, monotone<span class="op">=</span>(<span class="cn">false</span>, <span class="cn">true</span>))), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Monotone increasing in both dimensions</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t, monotone<span class="op">=</span>(<span class="cn">true</span>, <span class="cn">true</span>))), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Shared-origin tensor with monotone time</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(<span class="op">...</span>;</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> <span class="fu">Dict</span>(<span class="fl">1</span> <span class="op">=&gt;</span> <span class="fu">SharedOriginConfig</span>(monotone_time<span class="op">=</span><span class="cn">true</span>, increasing<span class="op">=</span><span class="cn">true</span>))</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Implementation (I-spline cumulative differencing)</strong>:</p>
<p>For monotone dimension <span class="math inline">\(j\)</span> with I-spline basis, the transformation from estimation-scale parameters <span class="math inline">\(\tilde{\beta}\)</span> to spline coefficients <span class="math inline">\(\beta\)</span> uses cumulative sums:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For 1D monotone spline (existing infrastructure in spline.jl)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ests_to_coefs_monotone</span>(ests, knots, order)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    coefs <span class="op">=</span> <span class="fu">similar</span>(ests)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    coefs[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">exp</span>(ests[<span class="fl">1</span>])  <span class="co"># Intercept</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fu">length</span>(coefs)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cumulative sum with knot-spacing weights</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        coefs[i] <span class="op">=</span> coefs[i<span class="op">-</span><span class="fl">1</span>] <span class="op">+</span> <span class="fu">exp</span>(ests[i]) <span class="op">*</span> (knots[i <span class="op">+</span> order] <span class="op">-</span> knots[i]) <span class="op">/</span> order</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coefs</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co"># For tensor product with monotonicity in dimension 2 (columns)</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ests_to_coefs_tensor_monotone_dim2</span>(ests_mat, knots2, order2)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> <span class="fu">size</span>(ests_mat)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    coefs_mat <span class="op">=</span> <span class="fu">similar</span>(ests_mat)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>k1</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply 1D monotone transform to each row (across dim 2)</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        coefs_mat[i, <span class="op">:</span>] <span class="op">=</span> <span class="fu">ests_to_coefs_monotone</span>(ests_mat[i, <span class="op">:</span>], knots2, order2)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coefs_mat</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Key insight</strong>: Monotonicity is enforced by: 1. Storing parameters on log scale (<span class="math inline">\(\tilde{\beta}\)</span>) 2. Exponentiating to ensure positivity (<span class="math inline">\(\exp(\tilde{\beta}) \geq 0\)</span>) 3. Cumulative summing along monotone dimension 4. Knot-spacing weights <span class="math inline">\((t_{i+k} - t_i)/k\)</span> ensure correct I-spline integration</p>
<p><strong>Penalty for monotone dimensions</strong>: - Penalty applies to estimation-scale parameters <span class="math inline">\(\tilde{\beta}\)</span>, NOT to the transformed coefficients - This induces shrinkage toward constant (flat) surfaces, not toward zero - Formula: <span class="math inline">\(\mathcal{P} = \lambda \tilde{\beta}^T S \tilde{\beta}\)</span></p>
</section>
<section id="handling-partial-domains" class="level3">
<h3 class="anchored" data-anchor-id="handling-partial-domains">4.4 Handling Partial Domains</h3>
<p>When data doesn’t fill tensor product domain (e.g., age × time with triangular support): 1. Identify unsupported basis functions 2. Drop corresponding penalty matrix rows 3. Constrain unsupported coefficients to zero</p>
<hr>
</section>
</section>
<section id="existing-infrastructure" class="level2">
<h2 class="anchored" data-anchor-id="existing-infrastructure">Existing Infrastructure</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 34%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Component</th>
<th style="text-align: left;">Location</th>
<th style="text-align: left;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Per-subject gradients</td>
<td style="text-align: left;"><code>compute_subject_gradients()</code> → <code>Matrix{Float64}</code> (p × n)</td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="even">
<td style="text-align: left;">Per-subject Hessians</td>
<td style="text-align: left;"><code>compute_subject_hessians()</code> → <code>Vector{Matrix{Float64}}</code></td>
<td style="text-align: left;">✅ Ready (R8-7: convert to Array{Float64,3} via <code>cat(..., dims=3)</code>)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PIJCV infrastructure</td>
<td style="text-align: left;"><code>PIJCVState</code> in <code>src/output/variance.jl</code></td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="even">
<td style="text-align: left;">Cholesky downdate</td>
<td style="text-align: left;"><code>cholesky_downdate!()</code> in <code>src/output/variance.jl</code></td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Spline knot/degree storage</td>
<td style="text-align: left;"><code>RuntimeSplineHazard</code></td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="even">
<td style="text-align: left;">Quantile knot placement</td>
<td style="text-align: left;"><code>place_interior_knots()</code></td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Monotone spline transforms</td>
<td style="text-align: left;"><code>spline_ests2coefs()</code>, I-spline basis</td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="even">
<td style="text-align: left;">Dense Hessian optimizer</td>
<td style="text-align: left;">Ipopt via <code>fit()</code></td>
<td style="text-align: left;">✅ Ready</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NCV criterion function</td>
<td style="text-align: left;"><code>pijcv_criterion()</code> in <code>src/output/variance.jl</code></td>
<td style="text-align: left;">✅ Ready (R8-13)</td>
</tr>
</tbody>
</table>
<p><strong>Note on <code>PIJCVState</code></strong>: The existing infrastructure computes leave-one-out parameter perturbations <span class="math inline">\(\hat{\theta}^{-k}\)</span> via Cholesky downdating AND provides <code>pijcv_criterion(state, params, loss_fn, data)</code> for NCV evaluation. We just need to provide the appropriate <code>loss_fn</code> (negative log-likelihood).</p>
<hr>
</section>
<section id="implementation-phases" class="level2">
<h2 class="anchored" data-anchor-id="implementation-phases">Implementation Phases</h2>
<section id="phase-0-infrastructure-preparation-2-3-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-0-infrastructure-preparation-2-3-days">Phase 0: Infrastructure Preparation (2-3 days)</h3>
<p><strong>Files:</strong> <code>src/utilities/constants.jl</code>, <code>src/types/hazard_structs.jl</code>, <code>Project.toml</code>, <code>src/construction/formula.jl</code> (NEW)</p>
<ul class="task-list">
<li><p><label><input type="checkbox"><strong>BSplineKit version constraint</strong> (R5-4, R8-3):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add to Project.toml [compat] section:</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">BSplineKit</span> <span class="op">=</span> <span class="st">"0.17"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Required imports</strong> (Issue #23 - verify in Project.toml):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode toml code-with-copy"><code class="sourceCode toml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Already present:</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">BSplineKit</span> <span class="op">=</span> <span class="st">"093aae92-e908-43d7-9660-e50ee39d5a0a"</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="dt">LinearAlgebra</span> <span class="op">=</span> <span class="st">"37e2e46d-f89d-539d-b4ee-838fcccc9c8e"</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dt">SparseArrays</span> <span class="op">=</span> <span class="st">"2f01184e-e22b-5df5-ae63-d93ebab69eaf"</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co"># BSplineKit ≥ 0.17 required for recombination_matrix()</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Shadowed <span class="citation" data-cites="formula">@formula</span> macro</strong> (R5-1) — Create <code>src/construction/formula.jl</code>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implements:</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"># - transform_smooth_terms(ex) - preprocess kwargs to positional</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># - transform_smooth_call(ex) - handle s(), te(), ti() individually</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># - @formula macro that shadows StatsModels.@formula</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co"># - function s end, function te end, function ti end</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co"># See "Implementation Phases for StatsModels Integration" section for full code</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Export shadowed <span class="citation" data-cites="formula">@formula</span></strong> — Update <code>src/MultistateModels.jl</code>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Include the formula module early (before other construction files)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">include</span>(<span class="st">"construction/formula.jl"</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Export our @formula, s, te, ti (shadows StatsModels exports)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">export</span> <span class="pp">@formula</span>, s, te, ti</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Add penalty constants to <code>constants.jl</code>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> PENALTY_ORDER_DEFAULT <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SMOOTHING_PARAM_LOWER <span class="op">=</span> <span class="op">-</span><span class="fl">20.0</span>  <span class="co"># log scale (R5-7: λ ≈ 2×10⁻⁹)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SMOOTHING_PARAM_UPPER <span class="op">=</span> <span class="fl">20.0</span>   <span class="co"># log scale (R5-7: λ ≈ 5×10⁸)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> PENALTY_MATRIX_TOL <span class="op">=</span> <span class="fl">1e-10</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Bounds justification (R5-7):</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co"># log(λ) ∈ [-20, 20] corresponds to λ ∈ [2×10⁻⁹, 5×10⁸]</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="co"># - Below λ ~ 10⁻⁹: penalty negligible (effectively unpenalized)</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co"># - Above λ ~ 10⁸: all penalized coefficients shrink to near-zero</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="co"># - Matches mgcv defaults; covers all practically relevant smoothing levels</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: For truly unpenalized fits (λ=0 exactly), users should call</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="co"># fit(model) without penalized=true. The lower bound λ≈10⁻⁹ is</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co"># effectively unpenalized for all practical purposes.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Create <code>PenaltyConfig</code> struct (created during <code>fit()</code>, stored in fitted result):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: PenaltyConfig is NOT a field in MultistateModel (unfitted).</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co"># It is created during fit() and stored in MultistateModelFitted.ConvergenceRecords.</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"># This avoids modifying the existing MultistateModelFitted struct definition.</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> PenaltyConfig</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    penalty_matrices<span class="op">::</span><span class="dt">Dict{Symbol, Matrix{Float64}}  </span><span class="co"># hazname → S</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    smoothing_params<span class="op">::</span><span class="dt">Dict{Symbol, Float64}          </span><span class="co"># hazname → log(λ)</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    shared_origin_configs<span class="op">::</span><span class="dt">Vector{SharedOriginTensorConfig}</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="co"># STORAGE (R8-1, R8-4, R9-4): Store in ConvergenceRecords NamedTuple.</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co"># ConvergenceRecords is an IMMUTABLE NamedTuple — cannot assign to field!</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the complete NamedTuple at fit() completion:</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="co"># In fit(...; penalized=true), at the </span><span class="re">END</span><span class="co"> of the function:</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>penalty_records <span class="op">=</span> (</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    penalty_config <span class="op">=</span> <span class="fu">PenaltyConfig</span>(<span class="op">...</span>),</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    smoothing_trace <span class="op">=</span> smoothing_trace,  <span class="co"># Optional: optimization history</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>ConvergenceRecords <span class="op">=</span> penalized ? <span class="fu">merge</span>(base_records, penalty_records) <span class="op">:</span> base_records</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Access via: fitted.ConvergenceRecords.penalty_config</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a><span class="co"># This requires NO changes to MultistateModelFitted struct definition.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Create <code>SharedOriginConfig</code> struct:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SharedOriginConfig</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    dest_penalty<span class="op">::</span><span class="dt">Union{Symbol, Matrix{Float64}}  </span><span class="co"># :ridge, :difference, or custom</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    monotone_time<span class="op">::</span><span class="dt">Bool</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    increasing<span class="op">::</span><span class="dt">Bool</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Add validation using <code>ArgumentError</code> (package convention)</label></p></li>
</ul>
</section>
<section id="phase-1-penalty-matrix-construction-4-5-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-1-penalty-matrix-construction-4-5-days">Phase 1: Penalty Matrix Construction (4-5 days)</h3>
<p><strong>File:</strong> New <code>src/inference/penalty.jl</code></p>
<ul class="task-list">
<li><p><label><input type="checkbox"><code>compute_derivative_penalty_matrix(basis, order)</code> — Wood’s algorithm</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compute_derivative_penalty_matrix</span>(basis<span class="op">::</span><span class="dt">BSplineBasis</span>, order<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute Galerkin matrix of the k-th derivative</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ∫ B^(k)(t) B^(k)(t)^T dt</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns a BandedMatrix, convert to Matrix for general use</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    S_banded <span class="op">=</span> <span class="fu">galerkin_matrix</span>(basis, (<span class="fu">Derivative</span>(order), <span class="fu">Derivative</span>(order)))</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">Matrix</span>(S_banded)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<blockquote class="blockquote">
<p><strong>Note (R10-2)</strong>: The penalty matrix S is ALWAYS rank-deficient with nullity = <code>order</code>. For 2nd derivative penalty (default), rank(S) = k - 2 (null space = constant + linear). This is mathematically correct: polynomials of degree &lt; order have zero penalty. The Fisher information matrix regularizes during optimization: I_p = I + λS is full rank.</p>
</blockquote></li>
<li><p><label><input type="checkbox"><strong>RecombinedBSplineBasis handling</strong> (verified with BSplineKit v0.17):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb34"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">BSplineKit</span>: recombination_matrix</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"># BSplineKit provides recombination_matrix(Br) which returns R</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co"># R has dimensions (k_original × k_recombined)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co"># For Derivative(1) constraint (constant extrapolation): first two and last two</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">#   original basis functions are combined, reducing dimension by 2.</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co"># For Natural() constraint: similar reduction at boundaries.</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compute_penalty_for_recombined_basis</span>(recombined_basis<span class="op">::</span><span class="dt">RecombinedBSplineBasis</span>, </span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>                                               penalty_order<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. Get the parent (original) basis</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    parent_basis <span class="op">=</span> <span class="fu">parent</span>(recombined_basis)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Compute penalty matrix for original basis (Wood's algorithm)</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    S_original <span class="op">=</span> <span class="fu">compute_derivative_penalty_matrix</span>(parent_basis, penalty_order)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Extract recombination matrix R (k_orig × k_recomb)</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> <span class="fu">Matrix</span>(<span class="fu">recombination_matrix</span>(recombined_basis))</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Transform: S_recombined = R' * S_original * R</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    S_recombined <span class="op">=</span> R<span class="op">'</span> <span class="op">*</span> S_original <span class="op">*</span> R</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S_recombined</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Verification test:</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a><span class="co"># For coefficients β_recomb in recombined basis and β_orig = R * β_recomb,</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a><span class="co"># the penalty β_recomb' * S_recombined * β_recomb should equal</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a><span class="co"># β_orig' * S_original * β_orig.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Dimension tracking</strong>: Natural splines reduce basis dimension by 2 (one constraint per boundary). Penalty matrix dimensions must match the recombined basis, not the original.</label></p></li>
<li><p><label><input type="checkbox">Banded structure for efficiency</label></p></li>
<li><p><label><input type="checkbox">Verify against R’s <code>mgcv::smoothCon</code></label></p></li>
<li><p><label><input type="checkbox">Unit tests for penalty matrices</label></p></li>
</ul>
</section>
<section id="phase-2-penalized-likelihood-2-3-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-2-penalized-likelihood-2-3-days">Phase 2: Penalized Likelihood (2-3 days)</h3>
<p><strong>File:</strong> New <code>src/inference/penalized.jl</code></p>
<ul class="task-list">
<li><label><input type="checkbox"><code>penalized_loglik(params, data, penalty_config)</code> wrapper</label></li>
<li><label><input type="checkbox">Individual transition penalties (block diagonal)</label></li>
<li><label><input type="checkbox">Shared-origin tensor penalties</label></li>
<li><label><input type="checkbox">ForwardDiff compatibility (penalty Hessian is constant, precomputable)</label></li>
<li><label><input type="checkbox"><strong>Parameter bounds interaction</strong> (Issue #18):</label>
<ul>
<li>Penalties compose additively with bounded optimization (<code>lb</code>, <code>ub</code> in Optim)</li>
<li>No special handling needed: penalty gradient/Hessian added to likelihood’s</li>
<li>Edge case: Boundary-active parameters have degenerate posterior variance → confidence intervals should reflect this (bounded CI extends to bound)</li>
<li>Test: Fit model with both penalty and box constraints, verify convergence</li>
</ul></li>
</ul>
<p><strong>Penalty convention</strong> (matching Wood 2017, mgcv): <span class="math display">\[\ell_p(\theta; \lambda) = \ell(\theta) - \frac{1}{2} \sum_j \lambda_j \theta^T S_j \theta\]</span></p>
<p>Derivatives for penalty term <span class="math inline">\(\mathcal{P}_j = \frac{1}{2}\lambda_j \theta^T S_j \theta\)</span>: - Gradient: <span class="math inline">\(\nabla_\theta \mathcal{P}_j = \lambda_j S_j \theta\)</span> - Hessian: <span class="math inline">\(\nabla^2_\theta \mathcal{P}_j = \lambda_j S_j\)</span> (constant)</p>
<p><strong>Note</strong>: The <span class="math inline">\(\frac{1}{2}\)</span> factor is standard (matches REML derivations). Some sources omit it and absorb into <span class="math inline">\(\lambda\)</span>; we include it explicitly for clarity.</p>
</section>
<section id="phase-3-smoothing-parameter-selection-5-6-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-3-smoothing-parameter-selection-5-6-days">Phase 3: Smoothing Parameter Selection (5-6 days)</h3>
<p><strong>File:</strong> New <code>src/inference/smoothing.jl</code></p>
<ul class="task-list">
<li><p><label><input type="checkbox"><strong>Leverage existing <code>pijcv_criterion()</code> from <code>variance.jl</code></strong>: The infrastructure already exists in <code>src/output/variance.jl</code>:</label></p>
<ul>
<li><code>PIJCVState</code> struct (line 1543)</li>
<li><code>pijcv_criterion(state, params, loss_fn, data)</code> (line 1978)</li>
<li><code>pijcv_criterion_quadratic()</code> for robustness (line 2020)</li>
<li><code>compute_pijcv_perturbations!()</code> for LOO deltas (line 1918)</li>
</ul>
<p><strong>What we need to add:</strong></p>
<ul>
<li>Wrapper that constructs the penalized Fisher information <span class="math inline">\(I_p = I + \lambda S\)</span> (where <span class="math inline">\(I = -H\)</span> is the unpenalized Fisher info, positive definite)</li>
<li>Loss function that evaluates deviance at LOO parameters</li>
<li>Integration with <code>fit()</code> to trigger smoothing selection</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">select_smoothing_params</span>(model, data, penalty_matrices; </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                                 init_log_λ<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. If init_log_λ not provided, use heuristic:</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#    log(λ₀) = -3 - log(‖S‖_F) for each penalty matrix</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Construct PIJCVState with penalized Fisher info I_p = I + λS</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. Call existing pijcv_criterion() in optimization loop</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. Return optimal log(λ) values</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Loss function for NCV</strong> (Issue #9, R4-5): The <code>pijcv_criterion(state, params, loss_fn, data)</code> function requires a <code>loss_fn</code> argument. For smoothing parameter selection, we use the <strong>negative log-likelihood</strong> as the loss.</p>
<p><strong>Sign convention (critical)</strong>:</p>
<ul>
<li>Log-likelihood <span class="math inline">\(\ell_i(\theta)\)</span> is the quantity we MAXIMIZE</li>
<li>Loss is the quantity we MINIMIZE</li>
<li>Therefore: <code>loss_fn</code> returns <span class="math inline">\(-\ell_i(\theta)\)</span> (negative log-likelihood)</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb36"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># loss_fn signature: (params, data, subject_index) -&gt; scalar loss</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Returns NEGATIVE log-likelihood for subject k at parameters params</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"># The NCV criterion minimizes leave-one-out prediction error (summed losses)</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ncv_loss_fn</span>(params<span class="op">::</span><span class="dt">AbstractVector</span>, data, k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute log-likelihood for subject k at params</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    loglik_k <span class="op">=</span> <span class="fu">compute_subject_loglik</span>(params, data, k)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return NEGATIVE log-likelihood (loss to minimize)</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>loglik_k</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Deviance version (scaled by 2):</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">deviance_loss_fn</span>(params<span class="op">::</span><span class="dt">AbstractVector</span>, data, k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    loglik_k <span class="op">=</span> <span class="fu">compute_subject_loglik</span>(params, data, k)</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deviance = -2 * log-likelihood</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">2.0</span> <span class="op">*</span> loglik_k</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Tracing through NCV for one subject</strong>:</p>
<ol type="1">
<li>At MLE <span class="math inline">\(\hat{\theta}\)</span>, compute LOO perturbation: <span class="math inline">\(\delta_k = \hat{\theta}^{(-k)} - \hat{\theta}\)</span></li>
<li>LOO params: <span class="math inline">\(\hat{\theta}^{(-k)} = \hat{\theta} + \delta_k\)</span></li>
<li>Evaluate: <span class="math inline">\(D_k = \text{loss\_fn}(\hat{\theta}^{(-k)}, \text{data}, k) = -\ell_k(\hat{\theta}^{(-k)})\)</span></li>
<li>NCV criterion: <span class="math inline">\(V = \frac{1}{n}\sum_k D_k\)</span> (average loss over left-out subjects)</li>
<li>Optimal <span class="math inline">\(\lambda\)</span>: <span class="math inline">\(\arg\min_\lambda V(\lambda)\)</span></li>
</ol>
<p><strong>Key insight</strong>: The penalty <span class="math inline">\(\lambda\)</span> enters through the <em>penalized Fisher info</em> used to compute LOO perturbations <span class="math inline">\(\delta_k\)</span>, not through the loss function itself.</p></li>
<li><p><label><input type="checkbox"><strong>Initialization heuristic</strong> (R4-6): <span class="math inline">\(\log\lambda_0 = -3 - \log\|S\|_F\)</span></label></p>
<p><strong>Derivation</strong>: We want a conservative (over-smoothed) starting point that NCV can relax if the data support more flexibility.</p>
<p><strong>Balanced point</strong> (equal penalty/likelihood contributions): At edf ≈ p/2, rough scaling gives <span class="math inline">\(\lambda \approx 20/\|S\|_F\)</span>, or <span class="math inline">\(\log\lambda \approx 3 - \log\|S\|_F\)</span>.</p>
<p><strong>Conservative choice</strong>: We start 2 orders of magnitude smoother: <span class="math display">\[\log\lambda_0 = -3 - \log\|S\|_F\]</span></p>
<p>This is <span class="math inline">\(e^6 \appro 400\times\)</span> smaller than the balanced point, ensuring we begin on the over-smoothed side. NCV optimization will increase λ if more structure is needed.</p>
<p><strong>Validation example</strong> (n=500, k=10, cubic B-splines):</p>
<ul>
<li>For 2nd-derivative penalty: <span class="math inline">\(\|S\|_F \approx 10\)</span></li>
<li><span class="math inline">\(\log\lambda_0 = -3 - \log(10) = -3 - 2.3 = -5.3\)</span></li>
<li><span class="math inline">\(\lambda_0 \approx 0.005\)</span></li>
<li>Penalty contribution: <span class="math inline">\(\lambda_0 \cdot \|\beta\|^2 \cdot \|S\|_F \approx 0.005 \cdot 1 \cdot 10 = 0.05\)</span></li>
<li>This is small relative to likelihood (~500) — starting smooth, letting NCV relax</li>
</ul>
<p><strong>Fallback</strong>: If NCV optimization fails to converge:</p>
<ol type="1">
<li>Retry with <span class="math inline">\(\log\lambda_0 \pm 3\)</span> (order of magnitude shifts)</li>
<li>If persistent failure, use GCV initialization: <span class="math inline">\(\lambda_{\text{GCV}} = n/\text{tr}(S)\)</span></li>
</ol></li>
<li><p><label><input type="checkbox"><strong>Multi-λ optimization</strong> for tensor products (BFGS on log scale)</label></p></li>
<li><p><label><input type="checkbox">Bounds: <span class="math inline">\(\log\lambda \in [-20, 20]\)</span></label></p></li>
<li><p><label><input type="checkbox"><strong>REML: EXPLICITLY DEFERRED</strong> — Not in initial scope. May add later as benchmark.</label></p></li>
<li><p><label><input type="checkbox"><strong>Effective degrees of freedom</strong> (Issue #4, R4-2):</label></p>
<p><strong>Sign convention</strong> (consistent with MultistateModels.jl codebase):</p>
<ul>
<li><span class="math inline">\(H\)</span> = Hessian of log-likelihood <span class="math inline">\(\ell(\theta)\)</span> — <strong>negative semi-definite</strong> at MLE</li>
<li><span class="math inline">\(H_p = H - \lambda S\)</span> = Hessian of penalized log-likelihood — more negative</li>
<li>Fisher information: <span class="math inline">\(I = -H\)</span> — <strong>positive semi-definite</strong></li>
<li>Penalized Fisher: <span class="math inline">\(I_p = -H_p = -H + \lambda S\)</span></li>
</ul>
<p><strong>Simple formula</strong> (what we implement): <span class="math display">\[\text{edf} = \text{tr}(I \cdot I_p^{-1}) = \text{tr}((-H)(-H_p)^{-1}) = \text{tr}((-H)(-H + \lambda S)^{-1})\]</span></p>
<p>This counts how many “effective parameters” are used after penalization.</p>
<p><strong>Verification at λ=0</strong>: <span class="math display">\[\text{edf}\big|_{\lambda=0} = \text{tr}((-H)(-H)^{-1}) = \text{tr}(I_p \cdot I_p^{-1}) = \text{tr}(\mathbf{I}_p) = p \checkmark\]</span></p>
<p>where <span class="math inline">\(\mathbf{I}_p\)</span> is the <span class="math inline">\(p \times p\)</span> identity matrix (not to be confused with Fisher info <span class="math inline">\(I\)</span>).</p>
<p><strong>Implementation note</strong>: In code, we work with Fisher info <span class="math inline">\(I = -H\)</span> (positive definite):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> <span class="op">-</span>H                        <span class="co"># Fisher information (p.d.)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>I_p <span class="op">=</span> I <span class="op">+</span> λ <span class="op">*</span> S               <span class="co"># Penalized Fisher (p.d. for λ ≥ 0)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>edf <span class="op">=</span> <span class="fu">tr</span>(I <span class="op">*</span> <span class="fu">inv</span>(I_p))        <span class="co"># Or: tr(I / I_p) using matrix division</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ul>
<li><strong>Sandwich formula</strong> (Eletti 2024, deferred): <span class="math display">\[\text{edf} = \text{tr}(I \cdot I_p^{-1} \cdot I \cdot I_p^{-1})\]</span> Accounts for bias in penalized estimation; more appropriate for inference.</li>
</ul>
<p>Note: Both formulas reduce to <span class="math inline">\(p\)</span> (number of parameters) when <span class="math inline">\(\lambda = 0\)</span>.</p></li>
<li><p><label><input type="checkbox">Subject weights support in NCV</label></p></li>
<li><p><label><input type="checkbox"><strong>Handle indefinite Hessian fallback</strong> (Issue #13): When Cholesky downdate fails during LOO-CV, the leave-one-out Hessian is indefinite.</label></p>
<p><strong>Strategy 1 (Simple)</strong>: Add small ridge regularization</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">regularize_indefinite_hessian</span>(H_λ, H_i, ε<span class="op">=</span><span class="fl">1e-6</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># H_λ,-i = H_λ - H_i  (leave-one-out Hessian)</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    H_loo <span class="op">=</span> H_λ <span class="op">-</span> H_i</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check positive definiteness via Cholesky</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">cholesky</span>(H_loo)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> PosDefException</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add ridge term to ensure PD</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@warn</span> <span class="st">"LOO Hessian indefinite, adding regularization ε=</span><span class="sc">$</span><span class="st">ε"</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="st">        </span>return<span class="st"> cholesky(H_loo + ε * I)</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Strategy 2 (Woodbury, deferred)</strong>: For computational efficiency with many subjects The Woodbury identity allows updating the inverse without full re-factorization: <span class="math display">\[H^{-1}_{-i} = H^{-1} + H^{-1} h_i (1 - h_i^T H^{-1} h_i)^{-1} h_i^T H^{-1}\]</span> where <span class="math inline">\(h_i\)</span> is subject <span class="math inline">\(i\)</span>’s contribution to the Hessian. This is a rank-<span class="math inline">\(d_i\)</span> update where <span class="math inline">\(d_i\)</span> is the number of observations for subject <span class="math inline">\(i\)</span>.</p>
<p><strong>For Phase 3</strong>: Use Strategy 1 (simple regularization). Strategy 2 can be added later for performance optimization when <span class="math inline">\(n\)</span> is large.</p></li>
</ul>
</section>
<section id="phase-4-confidence-intervals-2-3-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-4-confidence-intervals-2-3-days">Phase 4: Confidence Intervals (2-3 days)</h3>
<p><strong>File:</strong> Extend <code>src/output/variance.jl</code></p>
<ul class="task-list">
<li><p><label><input type="checkbox">Bayesian posterior: <span class="math inline">\(\hat{\theta} \sim N(\theta, I_p^{-1})\)</span> where <span class="math inline">\(I_p = I + \lambda S\)</span> is penalized Fisher info</label></p></li>
<li><p><label><input type="checkbox">Simulation-based CIs for nonlinear functions:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb39"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Complete signatures with required parameters:</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hazard_ci</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, hazard<span class="op">::</span><span class="dt">Symbol</span>, times<span class="op">::</span><span class="dt">AbstractVector</span>;</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>                   level<span class="op">=</span><span class="fl">0.95</span>, n_samples<span class="op">=</span><span class="fl">1000</span>, covariates<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If covariates=nothing, use baseline (covariates at reference values)</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns DataFrame with columns: time, estimate, lower, upper, se</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">survival_ci</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, state<span class="op">::</span><span class="dt">Int</span>, times<span class="op">::</span><span class="dt">AbstractVector</span>;</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>                     level<span class="op">=</span><span class="fl">0.95</span>, n_samples<span class="op">=</span><span class="fl">1000</span>, covariates<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Survival in state (P(still in state at time t))</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cumulative_incidence_ci</span>(fitted<span class="op">::</span><span class="dt">MultistateModelFitted</span>, </span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>                                 from<span class="op">::</span><span class="dt">Int</span>, to<span class="op">::</span><span class="dt">Int</span>, times<span class="op">::</span><span class="dt">AbstractVector</span>;</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>                                 level<span class="op">=</span><span class="fl">0.95</span>, n_samples<span class="op">=</span><span class="fl">1000</span>, covariates<span class="op">=</span><span class="cn">nothing</span>)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cumulative incidence of transition from-&gt;to</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Integration with existing <code>predict</code> interface</label></p></li>
<li><p><label><input type="checkbox"><strong>Note</strong>: CIs depend on Phase 3 (need <span class="math inline">\(I_p^{-1}\)</span> from penalized fit)</label></p></li>
</ul>
</section>
<section id="phase-5-covariate-splines-6-7-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-5-covariate-splines-6-7-days">Phase 5: Covariate Splines (6-7 days)</h3>
<p><strong>Files:</strong> New <code>src/construction/smooth_terms.jl</code>, modify <code>src/hazard/covariates.jl</code></p>
<blockquote class="blockquote">
<p><strong>Note (Issue #10)</strong>: The <code>SmoothTerm</code> struct is defined once in Section 2.2 above. We reference it here rather than duplicating the definition.</p>
</blockquote>
<ul class="task-list">
<li><p><label><input type="checkbox">Implement <code>SmoothTerm &lt;: StatsModels.AbstractTerm</code> (see Section 2.2 for struct definition)</label></p></li>
<li><p><label><input type="checkbox"><strong>Smooth term storage in fitted model</strong> (Issue #9):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add to MultistateModelFitted:</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">#   smooth_terms::Union{Nothing, Dict{Symbol, SmoothTermInfo}}</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SmoothTermInfo</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    term<span class="op">::</span><span class="dt">SmoothTerm                   </span><span class="co"># Original specification</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    hazard<span class="op">::</span><span class="dt">Symbol                     </span><span class="co"># Which hazard this belongs to</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    breakpoints<span class="op">::</span><span class="dt">Vector{Float64}       </span><span class="co"># Breakpoints for basis reconstruction (R10-4)</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    order<span class="op">::</span><span class="dt">Int                         </span><span class="co"># BSpline order (4 for cubic)</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    centering_vec<span class="op">::</span><span class="dt">Vector{Float64}     </span><span class="co"># Column means for basis centering</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    x_range<span class="op">::</span><span class="dt">Tuple{Float64, Float64}   </span><span class="co"># (min, max) of training data</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    coef_indices<span class="op">::</span><span class="dt">UnitRange{Int}       </span><span class="co"># Indices in parameter vector</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Access pattern:</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="co"># fitted.smooth_terms[:age].coef_indices gives parameter indices for s(age)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Formula parsing</strong> via StatsModels term interception (Issue #5, #7):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># StatsModels integration is handled by the shadowed @formula macro (Phase 0)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co"># which preprocesses smooth term kwargs to positional arguments.</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># After preprocessing by @formula:</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co"># - s(age; k=5, penalty_order=3) becomes s(age, 5, 3)</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"># - FunctionTerm has ft.args[1].sym = :age, ft.args[2].n = 5, ft.args[3].n = 3</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">#</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co"># See Section "Implementation Phases for StatsModels Integration" for:</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co"># - transform_smooth_terms() and transform_smooth_call() preprocessors</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co"># - apply_schema(::FunctionTerm{typeof(s)}, schema::StatsModels.Schema, ...) dispatch</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co"># - modelcols(::SmoothTerm, ...) for basis matrix generation</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Implement StatsModels interface methods:</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: Second argument must be schema::StatsModels.Schema for dispatch to work</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(t<span class="op">::</span><span class="dt">SmoothTerm</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Validate that t.var exists in schema</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return t (or transformed version)</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">modelcols</span>(t<span class="op">::</span><span class="dt">SmoothTerm</span>, d<span class="op">::</span><span class="dt">NamedTuple</span>)</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build basis matrix from data</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return centered basis matrix columns</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Smooth terms handled separately from linear covariates:</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a><span class="co"># - extract_smooth_terms() returns Vector{SmoothTerm}</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a><span class="co"># - extract_covar_names() returns linear covariates only (UNCHANGED - Issue #7)</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a><span class="co"># - Model matrix has [linear_covars | smooth_basis_1 | smooth_basis_2 | ...]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Input validation for smooth terms</strong>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb42"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">validate_smooth_input</span>(x<span class="op">::</span><span class="dt">AbstractVector</span>, k<span class="op">::</span><span class="dt">Int</span>, var<span class="op">::</span><span class="dt">Symbol</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for missing values</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">any</span>(ismissing, x) <span class="op">&amp;&amp;</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Missing values in smooth term s(</span><span class="sc">$</span>var<span class="st">) not supported. "</span> <span class="op">*</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Remove rows with missing values before fitting."</span>))</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check sufficient unique values for basis</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">=</span> <span class="fu">length</span>(<span class="fu">unique</span>(x))</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n_unique <span class="op">&lt;</span> k</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>            <span class="st">"s(</span><span class="sc">$</span>var<span class="st">) requests k=</span><span class="sc">$</span>k<span class="st"> basis functions but only </span><span class="sc">$</span>n_unique<span class="st"> "</span> <span class="op">*</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>            <span class="st">"unique values found. Reduce k or use linear term."</span>))</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for constant covariate</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    n_unique <span class="op">==</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">"s(</span><span class="sc">$</span>var<span class="st">) has constant value; cannot fit smooth term."</span>))</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Design matrix rank validation</strong> (R10-3):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">validate_design_matrix</span>(B<span class="op">::</span><span class="dt">Matrix{Float64}</span>, var<span class="op">::</span><span class="dt">Symbol</span>, k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for rank-deficient design matrix (e.g., clustered data)</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fu">rank</span>(B)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> r <span class="op">&lt;</span> k</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@warn</span> <span class="st">"Design matrix for s(</span><span class="sc">$</span>var<span class="st">) is rank-deficient (rank=</span><span class="sc">$</span>r<span class="st">, k=</span><span class="sc">$</span>k<span class="st">). "</span> <span class="op">*</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>              <span class="st">"Data may be clustered. Consider reducing k or transforming data."</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check condition number for numerical stability</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> <span class="fu">cond</span>(B)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> c <span class="op">&gt;</span> <span class="fl">1e10</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@warn</span> <span class="st">"Design matrix for s(</span><span class="sc">$</span>var<span class="st">) is ill-conditioned (cond=</span><span class="sc">$</span>c<span class="st">). "</span> <span class="op">*</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>              <span class="st">"Results may be numerically unstable."</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Basis construction from data</strong>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_smooth_basis</span>(x<span class="op">::</span><span class="dt">AbstractVector</span>, k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Place interior knots at quantiles</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    interior <span class="op">=</span> <span class="fu">place_interior_knots</span>(x, k <span class="op">-</span> <span class="fl">4</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Construct full breakpoints (including boundaries)</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BSplineBasis expects breakpoints and handles endpoint repetition</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    breakpoints <span class="op">=</span> <span class="fu">unique</span>(<span class="fu">sort</span>([<span class="fu">minimum</span>(x); interior; <span class="fu">maximum</span>(x)]))</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    basis <span class="op">=</span> <span class="fu">BSplineBasis</span>(<span class="fu">BSplineOrder</span>(<span class="fl">4</span>), breakpoints)</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> basis</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">evaluate_basis</span>(basis<span class="op">::</span><span class="dt">BSplineBasis</span>, x<span class="op">::</span><span class="dt">AbstractVector</span>)</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="fu">length</span>(basis)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [<span class="fu">evaluate</span>(basis, i, xi) for xi <span class="kw">in</span> x, i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>N]</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Identifiability constraints</strong> (sum-to-zero centering):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Center basis matrix: B̃ = B - mean(B, dims=1)</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This ensures Σᵢ s(xᵢ) = 0</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Extrapolation handling</strong> (Issue #11 — corrected, R10-1):</label></p>
<blockquote class="blockquote">
<p><strong>CRITICAL (R10-1)</strong>: <code>BSplineKit.evaluate(basis, i, x)</code> returns <strong>exactly 0.0</strong> for all basis functions when <code>x</code> is outside the knot range. This is NOT polynomial extrapolation — it is hard truncation to zero. The smooth function will be identically zero outside the training range unless we implement explicit handling.</p>
</blockquote>
<ul>
<li><code>:none</code> (default): Throw error if prediction requested outside training data range. Safe option that prevents silent extrapolation failures. <strong>Changed from <code>:natural</code></strong>.</li>
<li><code>:natural</code>: Natural spline boundary conditions (second derivative = 0 at boundaries). Requires explicit linear extrapolation implementation beyond knot range.</li>
<li><code>:linear</code>: Explicit linear extrapolation at boundaries (equivalent to <code>:natural</code> for cubic splines with second-order penalties).</li>
<li><code>:constant</code>: Hold boundary value constant beyond knot range (first derivative = 0, Neumann BC). Matches hazard <code>extrapolation="constant"</code>.</li>
</ul>
<p><strong>Implementation</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">evaluate_with_extrapolation</span>(basis, x, extrapolation, x_range, centering_vec, coefs)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    x_min, x_max <span class="op">=</span> x_range</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> x_min <span class="op">||</span> x <span class="op">&gt;</span> x_max</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> extrapolation <span class="op">==</span> <span class="op">:</span>none</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">throw</span>(<span class="fu">ArgumentError</span>(</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Value x=</span><span class="sc">$</span>x<span class="st"> outside training range [</span><span class="sc">$</span>x_min<span class="st">, </span><span class="sc">$</span>x_max<span class="st">]. "</span> <span class="op">*</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>                <span class="st">"Set extrapolation=:linear or :constant to allow extrapolation."</span>))</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> extrapolation <span class="op">==</span> <span class="op">:</span>linear</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Linear extrapolation using value and derivative at boundary</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> x <span class="op">&lt;</span> x_min</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>                f_boundary <span class="op">=</span> <span class="fu">evaluate_smooth_at</span>(basis, x_min, centering_vec, coefs)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>                df_boundary <span class="op">=</span> <span class="fu">evaluate_smooth_deriv_at</span>(basis, x_min, centering_vec, coefs)</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> f_boundary <span class="op">+</span> df_boundary <span class="op">*</span> (x <span class="op">-</span> x_min)</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>                f_boundary <span class="op">=</span> <span class="fu">evaluate_smooth_at</span>(basis, x_max, centering_vec, coefs)</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>                df_boundary <span class="op">=</span> <span class="fu">evaluate_smooth_deriv_at</span>(basis, x_max, centering_vec, coefs)</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> f_boundary <span class="op">+</span> df_boundary <span class="op">*</span> (x <span class="op">-</span> x_max)</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> extrapolation <span class="op">==</span> <span class="op">:</span>constant</span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x <span class="op">&lt;</span> x_min ? </span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>                <span class="fu">evaluate_smooth_at</span>(basis, x_min, centering_vec, coefs) <span class="op">:</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>                <span class="fu">evaluate_smooth_at</span>(basis, x_max, centering_vec, coefs)</span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inside range: normal evaluation</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">evaluate_smooth_at</span>(basis, x, centering_vec, coefs)</span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Integration with existing covariate infrastructure</label></p></li>
<li><p><label><input type="checkbox">Tests: recover known nonlinear functions (quadratic, sine, step)</label></p></li>
</ul>
</section>
<section id="phase-6-tensor-product-infrastructure-6-7-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-6-tensor-product-infrastructure-6-7-days">Phase 6: Tensor Product Infrastructure (6-7 days)</h3>
<p><strong>File:</strong> Extend <code>src/inference/penalty.jl</code>, new <code>src/construction/tensor_terms.jl</code></p>
<ul class="task-list">
<li><p><label><input type="checkbox"><code>TensorTerm &lt;: StatsModels.AbstractTerm</code> struct:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb47"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TensorTerm <span class="op">&lt;:</span><span class="dt"> StatsModels.AbstractTerm</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    vars<span class="op">::</span><span class="dt">Tuple{Symbol, Symbol}</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    k<span class="op">::</span><span class="dt">Tuple{Int, Int}</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    penalty_order<span class="op">::</span><span class="dt">Int            </span><span class="co"># Derivative order for penalty (default 2)</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    monotone<span class="op">::</span><span class="dt">Tuple{Bool, Bool}</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    increasing<span class="op">::</span><span class="dt">Tuple{Bool, Bool}</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    interaction_only<span class="op">::</span><span class="dt">Bool  </span><span class="co"># true for ti(), false for te()</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><code>SharedOriginTensorConfig</code> struct (internal, model-level):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SharedOriginTensorConfig</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    origin_state<span class="op">::</span><span class="dt">Int</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    destinations<span class="op">::</span><span class="dt">Vector{Int}</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    time_basis<span class="op">::</span><span class="dt">BSplineBasis</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    time_penalty<span class="op">::</span><span class="dt">Matrix{Float64}  </span><span class="co"># S_t</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    dest_penalty<span class="op">::</span><span class="dt">Matrix{Float64}  </span><span class="co"># S_d (ridge default)</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    λ_time<span class="op">::</span><span class="dt">Float64</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    λ_dest<span class="op">::</span><span class="dt">Float64</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    monotone_time<span class="op">::</span><span class="dt">Bool</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    increasing<span class="op">::</span><span class="dt">Bool</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Destination penalty matrices</strong>:</label></p>
<ul>
<li><code>:ridge</code> (default): <span class="math inline">\(S_d = I_D\)</span></li>
<li><code>:difference</code>: <span class="math inline">\(S_d = D_1^T D_1\)</span> (adjacent destinations similar)</li>
<li>Custom matrix allowed</li>
</ul></li>
<li><p><label><input type="checkbox"><strong>Kronecker-efficient penalty application</strong> (no full matrix formation):</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb49"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span>: dot</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">apply_tensor_penalty</span>(β_vec, S_time, S_dest, λ_time, λ_dest, k_time, k_dest)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># β_mat is k_time × k_dest (rows = time basis, columns = destinations)</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Column-major vectorization: vec(β_mat) stacks columns</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    β_mat <span class="op">=</span> <span class="fu">reshape</span>(β_vec, k_time, k_dest)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CORRECT: Quadratic forms β'Sβ (Issue #6)</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Time penalty (I_D ⊗ S_t): S_time acts on each column (destination's time coefficients)</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    pen_time <span class="op">=</span> λ_time <span class="op">*</span> <span class="fu">sum</span>(<span class="fu">dot</span>(β_mat[<span class="op">:</span>, d], S_time <span class="op">*</span> β_mat[<span class="op">:</span>, d]) <span class="cf">for</span> d <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>k_dest)</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Destination penalty (S_d ⊗ I_t): S_dest acts on each row (time point's dest coefficients)</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    pen_dest <span class="op">=</span> λ_dest <span class="op">*</span> <span class="fu">sum</span>(<span class="fu">dot</span>(β_mat[t, <span class="op">:</span>], S_dest <span class="op">*</span> β_mat[t, <span class="op">:</span>]) <span class="cf">for</span> t <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>k_time)</span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pen_time <span class="op">+</span> pen_dest</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: sum((S * β).^2) computes ‖Sβ‖² = β'S'Sβ ≠ β'Sβ</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="co"># The penalty matrix S is the quadratic form matrix itself, not a "square root"</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox"><strong>Partial domain handling</strong>: identify and constrain unsupported coefficients</label></p></li>
<li><p><label><input type="checkbox"><strong>Formula-level tensor products</strong>: <code>te()</code> and <code>ti()</code> parsing</label></p></li>
<li><p><label><input type="checkbox"><strong><code>ti()</code> identifiability constraints</strong> (Issue #7, R4-3): &gt; The <code>ti()</code> term produces pure interactions orthogonal to main effects. This requires &gt; sum-to-zero constraints <strong>on each margin</strong> of the tensor product. &gt; &gt; <strong>Reparametrization approach</strong>: Reduce from <span class="math inline">\(k_1 \times k_2\)</span> to <span class="math inline">\((k_1-1)(k_2-1)\)</span> parameters.</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="st">    build_ti_contrast_matrix(k1::Int, k2::Int) -&gt; Matrix{Float64}</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="st">Build a contrast matrix C that transforms a </span><span class="sc">$</span>(k_1<span class="op">-</span><span class="fl">1</span>)<span class="st">(k_2-1)</span><span class="sc">$</span><span class="st">-</span>dimensional<span class="st"> </span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="st">parameter vector into a </span><span class="sc">$</span>k_1<span class="st"> k_2</span><span class="sc">$</span><span class="st">-</span>dimensional<span class="st"> tensor satisfying sum-to-zero </span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="st">constraints on both margins.</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="st">Returns C of size (k1*k2) × ((k1-1)*(k2-1))</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_ti_contrast_matrix</span>(k1<span class="op">::</span><span class="dt">Int</span>, k2<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Helmert-style contrasts for each marginal</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># C1: (k1) × (k1-1) matrix with columns summing to zero</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># C2: (k2) × (k2-1) matrix with columns summing to zero</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k1)  <span class="co"># k1 × (k1-1)</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k2)  <span class="co"># k2 × (k2-1)</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kronecker product gives ti() contrast: </span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># C = C1 ⊗ C2, size (k1*k2) × ((k1-1)*(k2-1))</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">kron</span>(C1, C2)</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_sum_to_zero_contrast</span>(k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns k × (k-1) orthonormal matrix where each column sums to zero</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Based on Helmert contrasts, then orthonormalized via QR for numerical stability</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (QR preserves column space, so sum-to-zero property is maintained)</span></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, k, k<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>(k<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>        C[j, j] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>        C[j<span class="op">+</span><span class="fl">1</span><span class="op">:</span>k, j] <span class="op">.=</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">/</span> (k <span class="op">-</span> j)</span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Orthonormalize: QR preserves the property that columns span sum-to-zero subspace</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">Matrix</span>(<span class="fu">qr</span>(C).Q)[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span>(k<span class="op">-</span><span class="fl">1</span>)]</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_ti_basis</span>(B1<span class="op">::</span><span class="dt">Matrix{Float64}</span>, B2<span class="op">::</span><span class="dt">Matrix{Float64}</span>)</span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># B1: n × k1 basis for dimension 1</span></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># B2: n × k2 basis for dimension 2  </span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns: n × ((k1-1)*(k2-1)) constrained interaction basis</span></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">size</span>(B1, <span class="fl">1</span>)</span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> <span class="fu">size</span>(B1, <span class="fl">2</span>), <span class="fu">size</span>(B2, <span class="fl">2</span>)</span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get contrast matrices</span></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k1)  <span class="co"># k1 × (k1-1)</span></span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k2)  <span class="co"># k2 × (k2-1)</span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Centered marginal bases</span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>    B1_c <span class="op">=</span> B1 <span class="op">*</span> C1  <span class="co"># n × (k1-1)</span></span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>    B2_c <span class="op">=</span> B2 <span class="op">*</span> C2  <span class="co"># n × (k2-1)</span></span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Row-wise Kronecker product for interaction</span></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Result: n × ((k1-1)*(k2-1))</span></span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a>    p_new <span class="op">=</span> (k1<span class="op">-</span><span class="fl">1</span>) <span class="op">*</span> (k2<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a>    B_ti <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, n, p_new)</span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n</span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a>        B_ti[i, <span class="op">:</span>] <span class="op">=</span> <span class="fu">kron</span>(B1_c[i, <span class="op">:</span>], B2_c[i, <span class="op">:</span>])</span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_ti</span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Penalty matrix for ti(): transform base penalties through contrast</span></span>
<span id="cb50-63"><a href="#cb50-63" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_ti_penalty</span>(S1<span class="op">::</span><span class="dt">Matrix{Float64}</span>, S2<span class="op">::</span><span class="dt">Matrix{Float64}</span>, </span>
<span id="cb50-64"><a href="#cb50-64" aria-hidden="true" tabindex="-1"></a>                          k1<span class="op">::</span><span class="dt">Int</span>, k2<span class="op">::</span><span class="dt">Int</span>, λ<span class="fl">1</span><span class="op">::</span><span class="dt">Real</span>, λ<span class="fl">2</span><span class="op">::</span><span class="dt">Real</span>)</span>
<span id="cb50-65"><a href="#cb50-65" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k1)</span>
<span id="cb50-66"><a href="#cb50-66" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k2)</span>
<span id="cb50-67"><a href="#cb50-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-68"><a href="#cb50-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Transform penalties: C' S C</span></span>
<span id="cb50-69"><a href="#cb50-69" aria-hidden="true" tabindex="-1"></a>    S1_ti <span class="op">=</span> C1<span class="op">'</span> <span class="op">*</span> S1 <span class="op">*</span> C1  <span class="co"># (k1-1) × (k1-1)</span></span>
<span id="cb50-70"><a href="#cb50-70" aria-hidden="true" tabindex="-1"></a>    S2_ti <span class="op">=</span> C2<span class="op">'</span> <span class="op">*</span> S2 <span class="op">*</span> C2  <span class="co"># (k2-1) × (k2-1)</span></span>
<span id="cb50-71"><a href="#cb50-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-72"><a href="#cb50-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kronecker structure on reduced space</span></span>
<span id="cb50-73"><a href="#cb50-73" aria-hidden="true" tabindex="-1"></a>    p_new <span class="op">=</span> (k1<span class="op">-</span><span class="fl">1</span>) <span class="op">*</span> (k2<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-74"><a href="#cb50-74" aria-hidden="true" tabindex="-1"></a>    I1 <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{Float64}</span>(I, k1<span class="op">-</span><span class="fl">1</span>, k1<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-75"><a href="#cb50-75" aria-hidden="true" tabindex="-1"></a>    I2 <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{Float64}</span>(I, k2<span class="op">-</span><span class="fl">1</span>, k2<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb50-76"><a href="#cb50-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-77"><a href="#cb50-77" aria-hidden="true" tabindex="-1"></a>    S_ti <span class="op">=</span> λ<span class="fl">1</span> <span class="op">*</span> <span class="fu">kron</span>(I2, S1_ti) <span class="op">+</span> λ<span class="fl">2</span> <span class="op">*</span> <span class="fu">kron</span>(S2_ti, I1)</span>
<span id="cb50-78"><a href="#cb50-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S_ti</span>
<span id="cb50-79"><a href="#cb50-79" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Verification (k1=3, k2=4)</strong>:</p>
<ul>
<li>Full tensor: <span class="math inline">\(3 \times 4 = 12\)</span> parameters</li>
<li>After ti() constraints: <span class="math inline">\((3-1)(4-1) = 2 \times 3 = 6\)</span> parameters ✓</li>
</ul>
<h1 id="references">References:</h1>
<h1 id="wood-2006-gams-section-4.1.8-tensor-product-interaction-smooths">- Wood (2006) GAMs, Section 4.1.8: “Tensor product interaction smooths”</h1>
<h1 id="mgcvti-documentation-the-sum-to-zero-constraints-are-applied">- mgcv::ti() documentation: “The sum-to-zero constraints are applied</h1>
<h1 id="to-each-margin-to-remove-main-effects">to each margin to remove main effects”</h1></li>
<li><p><label><input type="checkbox"><strong>Monotone tensor products</strong> via cumulative I-spline transformation per dimension</label></p></li>
<li><p><label><input type="checkbox"><strong>Model construction integration</strong>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># When shared_origin_tensor = [1]:</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Identify hazards from state 1</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Combine into tensor structure</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Reindex parameters accordingly</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">Edge case: single destination degenerates to 1D spline</label></p></li>
</ul>
</section>
<section id="phase-7-testing-documentation-4-5-days" class="level3">
<h3 class="anchored" data-anchor-id="phase-7-testing-documentation-4-5-days">Phase 7: Testing &amp; Documentation (4-5 days)</h3>
<p><strong>File:</strong> <code>MultistateModelsTests/</code></p>
<ul class="task-list">
<li><label><input type="checkbox"><strong>Unit tests</strong>:</label>
<ul class="task-list">
<li><p><label><input type="checkbox">Penalty matrix construction matches R’s <code>mgcv::smoothCon</code></label></p></li>
<li><p><label><input type="checkbox">RecombinedBSplineBasis penalty transformation</label></p></li>
<li><p><label><input type="checkbox">Kronecker penalty equivalence</label></p></li>
<li><p><label><input type="checkbox">(Issue #17) <strong>Indefinite Hessian handling</strong>: Verify regularization fallback works</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb52"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test case: High λ causes ill-conditioning</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify: Warning issued, results still valid or error thrown</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
<li><p><label><input type="checkbox">(Issue #18) <strong>Parameter bounds interaction</strong>: Verify penalties compose with box constraints</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test case: Bounded parameter + penalty</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify: Optimization respects both simultaneously</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
</ul></li>
<li><label><input type="checkbox"><strong>Integration tests</strong>:</label>
<ul class="task-list">
<li><p><label><input type="checkbox">Fit penalized model, verify smoothness</label></p></li>
<li><p><label><input type="checkbox">Covariate splines: recover quadratic, sine, piecewise functions</label></p></li>
<li><p><label><input type="checkbox">Shared-origin tensor: verify borrowing strength</label></p></li>
<li><p><label><input type="checkbox">Monotone tensor products: verify constraints hold</label></p></li>
<li><p><label><input type="checkbox">(Issue #16) <strong>NCV correctness verification</strong>:</label></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb54"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test: Compare NCV λ_opt vs. oracle (known truth)</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co"># For simple cases, NCV should select reasonable λ</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Criterion: NCV-selected λ within [0.1×, 10×] of oracle</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"># (Wide tolerance because NCV is approximate)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div></li>
</ul></li>
<li><label><input type="checkbox"><strong>Simulation studies</strong>:</label>
<ul class="task-list">
<li><label><input type="checkbox">Coverage (Issue #20): 95% CI achieves ≥90% coverage</label>
<ul>
<li><strong>Rationale</strong>: Penalized CIs are based on Bayesian posterior approximation (Wood 2006, §4.8) which provides “across-the-function” coverage. Empirical coverage of 90-95% is expected, ≥90% is the pass criterion.</li>
<li>Test with N=500 simulations, report actual coverage with SE</li>
</ul></li>
<li><label><input type="checkbox">Bias: penalized estimates less variable than unpenalized</label></li>
<li><label><input type="checkbox">(Issue #16 extension) NCV vs.&nbsp;REML comparison (when REML implemented)</label></li>
</ul></li>
<li><label><input type="checkbox"><strong>Comparison benchmarks</strong>:</label>
<ul class="task-list">
<li><label><input type="checkbox">R/flexsurv/flexmsm comparison</label></li>
<li><label><input type="checkbox">mgcv gam() for covariate splines</label></li>
</ul></li>
<li><label><input type="checkbox"><strong>Documentation</strong>:</label>
<ul class="task-list">
<li><label><input type="checkbox">Docstrings for all public functions</label></li>
<li><label><input type="checkbox">Tutorial: penalized illness-death model</label></li>
<li><label><input type="checkbox">Vignette: tensor products for competing risks</label></li>
</ul></li>
</ul>
<p><strong>Total: ~35-42 days</strong></p>
<hr>
</section>
</section>
<section id="phase-dependencies" class="level2">
<h2 class="anchored" data-anchor-id="phase-dependencies">Phase Dependencies</h2>
<pre><code>Phase 0 (Infrastructure)
    │
    ▼
Phase 1 (Penalty matrices)
    │
    ▼
Phase 2 (Penalized likelihood)
    │
    ├──────────────────────────────────────────────────┐
    ▼                                                  │
Phase 3 (NCV) ─────────────────────────────────────────┤
    │                                                  │
    ├───────────────────────────────┐                  │
    ▼                               ▼                  ▼
Phase 4 (CIs)               Phase 5 (Covariate splines)
    │                               │
    └───────────────────────────────┘
                    │
                    ▼
         Phase 6 (Tensor products)
         ├── 6a: Marginal time tensor (I ⊗ S_t)
         ├── 6b: Destination tensor (S_d ⊗ I)
         └── 6c: Full 2D tensor (S_1 ⊗ S_2)
                    │
                    ▼
         Phase 7 (Testing &amp; docs)</code></pre>
<p><strong>Dependency Notes:</strong> - Phase 3 (NCV) → Phase 4 (CIs): CIs require <span class="math inline">\(I_p^{-1}\)</span> (penalized Fisher inverse) from penalized fit - Phase 4 and Phase 5 are independent of each other - Phase 6 subdivided into 6a/6b/6c for incremental delivery (Issue #14) - 6a alone covers shared-origin competing risks - 6b adds destination smoothing - 6c is full tensor products (advanced, may be future work)</p>
<pre><code>
---

## API Design

### Basic Penalized Fitting

```julia
# Opt-in penalization
fitted = fit(model; penalized=true)
fitted = fit(model; smoothing=:auto)  # NCV selection
fitted = fit(model; smoothing=:reml)  # REML selection (if implemented)

# Manual smoothing parameters (log scale)
fitted = fit(model; smoothing=Dict(:h12 =&gt; -3.0, :h13 =&gt; -2.0))</code></pre>
<section id="shared-origin-tensor-products" class="level3">
<h3 class="anchored" data-anchor-id="shared-origin-tensor-products">Shared-Origin Tensor Products</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb57"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple: list of origin states</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(h12, h13, h14, h21;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data,</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> [<span class="fl">1</span>]  <span class="co"># State 1's baselines share structure</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Explicit configuration</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(<span class="op">...</span>;</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span> <span class="op">=&gt;</span> <span class="fu">SharedOriginConfig</span>(dest_penalty<span class="op">=:</span>ridge, monotone_time<span class="op">=</span><span class="cn">false</span>)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="covariate-splines" class="level3">
<h3 class="anchored" data-anchor-id="covariate-splines">Covariate Splines</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Smooth nonlinear covariate effect</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> trt), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"># With options</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age, k<span class="op">=</span><span class="fl">8</span>, penalty_order<span class="op">=</span><span class="fl">2</span>)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="tensor-products" class="level3">
<h3 class="anchored" data-anchor-id="tensor-products">Tensor Products</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Covariate × covariate interaction</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Time-varying covariate effect (requires :sp family)</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Main effects + pure interaction</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> <span class="fu">s</span>(bmi) <span class="op">+</span> <span class="fu">ti</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
<section id="files-to-createmodify" class="level2">
<h2 class="anchored" data-anchor-id="files-to-createmodify">Files to Create/Modify</h2>
<section id="new-files" class="level3">
<h3 class="anchored" data-anchor-id="new-files">New Files</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src/inference/penalty.jl</code></td>
<td>Penalty matrix construction (Wood’s algorithm)</td>
</tr>
<tr class="even">
<td><code>src/inference/penalized.jl</code></td>
<td>Penalized likelihood wrapper</td>
</tr>
<tr class="odd">
<td><code>src/inference/smoothing.jl</code></td>
<td>Smoothing parameter selection (NCV, REML)</td>
</tr>
<tr class="even">
<td><code>src/construction/smooth_terms.jl</code></td>
<td><code>s()</code> term parsing and basis construction</td>
</tr>
<tr class="odd">
<td><code>src/construction/tensor_terms.jl</code></td>
<td><code>te()</code>, <code>ti()</code> term parsing</td>
</tr>
</tbody>
</table>
</section>
<section id="files-to-modify" class="level3">
<h3 class="anchored" data-anchor-id="files-to-modify">Files to Modify</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 40%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>File</th>
<th>Changes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src/types/hazard_structs.jl</code></td>
<td>Add <code>PenaltyConfig</code>, <code>SharedOriginConfig</code> structs (definition only, not stored here)</td>
</tr>
<tr class="even">
<td><code>src/inference/fit.jl</code></td>
<td>Add <code>penalized</code>, <code>smoothing</code> kwargs; store penalty info in <code>ConvergenceRecords</code></td>
</tr>
<tr class="odd">
<td><code>src/output/variance.jl</code></td>
<td>CI functions (existing <code>pijcv_criterion()</code> suffices for NCV)</td>
</tr>
<tr class="even">
<td><code>src/utilities/constants.jl</code></td>
<td>Add penalty constants</td>
</tr>
<tr class="odd">
<td><code>src/utilities/validation.jl</code></td>
<td>Add <code>check_penalty_config</code> validation</td>
</tr>
<tr class="even">
<td><code>src/hazard/covariates.jl</code></td>
<td>Unchanged — smooth terms handled separately (R8-10)</td>
</tr>
<tr class="odd">
<td><code>src/construction/multistatemodel.jl</code></td>
<td><code>shared_origin_tensor</code> kwarg handling</td>
</tr>
<tr class="even">
<td><code>Project.toml</code></td>
<td>Add <code>BSplineKit = "0.17"</code> to [compat] section (R8-3)</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="resolved-design-questions" class="level2">
<h2 class="anchored" data-anchor-id="resolved-design-questions">Resolved Design Questions</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Question</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Penalty storage location</td>
<td style="text-align: left;"><code>PenaltyConfig</code> struct stored in <code>ConvergenceRecords</code> NamedTuple (R8-1, R8-4, R9-4)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Total hazard penalty</td>
<td style="text-align: left;">Replaced by shared-origin tensor products</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Smoothing param bounds</td>
<td style="text-align: left;">Log scale: <span class="math inline">\([-20, 20]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">PIJCVState usage</td>
<td style="text-align: left;">Use existing <code>pijcv_criterion()</code> for NCV; provide appropriate loss_fn (R8-13)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Error handling</td>
<td style="text-align: left;"><code>ArgumentError</code> for user input (package convention)</td>
</tr>
<tr class="even">
<td style="text-align: left;">RecombinedBSplineBasis</td>
<td style="text-align: left;">Transform penalty: <span class="math inline">\(S_{recombined} = R^T S_{original} R\)</span> where <span class="math inline">\(R\)</span> is rectangular</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Monotone + penalization (1D)</td>
<td style="text-align: left;">Disallow for single-dimension splines (conflicting objectives)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Monotone tensor products</td>
<td style="text-align: left;">Supported via cumulative I-spline transformation per dimension</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalization default</td>
<td style="text-align: left;">Opt-in via <code>fit(...; penalized=true)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">MCEM compatibility</td>
<td style="text-align: left;">Deferred; initial scope is Markov + exact data only</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Absorbing state handling</td>
<td style="text-align: left;">Treat same as other destinations in shared-origin tensors</td>
</tr>
<tr class="even">
<td style="text-align: left;">Indefinite Hessian handling</td>
<td style="text-align: left;">Woodbury identity with partial Cholesky update (Wood 2024, Eq. 4)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NCV/edf generality</td>
<td style="text-align: left;">Confirmed general for all quadratically penalized regression (not GAM-specific)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Covariate spline extrapolation</td>
<td style="text-align: left;"><code>:natural</code> default (zero outside range), <code>:linear</code> and <code>:constant</code> options</td>
</tr>
<tr class="odd">
<td style="text-align: left;">P-values for smooth terms</td>
<td style="text-align: left;">Deferred to future extension (skip for initial scope)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Covariate knot placement</td>
<td style="text-align: left;">Quantile-based, using existing <code>place_interior_knots()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>apply_schema</code> signature</td>
<td style="text-align: left;">Must use <code>schema::StatsModels.Schema</code> (R9-1)</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="known-limitations-initial-scope" class="level2">
<h2 class="anchored" data-anchor-id="known-limitations-initial-scope">Known Limitations (Initial Scope)</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 24%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Limitation</th>
<th style="text-align: left;">Reason</th>
<th style="text-align: left;">Future Work</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Markov + exact data only</strong></td>
<td style="text-align: left;">MCEM stochastic gradients complicate NCV</td>
<td style="text-align: left;">Semi-Markov support requires converged MCEM Hessian</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>No phase-type hazards</strong></td>
<td style="text-align: left;">Different parameterization</td>
<td style="text-align: left;">Phase-type penalty structure TBD</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>No 1D monotone + penalized</strong></td>
<td style="text-align: left;">Conflicting objectives</td>
<td style="text-align: left;">Tensor products provide alternative</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>No constrained penalties</strong></td>
<td style="text-align: left;">Ipopt integration complex</td>
<td style="text-align: left;">Constrained trust region optimizer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>No REML initially</strong></td>
<td style="text-align: left;">Substantial implementation</td>
<td style="text-align: left;">May add as benchmark later</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Tensor size limits</strong></td>
<td style="text-align: left;"><span class="math inline">\(k_1 \times k_2 \leq 400\)</span> practical</td>
<td style="text-align: left;">Larger tensors need sparse methods</td>
</tr>
</tbody>
</table>
<section id="important-usage-notes" class="level3">
<h3 class="anchored" data-anchor-id="important-usage-notes">Important Usage Notes</h3>
<blockquote class="blockquote">
<p><strong>Issue #15: Tensor Structure Changes Require Model Re-specification</strong></p>
<p>Changing tensor dimensions (e.g., <code>k=(10,5)</code> → <code>k=(8,8)</code>) or switching between <code>te()</code> and <code>ti()</code> requires <strong>re-specifying the model from scratch</strong>, not just re-fitting. This is because: 1. Basis functions are constructed at model creation time 2. Parameter indices are determined by basis dimensions 3. Penalty matrices have fixed structure tied to basis configuration</p>
<p>Users should explore tensor configurations with <code>fit(...; penalized=true)</code> on subsets of data before committing to a final specification for full analysis.</p>
</blockquote>
<hr>
</section>
</section>
<section id="deferred-future-extensions" class="level2">
<h2 class="anchored" data-anchor-id="deferred-future-extensions">Deferred / Future Extensions</h2>
<ul>
<li><strong>P-values for smooth terms</strong>: Wood (2013) approximate p-values for testing <span class="math inline">\(H_0: s(x) = 0\)</span></li>
<li><strong>Semi-Markov penalties</strong>: Sojourn time <span class="math inline">\(u\)</span> vs.&nbsp;clock time <span class="math inline">\(t\)</span>, MCEM integration</li>
<li><strong>Phase-type model integration</strong>: Penalty on latent phase structure</li>
<li><strong>Constrained penalized optimization</strong>: For 1D monotone splines</li>
<li><strong>Varying coefficient models</strong>: <code>s(x, by=group)</code> syntax</li>
<li><strong>Spatial smoothing</strong>: <code>te(lat, lon)</code> for geographic models</li>
<li><strong>Sparse penalty matrices</strong>: For large tensor products</li>
</ul>
<hr>
</section>
<section id="adversarial-edge-cases-round-10-verification" class="level2">
<h2 class="anchored" data-anchor-id="adversarial-edge-cases-round-10-verification">Adversarial Edge Cases (Round 10 Verification)</h2>
<p>The following edge cases were verified via terminal testing:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 36%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Edge Case</th>
<th style="text-align: left;">Test Result</th>
<th style="text-align: left;">Mitigation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ForwardDiff through BSplineKit</strong></td>
<td style="text-align: left;">✅ Works</td>
<td style="text-align: left;"><code>BSplineKit.evaluate</code> accepts Dual numbers</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Extrapolation outside knots</strong></td>
<td style="text-align: left;">⚠️ Returns 0.0</td>
<td style="text-align: left;">Default <code>:none</code> throws error; must implement explicit extrapolation</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Categorical variable in s()</strong></td>
<td style="text-align: left;">⚠️ No error</td>
<td style="text-align: left;">Added <code>CategoricalTerm</code> check in <code>apply_schema</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>k &gt; unique data points</strong></td>
<td style="text-align: left;">⚠️ Repeated knots</td>
<td style="text-align: left;"><code>place_interior_knots</code> handles; existing infrastructure covers</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Clustered data (boundary clustering)</strong></td>
<td style="text-align: left;">⚠️ Rank-deficient design</td>
<td style="text-align: left;">Added <code>validate_design_matrix()</code> with warnings</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Penalty matrix singularity</strong></td>
<td style="text-align: left;">✅ Expected</td>
<td style="text-align: left;">Rank = k - penalty_order; Fisher info regularizes</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Degenerate (repeated) knots</strong></td>
<td style="text-align: left;">⚠️ Rank-deficient penalty</td>
<td style="text-align: left;">Same as above; <code>galerkin_matrix</code> handles gracefully</td>
</tr>
</tbody>
</table>
<section id="simplification-opportunities-identified" class="level3">
<h3 class="anchored" data-anchor-id="simplification-opportunities-identified">Simplification Opportunities Identified</h3>
<ol type="1">
<li><strong><code>SmoothTermInfo</code> simplified</strong>: Removed redundant <code>basis</code> field. Store only <code>breakpoints</code> + <code>order</code>; reconstruct on demand (192 vs 176 bytes, negligible).</li>
<li><strong>Extrapolation default changed</strong>: From <code>:natural</code> to <code>:none</code> (fail-safe).</li>
<li><strong>No covariate scaling</strong>: Confirmed MixedModels.jl and survival don’t scale; removed complexity.</li>
</ol>
</section>
<section id="not-invented-here-avoided" class="level3">
<h3 class="anchored" data-anchor-id="not-invented-here-avoided">Not-Invented-Here Avoided</h3>
<ol type="1">
<li><strong>Penalty matrix</strong>: Use <code>BSplineKit.galerkin_matrix(basis, (Derivative(k), Derivative(k)))</code> directly.</li>
<li><strong>Knot placement</strong>: Reuse existing <code>place_interior_knots()</code> from <code>src/hazard/spline.jl</code>.</li>
<li><strong>NCV infrastructure</strong>: Reuse existing <code>PIJCVState</code> and <code>pijcv_criterion()</code> from <code>variance.jl</code>.</li>
</ol>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>