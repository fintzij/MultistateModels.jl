<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>penalized_splines_literature_review</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="penalized_splines_literature_review_files/libs/clipboard/clipboard.min.js"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/popper.min.js"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="penalized_splines_literature_review_files/libs/quarto-html/anchor.min.js"></script>
<link href="penalized_splines_literature_review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="penalized_splines_literature_review_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="penalized_splines_literature_review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="penalized_splines_literature_review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="penalized_splines_literature_review_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="penalized-splines-for-multistate-models-design-document" class="level1">
<h1>Penalized Splines for Multistate Models: Design Document</h1>
<section id="document-status" class="level2">
<h2 class="anchored" data-anchor-id="document-status">Document Status</h2>
<blockquote class="blockquote">
<p><strong>Version</strong>: Post-Adversarial Review (Round 9)</p>
<p><strong>Companion Document</strong>: See <a href="penalized_splines_plan.md">penalized_splines_plan.md</a> for implementation roadmap.</p>
<p><strong>Consistency Check</strong>: All major design decisions in this document are consistent with the implementation plan. Key clarifications made during adversarial review: - Total hazard penalty (Section 4.2) is marked as <strong>SUPERSEDED</strong> by tensor products - Varying coefficient models are marked as <strong>FUTURE WORK</strong> - REML is marked as <strong>EXPLICITLY DEFERRED</strong> (NCV is primary method) - Penalty info stored in <code>ConvergenceRecords</code>, not new struct field (R8-1)</p>
</blockquote>
<section id="round-5-issue-resolution" class="level3">
<h3 class="anchored" data-anchor-id="round-5-issue-resolution">Round 5 Issue Resolution</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 21%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;">Severity</th>
<th style="text-align: left;">Issue</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R5-2</td>
<td style="text-align: left;">Critical</td>
<td style="text-align: left;">StatsModels kwargs integration impossible</td>
<td style="text-align: left;">Fixed: Documented shadowed <span class="citation" data-cites="formula">@formula</span> macro approach</td>
</tr>
<tr class="even">
<td style="text-align: left;">R5-3</td>
<td style="text-align: left;">Critical</td>
<td style="text-align: left;">ti() reparametrization undocumented</td>
<td style="text-align: left;">Fixed: Added detailed section with constraint math and implementation</td>
</tr>
</tbody>
</table>
</section>
<section id="round-6-issue-resolution" class="level3">
<h3 class="anchored" data-anchor-id="round-6-issue-resolution">Round 6 Issue Resolution</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 21%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;">Severity</th>
<th style="text-align: left;">Issue</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R6-1</td>
<td style="text-align: left;">Major</td>
<td style="text-align: left;"><code>apply_schema</code> signature inconsistency</td>
<td style="text-align: left;">Fixed: Standardized to <code>Mod::Type</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">R6-2</td>
<td style="text-align: left;">Major</td>
<td style="text-align: left;"><code>ti()</code> implementation mismatch with plan</td>
<td style="text-align: left;">Fixed: Updated to match plan‚Äôs Helmert contrast approach</td>
</tr>
<tr class="odd">
<td style="text-align: left;">R6-6</td>
<td style="text-align: left;">Minor</td>
<td style="text-align: left;">formula.jl had module wrapper</td>
<td style="text-align: left;">Fixed: Removed, now flat file</td>
</tr>
<tr class="even">
<td style="text-align: left;">R6-7</td>
<td style="text-align: left;">Minor</td>
<td style="text-align: left;"><code>build_ti_basis</code> naming inconsistency</td>
<td style="text-align: left;">Fixed: Aligned with plan</td>
</tr>
</tbody>
</table>
</section>
<section id="round-7-issue-resolution" class="level3">
<h3 class="anchored" data-anchor-id="round-7-issue-resolution">Round 7 Issue Resolution</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 21%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;">Severity</th>
<th style="text-align: left;">Issue</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R7-2</td>
<td style="text-align: left;">Minor</td>
<td style="text-align: left;">Helmert orthonormalization comment unclear</td>
<td style="text-align: left;">Fixed: Clarified QR preserves sum-to-zero property</td>
</tr>
</tbody>
</table>
</section>
<section id="round-8-issue-resolution" class="level3">
<h3 class="anchored" data-anchor-id="round-8-issue-resolution">Round 8 Issue Resolution</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 21%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;">Severity</th>
<th style="text-align: left;">Issue</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R8-1</td>
<td style="text-align: left;">Critical</td>
<td style="text-align: left;"><code>MultistateModelFitted</code> has no <code>penalty_config</code> field</td>
<td style="text-align: left;">Fixed: Store in <code>ConvergenceRecords</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">R8-3</td>
<td style="text-align: left;">Major</td>
<td style="text-align: left;">BSplineKit missing from <code>[compat]</code></td>
<td style="text-align: left;">Fixed: Added version constraint</td>
</tr>
<tr class="odd">
<td style="text-align: left;">R8-13</td>
<td style="text-align: left;">Minor</td>
<td style="text-align: left;">References to non-existent <code>compute_ncv_criterion()</code></td>
<td style="text-align: left;">Fixed: Use existing <code>pijcv_criterion()</code></td>
</tr>
</tbody>
</table>
</section>
<section id="round-9-issue-resolution" class="level3">
<h3 class="anchored" data-anchor-id="round-9-issue-resolution">Round 9 Issue Resolution</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 30%">
<col style="width: 21%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ID</th>
<th style="text-align: left;">Severity</th>
<th style="text-align: left;">Issue</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R9-1</td>
<td style="text-align: left;">Critical</td>
<td style="text-align: left;"><code>apply_schema</code> signature wrong: needs <code>schema::StatsModels.Schema</code></td>
<td style="text-align: left;">Fixed: Corrected in plan</td>
</tr>
<tr class="even">
<td style="text-align: left;">R9-2</td>
<td style="text-align: left;">Major</td>
<td style="text-align: left;">BSplineKit still not in actual Project.toml [compat]</td>
<td style="text-align: left;">Fixed: Documented as Phase 0 action</td>
</tr>
<tr class="odd">
<td style="text-align: left;">R9-4</td>
<td style="text-align: left;">Minor</td>
<td style="text-align: left;"><code>ConvergenceRecords</code> is immutable NamedTuple</td>
<td style="text-align: left;">Fixed: Build complete at fit() end</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">Executive Summary</h2>
<p>This document guides the implementation of penalized splines in <code>MultistateModels.jl</code>. The scope has been expanded based on adversarial review to include:</p>
<ol type="1">
<li><strong>Baseline hazard smoothing</strong>: Penalized splines for <span class="math inline">\(\log h_{rs}(t)\)</span></li>
<li><strong>Covariate splines</strong>: Smooth nonlinear covariate effects via <code>s(covariate)</code> syntax</li>
<li><strong>Shared-origin tensor products</strong>: Borrow strength across competing risks from same origin state</li>
<li><strong>Covariate tensor products</strong>: Interactions between covariates and time-varying effects</li>
</ol>
<p>We address three fundamental questions:</p>
<ol type="1">
<li><strong>What to penalize?</strong> ‚Äî Which functions should have smoothness penalties?</li>
<li><strong>How to set tuning parameters?</strong> ‚Äî How do we select smoothing parameters <span class="math inline">\(\lambda\)</span>?</li>
<li><strong>How to borrow strength?</strong> ‚Äî How do we share information across related transitions?</li>
</ol>
<p>Our approach synthesizes methods from four key papers: - <strong>Machado et al.&nbsp;(2018)</strong> and <strong>Eletti et al.&nbsp;(2024)</strong> for penalized multistate models - <strong>Wood (2016)</strong> for penalty matrix construction and tensor products - <strong>Wood (2024)</strong> for smoothing parameter selection via Neighbourhood Cross-Validation (NCV)</p>
<section id="key-design-decisions-summary" class="level3">
<h3 class="anchored" data-anchor-id="key-design-decisions-summary">Key Design Decisions (Summary)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 27%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Decision</th>
<th style="text-align: left;">Choice</th>
<th style="text-align: left;">Rationale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">What to penalize</td>
<td style="text-align: left;">Log-hazards <span class="math inline">\(\log h_{rs}(t)\)</span></td>
<td style="text-align: left;">Quadratic in <span class="math inline">\(\theta\)</span>; standard</td>
</tr>
<tr class="even">
<td style="text-align: left;">Penalty type</td>
<td style="text-align: left;">Derivative-based (Wood 2016)</td>
<td style="text-align: left;">Adapts to uneven knots</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty order</td>
<td style="text-align: left;"><span class="math inline">\(m = 2\)</span> (curvature), configurable</td>
<td style="text-align: left;">Standard; penalizes roughness</td>
</tr>
<tr class="even">
<td style="text-align: left;">Smoothing selection</td>
<td style="text-align: left;">NCV via <code>PIJCVState</code> + criterion function</td>
<td style="text-align: left;">Accounts for within-subject correlation</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Competing risks</td>
<td style="text-align: left;">Shared-origin tensor products</td>
<td style="text-align: left;">Replaces ad-hoc total hazard penalty</td>
</tr>
<tr class="even">
<td style="text-align: left;">Error handling</td>
<td style="text-align: left;"><code>ArgumentError</code> for user input</td>
<td style="text-align: left;">Package convention</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty storage</td>
<td style="text-align: left;"><code>PenaltyConfig</code> struct</td>
<td style="text-align: left;">Keep hazard types immutable</td>
</tr>
<tr class="even">
<td style="text-align: left;">Initial scope</td>
<td style="text-align: left;">Markov + exact data</td>
<td style="text-align: left;">MCEM compatibility deferred</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="tensor-product-api-design" class="level2">
<h2 class="anchored" data-anchor-id="tensor-product-api-design">Tensor Product API Design</h2>
<section id="three-distinct-use-cases" class="level3">
<h3 class="anchored" data-anchor-id="three-distinct-use-cases">Three Distinct Use Cases</h3>
<p>Tensor products serve different purposes depending on what dimensions are involved:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 27%">
<col style="width: 25%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Use Case</th>
<th style="text-align: left;">API Location</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Œª parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Shared-origin baselines</strong></td>
<td style="text-align: left;">Model-level kwarg</td>
<td style="text-align: left;">Borrow strength across competing risk baselines</td>
<td style="text-align: left;">2 (<span class="math inline">\(\lambda_t\)</span>, <span class="math inline">\(\lambda_d\)</span>)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Covariate √ó covariate</strong></td>
<td style="text-align: left;">Formula <code>te(x1, x2)</code></td>
<td style="text-align: left;">Smooth interaction surface</td>
<td style="text-align: left;">2 per term</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Covariate √ó time</strong></td>
<td style="text-align: left;">Formula <code>te(x, t)</code></td>
<td style="text-align: left;">Time-varying covariate effect</td>
<td style="text-align: left;">2 per term</td>
</tr>
</tbody>
</table>
</section>
<section id="shared-origin-tensor-products-baseline-hazards" class="level3">
<h3 class="anchored" data-anchor-id="shared-origin-tensor-products-baseline-hazards">1. Shared-Origin Tensor Products (Baseline Hazards)</h3>
<p>For competing risks from state <span class="math inline">\(r\)</span> to destinations <span class="math inline">\(\{s_1, \ldots, s_D\}\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Model-level specification (NOT in hazard formulas)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(h12, h13, h14;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> [<span class="fl">1</span>]  <span class="co"># State 1's baselines share structure</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Explicit configuration</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(<span class="op">...</span>;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span> <span class="op">=&gt;</span> <span class="fu">SharedOriginConfig</span>(</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            dest_penalty <span class="op">=</span> <span class="op">:</span>ridge,      <span class="co"># :ridge, :difference, or Matrix</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            monotone_time <span class="op">=</span> <span class="cn">false</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            increasing <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Why model-level?</strong> This restructures the baseline hazard parameters into a tensor, which is a structural model choice, not a hazard-level formula term.</p>
</section>
<section id="covariate-covariate-interactions" class="level3">
<h3 class="anchored" data-anchor-id="covariate-covariate-interactions">2. Covariate √ó Covariate Interactions</h3>
<p>Smooth interaction surface between two covariates:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Full tensor product (includes main effects implicitly)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Main effects + pure interaction (ANOVA decomposition)</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> <span class="fu">s</span>(bmi) <span class="op">+</span> <span class="fu">ti</span>(age, bmi)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Semantics:</strong> - <code>te(x1, x2)</code>: Full tensor product <span class="math inline">\(f(x_1, x_2) = \sum_{ij} \beta_{ij} B_{1i}(x_1) B_{2j}(x_2)\)</span> - <code>ti(x1, x2)</code>: Interaction only (constrained to sum to zero over margins)</p>
</section>
<section id="time-varying-covariate-effects" class="level3">
<h3 class="anchored" data-anchor-id="time-varying-covariate-effects">3. Time-Varying Covariate Effects</h3>
<p>Covariate effect that changes smoothly over time:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Requires :sp family (time basis needed)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t)), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># With additional linear terms</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, t) <span class="op">+</span> trt), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Constraint:</strong> <code>te(x, t)</code> requires <code>:sp</code> family because it needs a time spline basis.</p>
</section>
<section id="api-summary" class="level3">
<h3 class="anchored" data-anchor-id="api-summary">API Summary</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Level</th>
<th style="text-align: left;">Family Constraint</th>
<th style="text-align: left;">Parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>shared_origin_tensor=[r]</code></td>
<td style="text-align: left;">Model</td>
<td style="text-align: left;"><code>:sp</code> required</td>
<td style="text-align: left;"><span class="math inline">\(K_t \times D\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>s(x)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\(K_x\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>te(x1, x2)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\(K_1 \times K_2\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>te(x, t)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;"><code>:sp</code> only</td>
<td style="text-align: left;"><span class="math inline">\(K_x \times K_t\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>ti(x1, x2)</code></td>
<td style="text-align: left;">Formula</td>
<td style="text-align: left;">Any</td>
<td style="text-align: left;"><span class="math inline">\((K_1-1) \times (K_2-1)\)</span></td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="the-three-key-design-questions" class="level2">
<h2 class="anchored" data-anchor-id="the-three-key-design-questions">The Three Key Design Questions</h2>
<section id="question-1-what-to-penalize" class="level3">
<h3 class="anchored" data-anchor-id="question-1-what-to-penalize">Question 1: What to Penalize?</h3>
<p>We have flexibility in what quantities we penalize for smoothness:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 36%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Target</th>
<th style="text-align: left;">Formula</th>
<th style="text-align: left;">Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Individual hazards</strong> <span class="math inline">\(h_{rs}(t)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\lambda_{rs} \int [h_{rs}^{(m)}]^2 dt\)</span></td>
<td style="text-align: left;">‚úÖ Primary target</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Shared-origin tensor</strong></td>
<td style="text-align: left;"><span class="math inline">\(\lambda_t (I_D \otimes S_t) + \lambda_d (S_d \otimes I)\)</span></td>
<td style="text-align: left;">‚úÖ Replaces total hazard penalty</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Covariate smooths</strong></td>
<td style="text-align: left;"><span class="math inline">\(\lambda_j \gamma_j^T S_j \gamma_j\)</span></td>
<td style="text-align: left;">‚úÖ New feature</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Total hazard</strong> <span class="math inline">\(H_r(t)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\mu_r \int [H_r^{(m)}]^2 dt\)</span></td>
<td style="text-align: left;">‚ùå Superseded by tensor products</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Transition probabilities</strong></td>
<td style="text-align: left;">Non-quadratic</td>
<td style="text-align: left;">üîç Future exploration</td>
</tr>
</tbody>
</table>
<p><strong>Parametrization:</strong> Log scale (standard, ensures positivity) <strong>Penalty order:</strong> <span class="math inline">\(m=2\)</span> (penalize curvature), user-configurable <strong>Penalty construction:</strong> Wood (2016) derivative-based algorithm</p>
</section>
<section id="question-2-how-to-set-tuning-parameters" class="level3">
<h3 class="anchored" data-anchor-id="question-2-how-to-set-tuning-parameters">Question 2: How to Set Tuning Parameters?</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 22%">
<col style="width: 33%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Method</th>
<th style="text-align: left;">Assumption</th>
<th style="text-align: left;">Works for MSM?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>GCV/UBRE/GACV</strong></td>
<td style="text-align: left;">Independent subjects</td>
<td style="text-align: left;">‚ö†Ô∏è Possible (with deviance residuals)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>REML</strong></td>
<td style="text-align: left;">Smooths as random effects</td>
<td style="text-align: left;">‚úÖ Yes ‚Äî benchmark method</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NCV (PIJCV)</strong></td>
<td style="text-align: left;">Subject-level independence</td>
<td style="text-align: left;">‚úÖ Yes ‚Äî primary method</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation:</strong> Use NCV (leave-one-subject-out CV via Predictive Infinitesimal Jackknife). Existing infrastructure: <code>PIJCVState</code> in <code>src/output/variance.jl</code>.</p>
</section>
<section id="question-3-how-to-borrow-strength-across-transitions" class="level3">
<h3 class="anchored" data-anchor-id="question-3-how-to-borrow-strength-across-transitions">Question 3: How to Borrow Strength Across Transitions?</h3>
<p>For competing risks from state <span class="math inline">\(r\)</span> to destinations <span class="math inline">\(\{s_1, \ldots, s_D\}\)</span>:</p>
<p><strong>Original approach (superseded)</strong>: <span class="math display">\[\mathcal{P}_{total} = \mu_r \left(\sum_s \theta_{rs}\right)^T S_r \left(\sum_s \theta_{rs}\right)\]</span></p>
<p><strong>New approach (tensor products)</strong>: <span class="math display">\[\mathcal{P}_{tensor} = \lambda_t \boldsymbol{\beta}^T (I_D \otimes S_t) \boldsymbol{\beta} + \lambda_d \boldsymbol{\beta}^T (S_d \otimes I_{K_t}) \boldsymbol{\beta}\]</span></p>
<p>The tensor product approach: - Shrinks destinations <strong>toward each other</strong> (not toward sum) - Has cleaner probabilistic interpretation (random effects) - Borrows strength for sparse transitions - Is more flexible (configurable destination penalty)</p>
<hr>
</section>
</section>
<section id="decision-1-what-to-penalize" class="level2">
<h2 class="anchored" data-anchor-id="decision-1-what-to-penalize">Decision 1: What to Penalize</h2>
<section id="the-penalized-log-likelihood" class="level3">
<h3 class="anchored" data-anchor-id="the-penalized-log-likelihood">The Penalized Log-Likelihood</h3>
<p>The penalized log-likelihood has the form:</p>
<p><span class="math display">\[\ell_p(\theta; \boldsymbol{\lambda}) = \ell(\theta) - \frac{1}{2} \mathcal{P}(\theta; \boldsymbol{\lambda})\]</span></p>
<p>where <span class="math inline">\(\mathcal{P}\)</span> is a quadratic penalty. Our combined penalty structure is:</p>
<p><span class="math display">\[\mathcal{P}(\theta) = \underbrace{\sum_{(r,s)} \lambda_{rs} \theta_{rs}^T S_{rs} \theta_{rs}}_{\text{individual hazard penalties}} + \underbrace{\sum_r \mu_r \left(\sum_s \theta_{rs}\right)^T S_r \left(\sum_s \theta_{rs}\right)}_{\text{total hazard penalties}}\]</span></p>
<p>where: - <span class="math inline">\(\theta_{rs}\)</span> = spline coefficients for log-hazard <span class="math inline">\(\log h_{rs}(t)\)</span> - <span class="math inline">\(S_{rs}\)</span> = penalty matrix for transition <span class="math inline">\((r,s)\)</span> - <span class="math inline">\(\lambda_{rs}\)</span> = smoothing parameter for transition <span class="math inline">\((r,s)\)</span> - <span class="math inline">\(\mu_r\)</span> = smoothing parameter for total hazard from state <span class="math inline">\(r\)</span></p>
</section>
<section id="candidate-penalty-targets" class="level3">
<h3 class="anchored" data-anchor-id="candidate-penalty-targets">Candidate Penalty Targets</h3>
<section id="individual-hazards-h_rst-standard-approach" class="level4">
<h4 class="anchored" data-anchor-id="individual-hazards-h_rst-standard-approach">1. Individual Hazards <span class="math inline">\(h_{rs}(t)\)</span> ‚Äî Standard Approach</h4>
<p>Each transition has its own penalty:</p>
<p><span class="math display">\[\mathcal{P}_{\text{ind}} = \sum_{(r,s) \in \mathcal{A}} \lambda_{rs} \int_0^T \left[h_{rs}^{(m)}(t)\right]^2 dt\]</span></p>
<p><strong>Pros:</strong> Simple, well-understood, standard in the literature</p>
<p><strong>Cons:</strong> Total hazard can be wiggly even if individual hazards are smooth</p>
</section>
<section id="total-hazard-h_rt-sum_s-h_rst-superseded" class="level4">
<h4 class="anchored" data-anchor-id="total-hazard-h_rt-sum_s-h_rst-superseded">2. Total Hazard <span class="math inline">\(H_r(t) = \sum_s h_{rs}(t)\)</span> ‚Äî SUPERSEDED</h4>
<blockquote class="blockquote">
<p><strong>‚ö†Ô∏è STATUS: SUPERSEDED BY TENSOR PRODUCT APPROACH</strong></p>
<p>This section documents a penalty approach that was considered during initial design but has been superseded by shared-origin tensor product penalties (see Section below). The tensor product approach is preferred because it: - Shrinks destinations toward each other (not toward their sum) - Has cleaner probabilistic interpretation (random effects on destinations)<br>
- Is more flexible (can specify structure on destination dimension)</p>
<p>This section is retained for historical completeness and to explain why we chose NOT to implement total hazard penalties.</p>
</blockquote>
<p>The total hazard governs the overall rate of leaving state <span class="math inline">\(r\)</span>:</p>
<p><span class="math display">\[\mathcal{P}_{\text{total}} = \sum_{r} \mu_r \int_0^T \left[\sum_s h_{rs}^{(m)}(t)\right]^2 dt\]</span></p>
<p><strong>Pros:</strong> - Ensures survival function <span class="math inline">\(S_r(t) = \exp(-\int_0^t H_r(u) du)\)</span> is smooth - Important for competing risks where we care about overall event rate</p>
<p><strong>Cons:</strong> - Introduces coupling between transitions (not separable) - More complex Hessian structure - <strong>Superseded by tensor products</strong> which achieve similar goals with better properties</p>
</section>
<section id="cumulative-hazard-lambda_rst-explore" class="level4">
<h4 class="anchored" data-anchor-id="cumulative-hazard-lambda_rst-explore">3. Cumulative Hazard <span class="math inline">\(\Lambda_{rs}(t)\)</span> ‚Äî Explore</h4>
<p>While penalizing the <span class="math inline">\(m\)</span>-th derivative of the cumulative hazard is mathematically equivalent to penalizing the <span class="math inline">\((m-1)\)</span>-th derivative of the hazard, the numerical properties and interpretation may differ. We will explore this as an alternative target.</p>
</section>
<section id="transition-probabilities-p_rst-explore" class="level4">
<h4 class="anchored" data-anchor-id="transition-probabilities-p_rst-explore">4. Transition Probabilities <span class="math inline">\(P_{rs}(t)\)</span> ‚Äî Explore</h4>
<p>For panel data, the likelihood is constructed directly from transition probabilities <span class="math inline">\(P(s(t_{j+1}) | s(t_j))\)</span>, making this a natural target for smoothness.</p>
<p><strong>Pros:</strong> - Directly smooths the quantity of interest for panel data - Aligns with the structure of the path likelihood</p>
<p><strong>Cons:</strong> - Non-quadratic in parameters (requires iterative approximation) - Computationally expensive (requires matrix exponentials and derivatives)</p>
<p><strong>Feasibility:</strong> Eletti et al.&nbsp;(2024) provide the analytical derivatives for Markov models. For semi-Markov models, these quantities are also computable (e.g., via numerical integration or simulation), allowing us to explore this direction for all model types.</p>
</section>
<section id="sojourn-time-distributions-explore" class="level4">
<h4 class="anchored" data-anchor-id="sojourn-time-distributions-explore">5. Sojourn Time Distributions ‚Äî Explore</h4>
<p>The sojourn time in state <span class="math inline">\(r\)</span> has survival function <span class="math inline">\(S_r(t) = \exp(-\Lambda_r(t))\)</span>. Penalizing the roughness of the sojourn time distribution (e.g., its density <span class="math inline">\(f_r(t) = H_r(t)S_r(t)\)</span>) targets an <strong>observable quantity</strong>‚Äîthe time spent in a state‚Äîrather than the latent hazard rate.</p>
<p><strong>Hypothesis:</strong> Penalizing observables might lead to better behaved predictions in data-sparse regions compared to penalizing latent parameters.</p>
</section>
<section id="transition-densities-explore" class="level4">
<h4 class="anchored" data-anchor-id="transition-densities-explore">6. Transition Densities ‚Äî Explore</h4>
<p>The density of observing a transition from <span class="math inline">\(r \to s\)</span> at time <span class="math inline">\(t\)</span> is <span class="math inline">\(f_{rs}(t) = h_{rs}(t) S_r(t)\)</span>. This represents the distribution of actual event times.</p>
<p><strong>Pros:</strong> - Directly smooths the distribution of observed events - May prevent artifacts where hazard spikes in regions with low survival probability (few people at risk)</p>
<p><strong>Cons:</strong> - Highly non-linear in parameters - Depends on total hazard (coupling)</p>
</section>
</section>
<section id="philosophy-observables-vs.-parameters" class="level3">
<h3 class="anchored" data-anchor-id="philosophy-observables-vs.-parameters">Philosophy: Observables vs.&nbsp;Parameters</h3>
<p>A key open question is the effect of penalizing <strong>observable quantities</strong> (transition probabilities, sojourn times, event densities) versus <strong>model parameters</strong> (hazards, log-hazards).</p>
<ul>
<li><strong>Parameter Penalties (Standard):</strong> Smooth the underlying generator.
<ul>
<li><em>Pros:</em> Computationally simpler (often quadratic), ensures the ‚Äúengine‚Äù of the model is well-behaved.</li>
<li><em>Cons:</em> Can allow wild behavior in observables if the transformation is non-linear (e.g., small hazard wiggles can be magnified or suppressed in <span class="math inline">\(P(t)\)</span>).</li>
</ul></li>
<li><strong>Observable Penalties:</strong> Smooth the resulting data distribution.
<ul>
<li><em>Pros:</em> Aligns smoothness with what we see and measure. Prevents ‚Äúinvisible wiggliness‚Äù (e.g., wiggly hazards in regions where no one survives).</li>
<li><em>Cons:</em> Computationally expensive (non-quadratic, dense Hessians), complex dependencies.</li>
</ul></li>
</ul>
<p>We intend to explore whether shifting the penalty target to observables yields better predictive performance, particularly for panel data.</p>
</section>
<section id="the-coupled-hessian-structure" class="level3">
<h3 class="anchored" data-anchor-id="the-coupled-hessian-structure">The Coupled Hessian Structure</h3>
<p>With total hazard penalties, the penalty Hessian has off-diagonal blocks:</p>
<p><span class="math display">\[\frac{\partial^2 \mathcal{P}}{\partial \theta_{rs} \partial \theta_{rs}} = 2\lambda_{rs} S_{rs} + 2\mu_r S_r\]</span></p>
<p><span class="math display">\[\frac{\partial^2 \mathcal{P}}{\partial \theta_{rs} \partial \theta_{rs'}} = 2\mu_r S_r \quad \text{(transitions from same state)}\]</span></p>
<p><span class="math display">\[\frac{\partial^2 \mathcal{P}}{\partial \theta_{rs} \partial \theta_{r's'}} = 0 \quad \text{(transitions from different states)}\]</span></p>
<p><strong>Key insight:</strong> Total hazard penalties couple transitions from the same origin state.</p>
</section>
<section id="penalty-matrix-construction-wood-2016-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="penalty-matrix-construction-wood-2016-algorithm">Penalty Matrix Construction: Wood (2016) Algorithm</h3>
<p>For B-splines of order <span class="math inline">\(m_1\)</span> with penalty on the <span class="math inline">\(m_2\)</span>-th derivative:</p>
<p><strong>Algorithm:</strong> 1. Set <span class="math inline">\(p = m_1 - m_2\)</span> 2. For each knot interval, generate <span class="math inline">\(p+1\)</span> Gauss-Legendre points 3. Compute <span class="math inline">\(G\)</span>: maps coefficients to derivative values 4. Compute <span class="math inline">\(W\)</span>: integration weights (adapts to knot spacing) 5. Return <span class="math inline">\(S = G^T W G\)</span></p>
<p><strong>Properties:</strong> - <span class="math inline">\(S\)</span> is banded with <span class="math inline">\(2(m_1 - 1) + 1\)</span> diagonals - Adapts automatically to uneven knot spacing - Cost: <span class="math inline">\(O(bk)\)</span> where <span class="math inline">\(b\)</span> = bandwidth, <span class="math inline">\(k\)</span> = basis size</p>
</section>
<section id="the-parametrization-question" class="level3">
<h3 class="anchored" data-anchor-id="the-parametrization-question">The Parametrization Question</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 27%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Option</th>
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Penalty</th>
<th style="text-align: left;">Verdict</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>A: Natural scale</strong></td>
<td style="text-align: left;"><span class="math inline">\(h = \sum_k \beta_k B_k\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\lambda \beta^T S \beta\)</span></td>
<td style="text-align: left;">‚ùå Positivity issues</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>B: Log scale</strong></td>
<td style="text-align: left;"><span class="math inline">\(\log h = \sum_k \theta_k B_k\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\lambda \theta^T S \theta\)</span></td>
<td style="text-align: left;">‚úÖ Standard, use this</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>C: Hybrid</strong></td>
<td style="text-align: left;"><span class="math inline">\(h = \exp(\sum_k \theta_k B_k)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\lambda \int [h^{(m)}]^2\)</span></td>
<td style="text-align: left;">‚è≥ Future extension</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation:</strong> Option B (log scale). Standard, ensures positivity, keeps penalty quadratic.</p>
</section>
<section id="summary-penalty-design-decisions" class="level3">
<h3 class="anchored" data-anchor-id="summary-penalty-design-decisions">Summary: Penalty Design Decisions</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 43%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Decision</th>
<th style="text-align: left;">Recommendation</th>
<th style="text-align: left;">Rationale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Individual hazards</td>
<td style="text-align: left;">‚úÖ Yes</td>
<td style="text-align: left;">Standard, necessary</td>
</tr>
<tr class="even">
<td style="text-align: left;">Total hazards</td>
<td style="text-align: left;">‚úÖ Yes</td>
<td style="text-align: left;">Important for competing risks</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cumulative hazards</td>
<td style="text-align: left;">üîç Explore</td>
<td style="text-align: left;">Alternative to hazard penalty</td>
</tr>
<tr class="even">
<td style="text-align: left;">Transition probabilities</td>
<td style="text-align: left;">üîç Explore</td>
<td style="text-align: left;">Natural for panel data</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sojourn/Transition densities</td>
<td style="text-align: left;">üîç Explore</td>
<td style="text-align: left;">Smooth observables vs parameters</td>
</tr>
<tr class="even">
<td style="text-align: left;">Parametrization</td>
<td style="text-align: left;">Log scale</td>
<td style="text-align: left;">Positivity, quadratic penalty</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty order</td>
<td style="text-align: left;"><span class="math inline">\(m=2\)</span></td>
<td style="text-align: left;">Penalize curvature</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="decision-2-how-to-set-tuning-parameters" class="level2">
<h2 class="anchored" data-anchor-id="decision-2-how-to-set-tuning-parameters">Decision 2: How to Set Tuning Parameters</h2>
<section id="the-nested-optimization-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-nested-optimization-problem">The Nested Optimization Problem</h3>
<p>Given the penalty structure, we need to find optimal <span class="math inline">\(\boldsymbol{\lambda} = (\lambda_{rs}, \mu_r)\)</span>:</p>
<p><span class="math display">\[\min_{\boldsymbol{\lambda}} \text{Criterion}(\boldsymbol{\lambda}) \quad \text{where} \quad \hat{\theta}(\boldsymbol{\lambda}) = \arg\max_\theta \ell_p(\theta; \boldsymbol{\lambda})\]</span></p>
<p><strong>Inner optimization:</strong> Newton/trust-region for <span class="math inline">\(\theta\)</span> given <span class="math inline">\(\boldsymbol{\lambda}\)</span></p>
<p><strong>Outer optimization:</strong> BFGS or similar for <span class="math inline">\(\boldsymbol{\lambda}\)</span></p>
</section>
<section id="why-classical-cv-methods-are-suboptimal-for-msm" class="level3">
<h3 class="anchored" data-anchor-id="why-classical-cv-methods-are-suboptimal-for-msm">Why Classical CV Methods Are Suboptimal for MSM</h3>
<p><strong>GCV, UBRE, GACV</strong> are derived under the assumption of <strong>independent subjects</strong> (or independent sampling units).</p>
<p><strong>Machado et al.&nbsp;(2018)</strong> applied UBRE to multistate models by: 1. Approximating the likelihood with a penalized least squares problem (IRLS). 2. Defining a ‚Äúworking response‚Äù vector <span class="math inline">\(z\)</span> and ‚Äúhat matrix‚Äù <span class="math inline">\(A\)</span>. 3. Applying the standard UBRE formula.</p>
<p><strong>The Issue (Wood 2024):</strong> In panel data, observations from the same subject are <strong>correlated</strong>. - Standard implementations often treat every row (transition) as independent, which leads to <strong>undersmoothing</strong> (fitting the within-subject noise). - However, these methods <strong>can</strong> be adapted if we treat the <strong>subject</strong> as the independent unit. - A key challenge is defining ‚Äúresiduals‚Äù for MSMs, which lack the clear <span class="math inline">\(y - \hat{y}\)</span> structure of GLMs. - <strong>Solution:</strong> We can use <strong>deviance residuals</strong> (aggregated at the subject level) as a proxy for the squared error term in these criteria. This allows GCV/UBRE/GACV to be used, provided the independence assumption is applied at the subject level.</p>
<p><strong>NCV Solution:</strong> NCV explicitly handles this by leaving out <strong>independent units</strong> (subjects) rather than single observations.</p>
</section>
<section id="ncv-the-natural-choice-for-multistate-models" class="level3">
<h3 class="anchored" data-anchor-id="ncv-the-natural-choice-for-multistate-models">NCV: The Natural Choice for Multistate Models</h3>
<p>Leave out an entire <strong>neighbourhood</strong> (= subject) instead of single observations:</p>
<p><span class="math display">\[\text{NCV}(\boldsymbol{\lambda}) = \sum_k D\left(y_k, \hat{\theta}^{-k}(\boldsymbol{\lambda})\right)\]</span></p>
<p>where <span class="math inline">\(\hat{\theta}^{-k}\)</span> is the estimate with subject <span class="math inline">\(k\)</span> removed.</p>
<p><strong>Why this is right:</strong> - Matches how likelihoods factorize (at subject level) - Natural generalization of CV for panel data - Not an approximation‚Äîit‚Äôs the correct CV criterion</p>
</section>
<section id="efficient-computation-pijcv" class="level3">
<h3 class="anchored" data-anchor-id="efficient-computation-pijcv">Efficient Computation: PIJCV</h3>
<p>Exact NCV requires <span class="math inline">\(m\)</span> refits (one per subject). Wood‚Äôs key contribution: approximate via a single Newton step.</p>
<p><span class="math display">\[\hat{\theta}^{-k} \approx \hat{\theta} + H_{\lambda,k}^{-1} g_k\]</span></p>
<p>where: - <span class="math inline">\(H_{\lambda,k} = H_\lambda - H_k\)</span> (downdated Hessian) - <span class="math inline">\(g_k\)</span> = gradient contribution from subject <span class="math inline">\(k\)</span></p>
<p>This is the <strong>Predictive Infinitesimal Jackknife Cross-Validation (PIJCV)</strong>.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Standard IJ</th>
<th style="text-align: left;">PIJCV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Leave-out unit</td>
<td style="text-align: left;">Observation</td>
<td style="text-align: left;">Neighbourhood (subject)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hessian</td>
<td style="text-align: left;">Full <span class="math inline">\(H\)</span></td>
<td style="text-align: left;">Downdated <span class="math inline">\(H_{\lambda,k}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Accuracy</td>
<td style="text-align: left;"><span class="math inline">\(O(n^{-1})\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(n^{-2})\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Cost:</strong> <span class="math inline">\(O(mp^2)\)</span> via Cholesky downdating (already implemented in <code>PIJCVState</code>).</p>
<p><strong>Implementation note</strong>: The existing <code>PIJCVState</code> infrastructure computes LOO parameter perturbations <span class="math inline">\(\hat{\theta}^{-k}\)</span> but does NOT compute the NCV criterion itself. We must add <code>compute_ncv_criterion(state, model, data)</code> to evaluate the deviance at LOO parameters.</p>
</section>
<section id="reml-as-alternative" class="level3">
<h3 class="anchored" data-anchor-id="reml-as-alternative">REML as Alternative</h3>
<p>REML treats smoothing parameters as variance components:</p>
<p><span class="math display">\[\ell_{REML}(\lambda) = \ell_p(\hat{\theta}) - \frac{1}{2}\log|H_p| + \frac{1}{2}\log|S_\lambda| + \text{const}\]</span></p>
<p><strong>Pros:</strong> More stable optimization landscape, widely used</p>
<p><strong>Cons:</strong> Different interpretation (likelihood-based vs prediction-based)</p>
<p>Implement as secondary method for comparison (may defer to reduce initial scope).</p>
</section>
<section id="how-many-smoothing-parameters" class="level3">
<h3 class="anchored" data-anchor-id="how-many-smoothing-parameters">How Many Smoothing Parameters?</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Option</th>
<th style="text-align: left;"># Parameters</th>
<th style="text-align: left;">Use When</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Global <span class="math inline">\(\lambda\)</span></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Debugging, simple models</td>
</tr>
<tr class="even">
<td style="text-align: left;">Per-transition <span class="math inline">\(\lambda_{rs}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(|\mathcal{A}|\)</span></td>
<td style="text-align: left;">Default</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Per-origin-state <span class="math inline">\(\lambda_r\)</span></td>
<td style="text-align: left;"># states</td>
<td style="text-align: left;">Many transitions</td>
</tr>
<tr class="even">
<td style="text-align: left;">+ Total hazard <span class="math inline">\(\mu_r\)</span></td>
<td style="text-align: left;">+ # competing risk states</td>
<td style="text-align: left;">Competing risks</td>
</tr>
</tbody>
</table>
<p><strong>Tradeoffs:</strong> - Fewer parameters ‚Üí more stable, faster - More parameters ‚Üí more flexible, risk of overfitting <span class="math inline">\(\lambda\)</span></p>
<p><strong>Strategy:</strong> Start simple (global), add complexity as needed.</p>
</section>
<section id="comparison-of-smoothing-selection-methods" class="level3">
<h3 class="anchored" data-anchor-id="comparison-of-smoothing-selection-methods">Comparison of Smoothing Selection Methods</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 28%">
<col style="width: 24%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Method</th>
<th style="text-align: left;">Scale Known?</th>
<th style="text-align: left;">Assumption</th>
<th style="text-align: left;">Works for MSM?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>GCV</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Independent subjects</td>
<td style="text-align: left;">‚ö†Ô∏è Possible (with deviance residuals)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>UBRE</strong></td>
<td style="text-align: left;">Yes</td>
<td style="text-align: left;">Independent subjects</td>
<td style="text-align: left;">‚ö†Ô∏è Possible (with deviance residuals)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>GACV</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Independent subjects</td>
<td style="text-align: left;">‚ö†Ô∏è Possible (with deviance residuals)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>REML</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Random effects view</td>
<td style="text-align: left;">‚úÖ</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>NCV (PIJCV)</strong></td>
<td style="text-align: left;">Either</td>
<td style="text-align: left;">Subject-level factorization</td>
<td style="text-align: left;">‚úÖ</td>
</tr>
</tbody>
</table>
</section>
<section id="summary-smoothing-parameter-selection" class="level3">
<h3 class="anchored" data-anchor-id="summary-smoothing-parameter-selection">Summary: Smoothing Parameter Selection</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Decision</th>
<th style="text-align: left;">Recommendation</th>
<th style="text-align: left;">Rationale</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Primary method</td>
<td style="text-align: left;">NCV (PIJCV)</td>
<td style="text-align: left;">Natural for subject-level likelihoods</td>
</tr>
<tr class="even">
<td style="text-align: left;">Secondary method</td>
<td style="text-align: left;">REML</td>
<td style="text-align: left;">Good benchmark</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Reporting</td>
<td style="text-align: left;">AIC/BIC + edf</td>
<td style="text-align: left;">Model comparison</td>
</tr>
<tr class="even">
<td style="text-align: left;">Default structure</td>
<td style="text-align: left;">Per-transition</td>
<td style="text-align: left;">Balance flexibility/stability</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="the-wood-marra-computational-framework" class="level2">
<h2 class="anchored" data-anchor-id="the-wood-marra-computational-framework">The Wood-Marra Computational Framework</h2>
<p>The methods in Eletti (2024) build on a computational framework developed by Marra and Wood:</p>
<section id="key-papers" class="level3">
<h3 class="anchored" data-anchor-id="key-papers">Key Papers</h3>
<ol type="1">
<li><strong>Marra &amp; Radice (2020)</strong> ‚Äî Trust region + automatic smoothing selection</li>
<li><strong>Marra &amp; Wood (2012)</strong> ‚Äî Coverage properties of Bayesian CIs</li>
<li><strong>Marra et al.&nbsp;(2017)</strong> ‚Äî Full gradient/Hessian approach</li>
</ol>
</section>
<section id="the-connection" class="level3">
<h3 class="anchored" data-anchor-id="the-connection">The Connection</h3>
<p>Both REML (Marra) and NCV (Wood) require: - <strong>Exact analytical Hessian</strong> (not approximations) - <strong>Efficient Cholesky factorization</strong> - <strong>Per-subject gradient/Hessian contributions</strong></p>
<p><strong>Key insight:</strong> The same infrastructure supports both methods. We build once, get both.</p>
</section>
<section id="implications-for-implementation" class="level3">
<h3 class="anchored" data-anchor-id="implications-for-implementation">Implications for Implementation</h3>
<ol type="1">
<li><strong>Follow Marra &amp; Radice (2020)</strong> for optimization:
<ul>
<li>Trust region (not line search)</li>
<li>Analytical Hessian via Kosorok &amp; Chao (1996)</li>
</ul></li>
<li><strong>Use NCV instead of REML</strong> as primary:
<ul>
<li>Same computational infrastructure</li>
<li>More robust for panel data</li>
</ul></li>
<li><strong>Eletti (2024) is our template</strong>, with NCV replacing REML.</li>
</ol>
<hr>
</section>
</section>
<section id="handling-uneven-knot-spacing" class="level2">
<h2 class="anchored" data-anchor-id="handling-uneven-knot-spacing">Handling Uneven Knot Spacing</h2>
<section id="univariate-baseline-hazards-current-work" class="level3">
<h3 class="anchored" data-anchor-id="univariate-baseline-hazards-current-work">Univariate Baseline Hazards (Current Work)</h3>
<p><strong>Quantile-based knot placement:</strong> Already implemented in <code>place_interior_knots()</code>.</p>
<p><span class="math display">\[x_j = F^{-1}\left(\frac{j}{n_k + 1}\right)\]</span></p>
<p>Wood‚Äôs algorithm adapts automatically via the weight matrix: <span class="math display">\[W = \bigoplus_{q=1}^{n_k} \frac{h_q}{2} \tilde{W}\]</span></p>
<p>where <span class="math inline">\(h_q\)</span> is knot interval width.</p>
</section>
<section id="tensor-products-for-partial-domains" class="level3">
<h3 class="anchored" data-anchor-id="tensor-products-for-partial-domains">Tensor Products for Partial Domains</h3>
<p>When data don‚Äôt fill the domain (e.g., age √ó time with triangular support):</p>
<ol type="1">
<li>Identify unsupported basis functions</li>
<li>Drop corresponding rows from penalty matrix <span class="math inline">\(\tilde{D}_j\)</span></li>
<li>Constrain unsupported coefficients to zero</li>
</ol>
<hr>
</section>
</section>
<section id="extended-scope-covariate-splines" class="level2">
<h2 class="anchored" data-anchor-id="extended-scope-covariate-splines">Extended Scope: Covariate Splines</h2>
<section id="motivation" class="level3">
<h3 class="anchored" data-anchor-id="motivation">Motivation</h3>
<p>Support smooth nonlinear covariate effects via <code>s(covariate)</code> syntax in hazard formulas:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age) <span class="op">+</span> trt), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">2</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="model-structure" class="level3">
<h3 class="anchored" data-anchor-id="model-structure">Model Structure</h3>
<p>For covariate <span class="math inline">\(x\)</span> with B-spline basis <span class="math inline">\(\{B_{cj}(x)\}_{j=1}^{K_c}\)</span>: <span class="math display">\[\eta = \beta_0 + \sum_{j=1}^{K_c} \gamma_j B_{cj}(x) + \text{linear terms}\]</span></p>
</section>
<section id="penalty" class="level3">
<h3 class="anchored" data-anchor-id="penalty">Penalty</h3>
<p>Each smooth term has its own penalty: <span class="math display">\[\mathcal{P}_{cov}(\gamma) = \sum_{j} \lambda_j \gamma_j^T S_j \gamma_j\]</span></p>
</section>
<section id="identifiability" class="level3">
<h3 class="anchored" data-anchor-id="identifiability">Identifiability</h3>
<p>Smooth + intercept are non-identifiable. Resolve via <strong>sum-to-zero constraint</strong>: <span class="math display">\[\sum_i s(x_i) = 0\]</span></p>
<p>Implemented by centering the basis matrix: <span class="math inline">\(\tilde{B} = B - \bar{B}\)</span></p>
</section>
<section id="centering-and-back-transformation" class="level3">
<h3 class="anchored" data-anchor-id="centering-and-back-transformation">Centering and Back-Transformation</h3>
<section id="basis-centering-required" class="level4">
<h4 class="anchored" data-anchor-id="basis-centering-required">Basis Centering (REQUIRED)</h4>
<p><strong>Centered basis</strong>: <span class="math inline">\(\tilde{B} = B - \bar{B}\)</span> ensures <span class="math inline">\(\sum_i f(x_i) = 0\)</span>.</p>
<p><strong>Relationship</strong>: - Centered: <span class="math inline">\(f(x) = \tilde{B}(x)^T \tilde{\gamma}\)</span> - Uncentered: <span class="math inline">\(f(x) = B(x)^T \gamma - c\)</span> where <span class="math inline">\(c = \bar{B}^T \gamma\)</span> - Coefficients are the same (<span class="math inline">\(\gamma = \tilde{\gamma}\)</span>), but intercept absorbs <span class="math inline">\(c\)</span></p>
<p><strong>For prediction at new <span class="math inline">\(x_{new}\)</span></strong>: Must store <span class="math inline">\(\bar{B}\)</span> to compute <span class="math inline">\(\tilde{B}(x_{new}) = B(x_{new}) - \bar{B}\)</span>.</p>
</section>
<section id="covariate-scaling-not-recommended" class="level4">
<h4 class="anchored" data-anchor-id="covariate-scaling-not-recommended">Covariate Scaling: NOT RECOMMENDED</h4>
<p>After reviewing established packages: - <strong>MixedModels.jl</strong>: Does NOT scale or center fixed effects covariates - <strong>survival (R)</strong>: Does NOT scale design matrix; centers linear predictor post-hoc only</p>
<p><strong>Decision</strong>: Do NOT scale covariates. - Modern optimizers handle scale differences via Hessian adaptation - Eliminates complexity of storing/applying scale factors - Users can pre-transform if numerical issues arise - Time is never scaled (consistency with existing APIs)</p>
</section>
<section id="storage-for-prediction" class="level4">
<h4 class="anchored" data-anchor-id="storage-for-prediction">Storage for Prediction</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SmoothTermInfo</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    term<span class="op">::</span><span class="dt">SmoothTerm</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    basis<span class="op">::</span><span class="dt">BSplineBasis</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    centering_vec<span class="op">::</span><span class="dt">Vector{Float64}  </span><span class="co"># BÃÑ for basis centering</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    x_range<span class="op">::</span><span class="dt">Tuple{Float64, Float64}  </span><span class="co"># Data range for plotting</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
</section>
<section id="statsmodels.jl-formula-integration" class="level2">
<h2 class="anchored" data-anchor-id="statsmodels.jl-formula-integration">StatsModels.jl Formula Integration</h2>
<section id="the-shadowed-formula-macro-approach" class="level3">
<h3 class="anchored" data-anchor-id="the-shadowed-formula-macro-approach">The Shadowed <span class="citation" data-cites="formula">@formula</span> Macro Approach</h3>
<p><strong>Critical limitation</strong>: StatsModels.jl‚Äôs <code>@formula</code> macro rejects keyword arguments at parse time. It checks the AST for <code>:kw</code> and <code>:parameters</code> nodes and throws <code>ArgumentError</code> before any dispatch occurs. This means <code>@formula(0 ~ s(age; k=5))</code> fails immediately.</p>
<p><strong>Solution</strong>: MultistateModels exports a <strong>shadowed <code>@formula</code> macro</strong> that preprocesses smooth term syntax before delegating to <code>StatsModels.@formula</code>. This is implemented in <code>src/construction/formula.jl</code>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># File: src/construction/formula.jl</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">StatsModels</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare smooth term functions (must exist for FunctionTerm{typeof(s)})</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> s <span class="kw">end</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> te <span class="kw">end</span>  </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> ti <span class="kw">end</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="st">Transform smooth terms with kwargs to positional args before StatsModels parsing.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="st">s(age; k=5, penalty_order=3) ‚Üí s(age, 5, 3)</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="st">te(age, bmi; k=(8, 6)) ‚Üí te(age, bmi, 8, 6, 2)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">transform_smooth_terms</span>(ex)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ex isa <span class="dt">Expr</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ex.head <span class="op">==</span> <span class="op">:</span>call <span class="op">&amp;&amp;</span> <span class="fu">length</span>(ex.args) <span class="op">&gt;=</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> ex.args[<span class="fl">1</span>] <span class="kw">in</span> (<span class="op">:</span>s, <span class="op">:</span>te, <span class="op">:</span>ti)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">transform_smooth_call</span>(ex)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">Expr</span>(ex.head, [<span class="fu">transform_smooth_terms</span>(a) for a <span class="kw">in</span> ex.args]<span class="op">...</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ex</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">transform_smooth_call</span>(ex)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    func <span class="op">=</span> ex.args[<span class="fl">1</span>]</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    positional <span class="op">=</span> <span class="dt">Symbol</span>[]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> func <span class="op">==</span> <span class="op">:</span>s ? <span class="fl">10</span> <span class="op">:</span> (<span class="fl">10</span>, <span class="fl">10</span>)  <span class="co"># Default k</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> <span class="fl">2</span>               <span class="co"># Default penalty order</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fu">length</span>(ex.args)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        arg <span class="op">=</span> ex.args[i]</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arg isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> arg.head <span class="op">==</span> <span class="op">:</span>parameters</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract kwargs from parameters block</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> kwexpr <span class="kw">in</span> arg.args</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> kwexpr isa <span class="dt">Expr</span> <span class="op">&amp;&amp;</span> kwexpr.head <span class="op">==</span> <span class="op">:</span>kw</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>                    name, val <span class="op">=</span> kwexpr.args[<span class="fl">1</span>], kwexpr.args[<span class="fl">2</span>]</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> name <span class="op">==</span> <span class="op">:</span>k</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>                        k <span class="op">=</span> val</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">elseif</span> name <span class="op">==</span> <span class="op">:</span>penalty_order</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                        penalty_order <span class="op">=</span> val</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">end</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">end</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">end</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elseif</span> arg isa <span class="dt">Symbol</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>            <span class="fu">push!</span>(positional, arg)</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build positional-only call</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> func <span class="op">==</span> <span class="op">:</span>s</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">Expr</span>(<span class="op">:</span>call, <span class="op">:</span>s, positional[<span class="fl">1</span>], k, penalty_order)</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>  <span class="co"># te or ti</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        k1, k2 <span class="op">=</span> k isa <span class="dt">Tuple</span> ? k <span class="op">:</span> (k, k)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">Expr</span>(<span class="op">:</span>call, func, positional[<span class="fl">1</span>], positional[<span class="fl">2</span>], k1, k2, penalty_order)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a><span class="st">    @formula(ex)</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a><span class="st">Extended formula macro supporting smooth term kwargs.</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a><span class="st">Transforms s(x; k=5) syntax to s(x, 5, 2) before calling StatsModels.@formula.</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a><span class="kw">macro</span> <span class="fu">formula</span>(ex)</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    transformed <span class="op">=</span> <span class="fu">transform_smooth_terms</span>(ex)</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">:</span>(StatsModels.<span class="pp">@formula</span>(<span class="op">\$</span>transformed))</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a><span class="co"># Export (in MultistateModels.jl, not here)</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a><span class="co"># export @formula, s, te, ti</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="user-facing-api" class="level3">
<h3 class="anchored" data-anchor-id="user-facing-api">User-Facing API</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">MultistateModels</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># All these now work:</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age; k<span class="op">=</span><span class="fl">5</span>)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>h13 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">te</span>(age, bmi; k<span class="op">=</span>(<span class="fl">8</span>, <span class="fl">6</span>))), <span class="op">:</span>sp, <span class="fl">1</span>, <span class="fl">3</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>h14 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age; k<span class="op">=</span><span class="fl">5</span>, penalty_order<span class="op">=</span><span class="fl">3</span>) <span class="op">+</span> trt), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">4</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="term-registration-via-apply_schema" class="level3">
<h3 class="anchored" data-anchor-id="term-registration-via-apply_schema">Term Registration via apply_schema</h3>
<p>After the macro transforms kwargs to positional args, StatsModels creates <code>FunctionTerm</code> objects with positional arguments as <code>ConstantTerm</code> in <code>ft.args</code>. We dispatch on these:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Register s() term conversion</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># After transformation: s(age, 5, 2) ‚Üí ft.args = [Term(:age), ConstantTerm(5), ConstantTerm(2)]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co"> (R9-1): Second argument MUST be schema::StatsModels.Schema for dispatch to work</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(s)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> ft.args[<span class="fl">1</span>].sym</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> ft.args[<span class="fl">2</span>].n              <span class="co"># ConstantTerm has .n accessor</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> ft.args[<span class="fl">3</span>].n</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">SmoothTerm</span>(var, k, penalty_order, <span class="op">:</span>natural)  <span class="co"># extrapolation default</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Register te() term conversion  </span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(te)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    v1, v2 <span class="op">=</span> ft.args[<span class="fl">1</span>].sym, ft.args[<span class="fl">2</span>].sym</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> ft.args[<span class="fl">3</span>].n, ft.args[<span class="fl">4</span>].n</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> ft.args[<span class="fl">5</span>].n</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">TensorTerm</span>((v1, v2), (k1, k2), penalty_order, (<span class="cn">false</span>, <span class="cn">false</span>), (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">false</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Register ti() term conversion</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> StatsModels.<span class="fu">apply_schema</span>(ft<span class="op">::</span><span class="dt">FunctionTerm{typeof(ti)}</span>, schema<span class="op">::</span><span class="dt">StatsModels.Schema</span>, Mod<span class="op">::</span><span class="dt">Type</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    v1, v2 <span class="op">=</span> ft.args[<span class="fl">1</span>].sym, ft.args[<span class="fl">2</span>].sym</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> ft.args[<span class="fl">3</span>].n, ft.args[<span class="fl">4</span>].n</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    penalty_order <span class="op">=</span> ft.args[<span class="fl">5</span>].n</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">TensorTerm</span>((v1, v2), (k1, k2), penalty_order, (<span class="cn">false</span>, <span class="cn">false</span>), (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">true</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="interaction-pattern-summary" class="level3">
<h3 class="anchored" data-anchor-id="interaction-pattern-summary">Interaction Pattern Summary</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 24%">
<col style="width: 21%">
<col style="width: 29%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Pattern</th>
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Semantics</th>
<th style="text-align: left;">Œª count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Smooth main</td>
<td style="text-align: left;"><code>s(age)</code></td>
<td style="text-align: left;"><span class="math inline">\(f(\text{age})\)</span></td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Varying coefficient</td>
<td style="text-align: left;"><code>s(age, by=trt)</code></td>
<td style="text-align: left;"><span class="math inline">\(\text{trt} \cdot f(\text{age})\)</span></td>
<td style="text-align: left;">1 per level</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Linear √ó smooth</td>
<td style="text-align: left;"><code>s(age) * trt</code></td>
<td style="text-align: left;">Main + interaction</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Smooth √ó smooth</td>
<td style="text-align: left;"><code>te(age, bmi)</code></td>
<td style="text-align: left;">Tensor product</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pure interaction</td>
<td style="text-align: left;"><code>s(age) + s(bmi) + ti(age, bmi)</code></td>
<td style="text-align: left;">ANOVA decomposition</td>
<td style="text-align: left;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">Time-varying</td>
<td style="text-align: left;"><code>te(age, t)</code></td>
<td style="text-align: left;">Modifies baseline</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
</section>
<section id="the-t-symbol-time-axis-reference" class="level3">
<h3 class="anchored" data-anchor-id="the-t-symbol-time-axis-reference">The <code>t</code> Symbol: Time Axis Reference</h3>
<p>In formulas like <code>te(age, t)</code>, the symbol <code>t</code> does <strong>not</strong> refer to a data column. It references the hazard‚Äôs internal time axis:</p>
<ul>
<li>For <code>:sp</code> family: <code>t</code> uses the same B-spline basis as the baseline hazard</li>
<li>For parametric families (<code>:wei</code>, <code>:exp</code>, <code>:gom</code>): <code>te(..., t)</code> is <strong>invalid</strong></li>
</ul>
<p>This coupling ensures the time-varying effect shares the same knots and boundary conditions as the baseline.</p>
</section>
<section id="constraints-whats-not-allowed" class="level3">
<h3 class="anchored" data-anchor-id="constraints-whats-not-allowed">Constraints: What‚Äôs Not Allowed</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 43%">
<col style="width: 21%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Invalid syntax</th>
<th style="text-align: left;">Reason</th>
<th style="text-align: left;">Use instead</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>s(age) * s(bmi)</code></td>
<td style="text-align: left;">Smooth √ó smooth ambiguous</td>
<td style="text-align: left;"><code>te(age, bmi)</code> or <code>ti(age, bmi)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>te(age, t)</code> with <code>:wei</code></td>
<td style="text-align: left;">No time basis for parametric</td>
<td style="text-align: left;">Use <code>:sp</code> family</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>s(t)</code></td>
<td style="text-align: left;">Time is not a covariate</td>
<td style="text-align: left;"><code>:sp</code> family handles baseline</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>te(age, bmi, dose)</code></td>
<td style="text-align: left;">Only 2D tensors</td>
<td style="text-align: left;">Nest: <code>te(te(age, bmi), dose)</code> (future)</td>
</tr>
</tbody>
</table>
</section>
<section id="varying-coefficient-models" class="level3">
<h3 class="anchored" data-anchor-id="varying-coefficient-models">Varying Coefficient Models</h3>
<blockquote class="blockquote">
<p><strong>‚ö†Ô∏è SCOPE: DEFERRED TO FUTURE WORK</strong></p>
<p>The <code>by</code> argument for varying coefficient models is documented here for reference but is <strong>NOT included in the initial implementation scope</strong>. See <code>penalized_splines_plan.md</code> Section ‚ÄúVarying Coefficient Models ‚Äî FUTURE WORK‚Äù.</p>
</blockquote>
<p>The <code>by</code> argument would enable smooth effects that vary across levels of a factor:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FUTURE SYNTAX (NOT YET IMPLEMENTED):</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Separate age effect per treatment arm</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> <span class="fu">s</span>(age, by<span class="op">=</span>trt)), <span class="op">:</span>wei, <span class="fl">1</span>, <span class="fl">2</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Model: log h(t|x) = baseline + f_trt(age)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># where f_0(age), f_1(age) are separate smooth functions</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Penalty structure</strong> (future): Each level gets its own smooth with <strong>shared</strong> smoothing parameter (shrinks toward common shape).</p>
<hr>
</section>
</section>
<section id="extended-scope-shared-origin-tensor-product-splines" class="level2">
<h2 class="anchored" data-anchor-id="extended-scope-shared-origin-tensor-product-splines">Extended Scope: Shared-Origin Tensor Product Splines</h2>
<section id="motivation-1" class="level3">
<h3 class="anchored" data-anchor-id="motivation-1">Motivation</h3>
<p>For competing risks from state <span class="math inline">\(r\)</span>, the baseline hazards to different destinations are often related: - Similar time patterns (e.g., all hazards increase after diagnosis) - Correlated uncertainty when some destinations have sparse data - Total hazard should be smooth</p>
<p>Rather than independent splines with ad-hoc penalties, tensor products provide a principled approach.</p>
</section>
<section id="mathematical-formulation" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-formulation">Mathematical Formulation</h3>
<p>For state <span class="math inline">\(r\)</span> with destinations <span class="math inline">\(\{s_1, \ldots, s_D\}\)</span>, model: <span class="math display">\[\log h_{r,d}(t) = f_r(t, d) = \sum_{i=1}^{K_t} \sum_{j=1}^{D} \beta_{ij} B_i(t) \mathbf{1}_{d=j}\]</span></p>
<p>This is a tensor product of: 1. <strong>Time basis</strong>: <span class="math inline">\(B_1(t), \ldots, B_{K_t}(t)\)</span> (B-splines as before) 2. <strong>Destination factor</strong>: <span class="math inline">\(\mathbf{1}_{d=s_1}, \ldots, \mathbf{1}_{d=s_D}\)</span></p>
<p>Coefficient matrix <span class="math inline">\(\boldsymbol{\beta}\)</span> is <span class="math inline">\(K_t \times D\)</span>.</p>
</section>
<section id="penalty-structure-anova-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="penalty-structure-anova-decomposition">Penalty Structure (ANOVA Decomposition)</h3>
<p><strong>Penalty 1: Smoothness in time</strong> (within each destination) <span class="math display">\[\mathcal{P}_1 = \lambda_t \sum_{j=1}^{D} \boldsymbol{\beta}_{\cdot j}^T S_t \boldsymbol{\beta}_{\cdot j} = \lambda_t \text{tr}(\boldsymbol{\beta}^T S_t \boldsymbol{\beta})\]</span></p>
<p><strong>Penalty 2: Shrinkage across destinations</strong> (at each time point) <span class="math display">\[\mathcal{P}_2 = \lambda_d \sum_{i=1}^{K_t} \boldsymbol{\beta}_{i \cdot}^T S_d \boldsymbol{\beta}_{i \cdot}\]</span></p>
<p>where <span class="math inline">\(S_d\)</span> is a penalty on destination dimension: - <strong>Ridge</strong> (default): <span class="math inline">\(S_d = I_D\)</span> ‚Äî shrink destinations toward each other - <strong>First difference</strong>: <span class="math inline">\(S_d = D_1^T D_1\)</span> ‚Äî adjacent destinations similar (if ordered) - <strong>Graph Laplacian</strong>: <span class="math inline">\(S_d = L\)</span> ‚Äî destinations connected by clinical similarity</p>
<p><strong>Combined penalty (vectorized)</strong>: <span class="math display">\[\mathcal{P}(\boldsymbol{\beta}) = \lambda_t \boldsymbol{\beta}^T (I_D \otimes S_t) \boldsymbol{\beta} + \lambda_d \boldsymbol{\beta}^T (S_d \otimes I_{K_t}) \boldsymbol{\beta}\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\beta} = \text{vec}(B)\)</span> is column-vectorized.</p>
</section>
<section id="advantages-over-total-hazard-penalty" class="level3">
<h3 class="anchored" data-anchor-id="advantages-over-total-hazard-penalty">Advantages Over Total Hazard Penalty</h3>
<p>The original plan used: <span class="math display">\[\mathcal{P}_{total} = \mu_r \left(\sum_s \theta_{rs}\right)^T S_r \left(\sum_s \theta_{rs}\right)\]</span></p>
<p>which penalizes the <strong>sum</strong> of log-hazards.</p>
<p>The tensor product penalty instead: - Shrinks destinations <strong>toward each other</strong> (not toward their sum) - Has cleaner probabilistic interpretation (random effects on destinations) - More flexible (can specify structure on destination dimension) - Borrows strength from data-rich transitions to sparse ones</p>
<p><strong>Recommendation</strong>: Replace total hazard penalty with tensor products for shared-origin states.</p>
</section>
<section id="design-decisions" class="level3">
<h3 class="anchored" data-anchor-id="design-decisions">Design Decisions</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 25%">
<col style="width: 45%">
</colgroup>
<thead>
<tr class="header">
<th>Decision</th>
<th>Options</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Destination penalty <span class="math inline">\(S_d\)</span></td>
<td>Ridge, Difference, Custom</td>
<td>Ridge (default), user-configurable</td>
</tr>
<tr class="even">
<td>Shared <span class="math inline">\(\lambda_t\)</span> across destinations</td>
<td>Yes / No</td>
<td>Yes (tensor structure implies sharing)</td>
</tr>
<tr class="odd">
<td>Number of <span class="math inline">\(\lambda\)</span> parameters</td>
<td>2 or more</td>
<td>Start with 2 (<span class="math inline">\(\lambda_t\)</span>, <span class="math inline">\(\lambda_d\)</span>)</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="extended-scope-general-tensor-product-splines" class="level2">
<h2 class="anchored" data-anchor-id="extended-scope-general-tensor-product-splines">Extended Scope: General Tensor Product Splines</h2>
<section id="use-cases" class="level3">
<h3 class="anchored" data-anchor-id="use-cases">Use Cases</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 29%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Use Case</th>
<th>Syntax</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Time-varying effect</td>
<td><code>te(age, t)</code></td>
<td>Effect of age changes over follow-up</td>
</tr>
<tr class="even">
<td>Spatial effects</td>
<td><code>te(lat, lon)</code></td>
<td>Geographic variation</td>
</tr>
<tr class="odd">
<td>Pure interaction</td>
<td><code>ti(age, bmi)</code></td>
<td>Interaction excluding main effects</td>
</tr>
</tbody>
</table>
</section>
<section id="implementation-structs" class="level3">
<h3 class="anchored" data-anchor-id="implementation-structs">Implementation Structs</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Formula-level term for te() and ti()</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TensorTerm <span class="op">&lt;:</span><span class="dt"> StatsModels.AbstractTerm</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    vars<span class="op">::</span><span class="dt">Tuple{Symbol, Symbol}</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    k<span class="op">::</span><span class="dt">Tuple{Int, Int}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    penalty_order<span class="op">::</span><span class="dt">Int            </span><span class="co"># Derivative order for penalty (default 2)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    monotone<span class="op">::</span><span class="dt">Tuple{Bool, Bool}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    increasing<span class="op">::</span><span class="dt">Tuple{Bool, Bool}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    interaction_only<span class="op">::</span><span class="dt">Bool  </span><span class="co"># true for ti(), false for te()</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Helper constructors (for reference - actual construction via apply_schema)</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="fu">te</span>(v1<span class="op">::</span><span class="dt">Symbol</span>, v2<span class="op">::</span><span class="dt">Symbol</span>; k<span class="op">=</span>(<span class="fl">10</span>, <span class="fl">10</span>), penalty_order<span class="op">=</span><span class="fl">2</span>, monotone<span class="op">=</span>(<span class="cn">false</span>, <span class="cn">false</span>)) <span class="op">=</span> </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">TensorTerm</span>((v1, v2), k, penalty_order, monotone, (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">false</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="fu">ti</span>(v1<span class="op">::</span><span class="dt">Symbol</span>, v2<span class="op">::</span><span class="dt">Symbol</span>; k<span class="op">=</span>(<span class="fl">10</span>, <span class="fl">10</span>), penalty_order<span class="op">=</span><span class="fl">2</span>) <span class="op">=</span> </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">TensorTerm</span>((v1, v2), k, penalty_order, (<span class="cn">false</span>, <span class="cn">false</span>), (<span class="cn">true</span>, <span class="cn">true</span>), <span class="cn">true</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="basis-construction" class="level3">
<h3 class="anchored" data-anchor-id="basis-construction">Basis Construction</h3>
<p>For <code>te(x1, x2)</code>: <span class="math display">\[f(x_1, x_2) = \sum_{i,j} \beta_{ij} B_{1i}(x_1) B_{2j}(x_2)\]</span></p>
<p><strong>Efficient evaluation</strong> (avoid full Kronecker product):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">eval_tensor_term</span>(beta_mat, B1_vals, B2_vals)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># O(n * k1 * k2) instead of O(n * k1¬≤ * k2¬≤)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">sum</span>((B1_vals <span class="op">*</span> beta_mat) <span class="op">.*</span> B2_vals, dims<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="penalty-structure" class="level3">
<h3 class="anchored" data-anchor-id="penalty-structure">Penalty Structure</h3>
<p>Marginal penalties from Wood (2016): - <span class="math inline">\(S_1 = D_1^T D_1 \otimes I_{k_2}\)</span>: Roughness in <span class="math inline">\(x_1\)</span> - <span class="math inline">\(S_2 = I_{k_1} \otimes D_2^T D_2\)</span>: Roughness in <span class="math inline">\(x_2\)</span></p>
<p><strong>Efficient penalty application</strong> (no full matrix formation):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">apply_penalty</span>(beta_vec, D1, D2, Œª<span class="fl">1</span>, Œª<span class="fl">2</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    beta_mat <span class="op">=</span> <span class="fu">reshape</span>(beta_vec, k1, k2)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    S1_beta <span class="op">=</span> <span class="fu">vec</span>(D1<span class="op">'</span> <span class="op">*</span> (D1 <span class="op">*</span> beta_mat))       <span class="co"># S1 penalty</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    S2_beta <span class="op">=</span> <span class="fu">vec</span>(beta_mat <span class="op">*</span> (D2<span class="op">'</span> <span class="op">*</span> D2))       <span class="co"># S2 penalty</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Œª<span class="fl">1</span> <span class="op">*</span> S1_beta <span class="op">+</span> Œª<span class="fl">2</span> <span class="op">*</span> S2_beta</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-ti-reparametrization-pure-interaction" class="level3">
<h3 class="anchored" data-anchor-id="the-ti-reparametrization-pure-interaction">The ti() Reparametrization: Pure Interaction</h3>
<p>The <code>ti()</code> term (tensor interaction) represents <strong>pure interaction</strong> that excludes main effects. This is essential for ANOVA-style decompositions:</p>
<p><span class="math display">\[f(x_1, x_2) = f_1(x_1) + f_2(x_2) + f_{12}(x_1, x_2)\]</span></p>
<p>where <code>s(x1) + s(x2) + ti(x1, x2)</code> models the three components.</p>
<section id="constraint-mechanism" class="level4">
<h4 class="anchored" data-anchor-id="constraint-mechanism">Constraint Mechanism</h4>
<p>For <code>ti()</code> to represent pure interaction, it must satisfy <strong>centered constraints</strong>: <span class="math display">\[\sum_i f_{12}(x_{1i}, x_2) = 0 \quad \forall x_2\]</span> <span class="math display">\[\sum_j f_{12}(x_1, x_{2j}) = 0 \quad \forall x_1\]</span></p>
<p>This is achieved via <strong>basis reparametrization</strong> using Helmert-style contrasts (Wood, 2017 ¬ß5.6.3):</p>
<ol type="1">
<li>Build sum-to-zero contrast matrix <span class="math inline">\(C_1\)</span> (<span class="math inline">\(k_1 \times (k_1-1)\)</span>) for dimension 1</li>
<li>Build sum-to-zero contrast matrix <span class="math inline">\(C_2\)</span> (<span class="math inline">\(k_2 \times (k_2-1)\)</span>) for dimension 2</li>
<li>Center each marginal basis: <span class="math inline">\(B_1^c = B_1 C_1\)</span>, <span class="math inline">\(B_2^c = B_2 C_2\)</span></li>
<li>Form interaction basis: row-wise Kronecker of centered bases</li>
<li>Result: <span class="math inline">\(n \times (k_1-1)(k_2-1)\)</span> basis satisfying constraints</li>
</ol>
</section>
<section id="implementation" class="level4">
<h4 class="anchored" data-anchor-id="implementation">Implementation</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="st">Build sum-to-zero contrast matrix using Helmert-style contrasts.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="st">Returns: k √ó (k-1) matrix where each column sums to zero.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_sum_to_zero_contrast</span>(k<span class="op">::</span><span class="dt">Int</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returns k √ó (k-1) orthonormal matrix where each column sums to zero</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Based on Helmert contrasts, then orthonormalized via QR for numerical stability</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (QR preserves column space, so sum-to-zero property is maintained)</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, k, k<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>(k<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        C[j, j] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        C[j<span class="op">+</span><span class="fl">1</span><span class="op">:</span>k, j] <span class="op">.=</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">/</span> (k <span class="op">-</span> j)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Orthonormalize: QR preserves the property that columns span sum-to-zero subspace</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">Matrix</span>(<span class="fu">qr</span>(C).Q)[<span class="op">:</span>, <span class="fl">1</span><span class="op">:</span>(k<span class="op">-</span><span class="fl">1</span>)]</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="st">Build the centered interaction basis for ti() terms.</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="st">Returns: n √ó ((k1-1)*(k2-1)) constrained interaction basis.</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_ti_basis</span>(B1<span class="op">::</span><span class="dt">Matrix{Float64}</span>, B2<span class="op">::</span><span class="dt">Matrix{Float64}</span>)</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="fu">size</span>(B1, <span class="fl">1</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> <span class="fu">size</span>(B1, <span class="fl">2</span>), <span class="fu">size</span>(B2, <span class="fl">2</span>)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get contrast matrices</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k1)  <span class="co"># k1 √ó (k1-1)</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k2)  <span class="co"># k2 √ó (k2-1)</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Centered marginal bases</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    B1_c <span class="op">=</span> B1 <span class="op">*</span> C1  <span class="co"># n √ó (k1-1)</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    B2_c <span class="op">=</span> B2 <span class="op">*</span> C2  <span class="co"># n √ó (k2-1)</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Row-wise Kronecker product for interaction</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Result: n √ó ((k1-1)*(k2-1))</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    p_new <span class="op">=</span> (k1<span class="op">-</span><span class="fl">1</span>) <span class="op">*</span> (k2<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    B_ti <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, n, p_new)</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>        B_ti[i, <span class="op">:</span>] <span class="op">=</span> <span class="fu">kron</span>(B1_c[i, <span class="op">:</span>], B2_c[i, <span class="op">:</span>])</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B_ti</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a><span class="st">Penalty matrix for ti() term in the reduced parameterization.</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">build_ti_penalty</span>(S1<span class="op">::</span><span class="dt">Matrix{Float64}</span>, S2<span class="op">::</span><span class="dt">Matrix{Float64}</span>, </span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>                          k1<span class="op">::</span><span class="dt">Int</span>, k2<span class="op">::</span><span class="dt">Int</span>, Œª<span class="fl">1</span><span class="op">::</span><span class="dt">Real</span>, Œª<span class="fl">2</span><span class="op">::</span><span class="dt">Real</span>)</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    C1 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k1)</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    C2 <span class="op">=</span> <span class="fu">build_sum_to_zero_contrast</span>(k2)</span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Transform penalties: C' S C</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    S1_ti <span class="op">=</span> C1<span class="op">'</span> <span class="op">*</span> S1 <span class="op">*</span> C1  <span class="co"># (k1-1) √ó (k1-1)</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>    S2_ti <span class="op">=</span> C2<span class="op">'</span> <span class="op">*</span> S2 <span class="op">*</span> C2  <span class="co"># (k2-1) √ó (k2-1)</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Kronecker structure on reduced space</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>    I1 <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{Float64}</span>(I, k1<span class="op">-</span><span class="fl">1</span>, k1<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    I2 <span class="op">=</span> <span class="fu">Matrix</span><span class="dt">{Float64}</span>(I, k2<span class="op">-</span><span class="fl">1</span>, k2<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    S_ti <span class="op">=</span> Œª<span class="fl">1</span> <span class="op">*</span> <span class="fu">kron</span>(I2, S1_ti) <span class="op">+</span> Œª<span class="fl">2</span> <span class="op">*</span> <span class="fu">kron</span>(S2_ti, I1)</span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S_ti</span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="why-reparametrize-rather-than-constrain" class="level4">
<h4 class="anchored" data-anchor-id="why-reparametrize-rather-than-constrain">Why Reparametrize Rather Than Constrain?</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 27%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Soft constraint</strong> (penalty)</td>
<td>Simple implementation</td>
<td>Doesn‚Äôt exactly enforce</td>
</tr>
<tr class="even">
<td><strong>Hard constraint</strong> (Lagrange)</td>
<td>Exact</td>
<td>Complicated optimization</td>
</tr>
<tr class="odd">
<td><strong>Reparametrization</strong></td>
<td>Exact + unconstrained optimization</td>
<td>Reduced basis dimension</td>
</tr>
</tbody>
</table>
<p>We use <strong>reparametrization</strong> because: 1. Optimization stays unconstrained (no Lagrange multipliers) 2. Constraints are exactly satisfied by construction 3. Basis dimension matches degrees of freedom: <span class="math inline">\((K_1-1) \times (K_2-1)\)</span></p>
<hr>
</section>
</section>
</section>
<section id="monotone-tensor-products" class="level2">
<h2 class="anchored" data-anchor-id="monotone-tensor-products">Monotone Tensor Products</h2>
<section id="motivation-2" class="level3">
<h3 class="anchored" data-anchor-id="motivation-2">Motivation</h3>
<p>In survival analysis, shape constraints are often substantively motivated: - <strong>Monotone in time</strong>: Hazards that increase or decrease over follow-up (e.g., post-transplant mortality) - <strong>Monotone in covariate</strong>: Risk that increases with biomarker level - <strong>Mixed</strong>: Monotone in one dimension but flexible in another</p>
<p>Tensor products allow <strong>per-dimension monotonicity</strong>, unlike univariate splines where combining monotonicity with penalization creates conflicts.</p>
</section>
<section id="i-spline-basis-via-cumulative-differencing" class="level3">
<h3 class="anchored" data-anchor-id="i-spline-basis-via-cumulative-differencing">I-Spline Basis via Cumulative Differencing</h3>
<p>The existing <code>spline_ests2coefs()</code> in <code>spline.jl</code> implements I-spline transformation via cumulative differencing:</p>
<p><span class="math display">\[\text{coef}_i = \text{coef}_{i-1} + \exp(\tilde{\beta}_i) \cdot \frac{t_{i+k} - t_i}{k}\]</span></p>
<p>where: - <span class="math inline">\(\tilde{\beta}_i\)</span> is the estimation-scale parameter (unconstrained) - <span class="math inline">\(\exp(\tilde{\beta}_i)\)</span> ensures non-negative increments - <span class="math inline">\((t_{i+k} - t_i)/k\)</span> is the knot-spacing weight for proper I-spline integration - <span class="math inline">\(k\)</span> is the spline order</p>
<p>This guarantees monotonicity through cumulative sums of non-negative quantities.</p>
</section>
<section id="tensor-product-with-partial-monotonicity" class="level3">
<h3 class="anchored" data-anchor-id="tensor-product-with-partial-monotonicity">Tensor Product with Partial Monotonicity</h3>
<p>For <code>te(x1, x2, monotone=(false, true))</code>: - <span class="math inline">\(x_1\)</span>: Standard B-spline basis <span class="math inline">\(B_1(x_1)\)</span> with unconstrained coefficients - <span class="math inline">\(x_2\)</span>: I-spline transformation applied along columns of coefficient matrix</p>
<p>The transformation operates on the coefficient matrix <span class="math inline">\(\tilde{B}\)</span> (estimation scale):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For tensor product with monotonicity in dimension 2 (columns)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">ests_to_coefs_tensor_monotone_dim2</span>(ests_mat, knots2, order2)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    k1, k2 <span class="op">=</span> <span class="fu">size</span>(ests_mat)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    coefs_mat <span class="op">=</span> <span class="fu">similar</span>(ests_mat)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>k1</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply cumulative I-spline transform to each row</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        coefs_mat[i, <span class="fl">1</span>] <span class="op">=</span> <span class="fu">exp</span>(ests_mat[i, <span class="fl">1</span>])  <span class="co"># Intercept</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>k2</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            coefs_mat[i, j] <span class="op">=</span> coefs_mat[i, j<span class="op">-</span><span class="fl">1</span>] <span class="op">+</span> </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                <span class="fu">exp</span>(ests_mat[i, j]) <span class="op">*</span> (knots2[j <span class="op">+</span> order2] <span class="op">-</span> knots2[j]) <span class="op">/</span> order2</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coefs_mat</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="penalty-structure-for-monotone-dimensions" class="level3">
<h3 class="anchored" data-anchor-id="penalty-structure-for-monotone-dimensions">Penalty Structure for Monotone Dimensions</h3>
<p><strong>Key insight</strong>: Penalization operates on the <strong>estimation-scale parameters</strong> <span class="math inline">\(\tilde{\beta}\)</span>, not the transformed coefficients.</p>
<p>For monotone dimension with I-splines: 1. Coefficients stored as <span class="math inline">\(\tilde{\beta}\)</span> (log-scale, unconstrained) 2. Forward pass applies cumulative sum: <span class="math inline">\(\beta = \text{cumsum}(\exp(\tilde{\beta}) \cdot w)\)</span> 3. Penalty matrix applied to <span class="math inline">\(\tilde{\beta}\)</span> directly</p>
<p>This induces shrinkage toward <strong>constant (flat)</strong> monotone surfaces, not toward zero.</p>
<p><strong>Penalty formulation</strong>: <span class="math display">\[\text{Penalty} = \lambda_1 \tilde{\beta}^T S_1 \tilde{\beta} + \lambda_2 \tilde{\beta}^T S_2 \tilde{\beta}\]</span></p>
<p>where <span class="math inline">\(S_2\)</span> (monotone dimension) penalizes roughness in the estimation-scale parameters.</p>
</section>
<section id="implementation-details" class="level3">
<h3 class="anchored" data-anchor-id="implementation-details">Implementation Details</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MonotoneTensorConfig</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    monotone<span class="op">::</span><span class="dt">Tuple{Bool, Bool}  </span><span class="co"># (dim1_monotone, dim2_monotone)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    increasing<span class="op">::</span><span class="dt">Tuple{Bool, Bool}  </span><span class="co"># Direction (true=increasing)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">transform_tensor_coefficients</span>(ests_mat, knots1, knots2, order1, order2, config)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    coefs_mat <span class="op">=</span> <span class="fu">copy</span>(ests_mat)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply cumulative I-spline transform along monotone dimensions</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> config.monotone[<span class="fl">1</span>]</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="fu">axes</span>(coefs_mat, <span class="fl">2</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>            coefs_mat[<span class="op">:</span>, j] <span class="op">=</span> <span class="fu">cumulative_ispline_transform</span>(</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>                coefs_mat[<span class="op">:</span>, j], knots1, order1, config.increasing[<span class="fl">1</span>]</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> config.monotone[<span class="fl">2</span>]</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="fu">axes</span>(coefs_mat, <span class="fl">1</span>)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>            coefs_mat[i, <span class="op">:</span>] <span class="op">=</span> <span class="fu">cumulative_ispline_transform</span>(</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>                coefs_mat[i, <span class="op">:</span>], knots2, order2, config.increasing[<span class="fl">2</span>]</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> coefs_mat</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">cumulative_ispline_transform</span>(ests, knots, order, increasing)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    coefs <span class="op">=</span> <span class="fu">similar</span>(ests)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    coefs[<span class="fl">1</span>] <span class="op">=</span> <span class="fu">exp</span>(ests[<span class="fl">1</span>])</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span><span class="fu">length</span>(coefs)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        coefs[i] <span class="op">=</span> coefs[i<span class="op">-</span><span class="fl">1</span>] <span class="op">+</span> <span class="fu">exp</span>(ests[i]) <span class="op">*</span> (knots[i <span class="op">+</span> order] <span class="op">-</span> knots[i]) <span class="op">/</span> order</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> increasing ? coefs <span class="op">:</span> <span class="fu">reverse</span>(coefs)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="shared-origin-tensor-products-with-monotonicity" class="level3">
<h3 class="anchored" data-anchor-id="shared-origin-tensor-products-with-monotonicity">Shared-Origin Tensor Products with Monotonicity</h3>
<p>For competing risks with monotone temporal baseline:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> <span class="fu">multistatemodel</span>(h12, h13, h14;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    shared_origin_tensor <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="fl">1</span> <span class="op">=&gt;</span> <span class="fu">SharedOriginConfig</span>(monotone_time<span class="op">=</span><span class="cn">true</span>, increasing<span class="op">=</span><span class="cn">true</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This specifies: - Shared time basis across destinations with I-spline transformation - Destination effects via ridge-penalized coefficients - Hazards guaranteed to be monotonically increasing over follow-up</p>
<p><strong>Use case</strong>: Immediate post-operative period where all-cause mortality decreases over time.</p>
<hr>
</section>
</section>
<section id="implementation-roadmap-revised" class="level2">
<h2 class="anchored" data-anchor-id="implementation-roadmap-revised">Implementation Roadmap (Revised)</h2>
<section id="phase-0-infrastructure-preparation" class="level3">
<h3 class="anchored" data-anchor-id="phase-0-infrastructure-preparation">Phase 0: Infrastructure Preparation</h3>
<ul class="task-list">
<li><label><input type="checkbox">Add penalty constants to <code>constants.jl</code></label></li>
<li><label><input type="checkbox">Create <code>PenaltyConfig</code> struct (model-level)</label></li>
<li><label><input type="checkbox">Update error handling (<code>ArgumentError</code> convention)</label></li>
</ul>
</section>
<section id="phase-1-penalty-matrix-construction" class="level3">
<h3 class="anchored" data-anchor-id="phase-1-penalty-matrix-construction">Phase 1: Penalty Matrix Construction</h3>
<ul class="task-list">
<li><label><input type="checkbox"><code>compute_derivative_penalty_matrix(basis, order)</code> ‚Äî Wood‚Äôs algorithm</label></li>
<li><label><input type="checkbox">Handle <code>RecombinedBSplineBasis</code> transformation</label></li>
<li><label><input type="checkbox">Test banding structure</label></li>
<li><label><input type="checkbox">Verify against R‚Äôs <code>mgcv::smoothCon</code></label></li>
</ul>
</section>
<section id="phase-2-penalized-likelihood" class="level3">
<h3 class="anchored" data-anchor-id="phase-2-penalized-likelihood">Phase 2: Penalized Likelihood</h3>
<ul class="task-list">
<li><label><input type="checkbox"><code>penalized_loglik</code> wrapper</label></li>
<li><label><input type="checkbox">Individual transition penalties</label></li>
<li><label><input type="checkbox">Shared-origin tensor penalties</label></li>
<li><label><input type="checkbox">ForwardDiff compatibility</label></li>
</ul>
</section>
<section id="phase-3-smoothing-parameter-selection" class="level3">
<h3 class="anchored" data-anchor-id="phase-3-smoothing-parameter-selection">Phase 3: Smoothing Parameter Selection</h3>
<ul class="task-list">
<li><label><input type="checkbox"><code>compute_ncv_criterion(state, model, data)</code> ‚Äî evaluate deviance at LOO parameters</label></li>
<li><label><input type="checkbox">Multi-Œª optimization for tensor products (BFGS on log scale)</label></li>
<li><label><input type="checkbox">REML (secondary benchmark, may defer)</label></li>
<li><label><input type="checkbox">AIC/BIC with effective degrees of freedom</label></li>
<li><label><input type="checkbox">Subject weights support</label></li>
<li><label><input type="checkbox">Indefinite Hessian fallback</label></li>
</ul>
</section>
<section id="phase-4-confidence-intervals" class="level3">
<h3 class="anchored" data-anchor-id="phase-4-confidence-intervals">Phase 4: Confidence Intervals</h3>
<ul class="task-list">
<li><label><input type="checkbox">Bayesian posterior CIs</label></li>
<li><label><input type="checkbox">Simulation-based CIs for functions</label></li>
<li><label><input type="checkbox">Integration with <code>predict</code> interface</label></li>
</ul>
</section>
<section id="phase-5-covariate-splines" class="level3">
<h3 class="anchored" data-anchor-id="phase-5-covariate-splines">Phase 5: Covariate Splines</h3>
<ul class="task-list">
<li><label><input type="checkbox"><code>SmoothTerm &lt;: StatsModels.AbstractTerm</code> struct for <code>s()</code> syntax</label></li>
<li><label><input type="checkbox">Formula parsing via term interception</label></li>
<li><label><input type="checkbox">Basis construction from data quantiles</label></li>
<li><label><input type="checkbox">Identifiability constraints (sum-to-zero centering)</label></li>
</ul>
</section>
<section id="phase-6-tensor-product-infrastructure" class="level3">
<h3 class="anchored" data-anchor-id="phase-6-tensor-product-infrastructure">Phase 6: Tensor Product Infrastructure</h3>
<ul class="task-list">
<li><label><input type="checkbox"><code>SharedOriginConfig</code> and <code>SharedOriginTensorConfig</code> structs</label></li>
<li><label><input type="checkbox"><code>TensorTerm &lt;: StatsModels.AbstractTerm</code> for <code>te()</code> and <code>ti()</code></label></li>
<li><label><input type="checkbox">Destination penalty matrices (:ridge, :difference, custom)</label></li>
<li><label><input type="checkbox">Kronecker-efficient penalty application</label></li>
<li><label><input type="checkbox">Partial domain handling</label></li>
<li><label><input type="checkbox">Model construction integration for <code>shared_origin_tensor</code> kwarg</label></li>
</ul>
</section>
<section id="phase-7-testing-documentation" class="level3">
<h3 class="anchored" data-anchor-id="phase-7-testing-documentation">Phase 7: Testing &amp; Documentation</h3>
<ul class="task-list">
<li><label><input type="checkbox">Unit tests for penalty matrices (verify against R mgcv)</label></li>
<li><label><input type="checkbox">RecombinedBSplineBasis penalty transformation tests</label></li>
<li><label><input type="checkbox">Coverage simulation studies</label></li>
<li><label><input type="checkbox">Shared-origin tensor tests</label></li>
<li><label><input type="checkbox">R/flexsurv/flexmsm comparison benchmarks</label></li>
</ul>
<p><strong>Estimated timeline: 35-42 days</strong></p>
<hr>
</section>
</section>
<section id="compatibility-notes" class="level2">
<h2 class="anchored" data-anchor-id="compatibility-notes">Compatibility Notes</h2>
<section id="mcem-semi-markov-models-deferred" class="level3">
<h3 class="anchored" data-anchor-id="mcem-semi-markov-models-deferred">MCEM / Semi-Markov Models (Deferred)</h3>
<p>Penalization with MCEM-fitted semi-Markov models presents challenges:</p>
<ol type="1">
<li><strong>Stochastic gradients</strong>: MCEM uses importance-weighted gradient estimates, not exact gradients</li>
<li><strong>Hessian estimation</strong>: The penalized Hessian <span class="math inline">\(H_\lambda\)</span> includes the (constant) penalty term, but the likelihood Hessian is stochastic</li>
<li><strong>NCV computation</strong>: Leave-one-out parameter perturbations rely on exact subject-level contributions</li>
</ol>
<p><strong>Potential approach</strong> (future work): - Use converged MCEM Hessian estimate for penalty selection - Require convergence diagnostics before smoothing selection - Consider REML as alternative (less sensitive to gradient noise)</p>
<p><strong>Initial scope</strong>: Markov models and exact-observation semi-Markov models only.</p>
</section>
<section id="constrained-optimization" class="level3">
<h3 class="anchored" data-anchor-id="constrained-optimization">Constrained Optimization</h3>
<p>When penalties are combined with parameter constraints (e.g., monotone 1D splines, positivity), the optimization becomes: <span class="math display">\[\min_\theta -\ell_p(\theta; \lambda) \quad \text{subject to } g(\theta) \leq 0\]</span></p>
<p>This requires constrained trust region methods, which are more complex than unconstrained penalized optimization.</p>
<p><strong>Initial scope</strong>: Penalization available only for unconstrained problems. Monotonicity via tensor products (per-dimension) rather than 1D constrained splines.</p>
<hr>
</section>
</section>
<section id="resolved-design-questions" class="level2">
<h2 class="anchored" data-anchor-id="resolved-design-questions">Resolved Design Questions</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Question</th>
<th style="text-align: left;">Resolution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Total vs individual penalty</td>
<td style="text-align: left;">Replace with shared-origin tensor products</td>
</tr>
<tr class="even">
<td style="text-align: left;">Shared smoothing parameters</td>
<td style="text-align: left;">Via tensor product structure</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Penalty storage location</td>
<td style="text-align: left;"><code>PenaltyConfig</code> stored in <code>ConvergenceRecords</code> NamedTuple (R8-1, R8-4, R9-4)</td>
</tr>
<tr class="even">
<td style="text-align: left;">PIJCVState usage</td>
<td style="text-align: left;">Use existing <code>pijcv_criterion()</code> for NCV; provide appropriate loss_fn (R8-13)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RecombinedBSplineBasis</td>
<td style="text-align: left;">Transform penalty: <span class="math inline">\(S_{recombined} = R^T S_{original} R\)</span> (R is rectangular)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><span class="math inline">\(\log\lambda_0 = -3 - \log\|S\|_F\)</span> (heuristic, should validate)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Smoothing param bounds</td>
<td style="text-align: left;">Log scale: <span class="math inline">\([-20, 20]\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Monotone + penalization (1D)</td>
<td style="text-align: left;">Disallow (conflicting objectives)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Monotone tensor products</td>
<td style="text-align: left;">Supported via cumulative I-spline transformation per dimension</td>
</tr>
<tr class="even">
<td style="text-align: left;">MCEM compatibility</td>
<td style="text-align: left;">Deferred; initial scope is Markov + exact data</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Absorbing states</td>
<td style="text-align: left;">Treat same as other destinations in shared-origin tensors</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>apply_schema</code> signature</td>
<td style="text-align: left;">Must use <code>schema::StatsModels.Schema</code> (R9-1)</td>
</tr>
</tbody>
</table>
<hr>
</section>
<section id="appendix-a-detailed-paper-summaries" class="level2">
<h2 class="anchored" data-anchor-id="appendix-a-detailed-paper-summaries">Appendix A: Detailed Paper Summaries</h2>
<section id="a.1-machado-van-den-hout-marra-2018" class="level3">
<h3 class="anchored" data-anchor-id="a.1-machado-van-den-hout-marra-2018">A.1 Machado, van den Hout &amp; Marra (2018)</h3>
<p><strong>‚ÄúPenalised maximum likelihood estimation in multistate models for interval-censored data‚Äù</strong></p>
<p><strong>Context:</strong> Frequentist penalized maximum likelihood for multistate models with interval-censored transition times.</p>
<section id="hazard-representation" class="level4">
<h4 class="anchored" data-anchor-id="hazard-representation">Hazard Representation</h4>
<p>The baseline hazard for transition <span class="math inline">\(r \to s\)</span> is modeled using B-splines on the log scale:</p>
<p><span class="math display">\[q_{rs,0}(t) = \exp\left(\sum_{k=1}^{K_{rs}} \alpha_{rs,k} B_k(t)\right)\]</span></p>
<p>where <span class="math inline">\(B_k(t)\)</span> are cubic regression spline basis functions and <span class="math inline">\(\alpha_{rs,k}\)</span> are coefficients to be estimated.</p>
</section>
<section id="penalty-structure-1" class="level4">
<h4 class="anchored" data-anchor-id="penalty-structure-1">Penalty Structure</h4>
<p>Each transition hazard has its own quadratic penalty:</p>
<p><span class="math display">\[\lambda_{rs} \alpha_{rs}^T S_{rs} \alpha_{rs}\]</span></p>
<p>where <span class="math inline">\(S_{rs}\)</span> is the penalty matrix (integrated squared second derivative). The full penalty matrix <span class="math inline">\(S_\lambda\)</span> is <strong>block-diagonal</strong> with blocks <span class="math inline">\(\lambda_{rs} S_{rs}\)</span> for each transition and zeros elsewhere.</p>
</section>
<section id="penalized-log-likelihood" class="level4">
<h4 class="anchored" data-anchor-id="penalized-log-likelihood">Penalized Log-Likelihood</h4>
<p><span class="math display">\[\ell_p(\theta) = \ell(\theta) - \frac{1}{2} \theta^T S_\lambda \theta\]</span></p>
</section>
<section id="smoothing-parameter-selection" class="level4">
<h4 class="anchored" data-anchor-id="smoothing-parameter-selection">Smoothing Parameter Selection</h4>
<p>They use <strong>UBRE</strong> (Unbiased Risk Estimator):</p>
<p><span class="math display">\[V(\lambda) = \|z - A_\lambda z\|^2 - c + 2\text{tr}(A_\lambda)\]</span></p>
<p>where <span class="math inline">\(A_\lambda = \sqrt{I}(I + S_\lambda)^{-1}\sqrt{I}\)</span> is the ‚Äúhat‚Äù matrix. This is minimized using a general-purpose optimizer.</p>
</section>
<section id="estimation-algorithm-two-step-iteration" class="level4">
<h4 class="anchored" data-anchor-id="estimation-algorithm-two-step-iteration">Estimation Algorithm (Two-Step Iteration)</h4>
<ol type="1">
<li><p><strong>Step 1:</strong> For fixed <span class="math inline">\(\lambda\)</span>, update <span class="math inline">\(\theta\)</span> using Newton-type scoring: <span class="math display">\[\theta^{[a+1]} = (I^{[a]} + S_{\hat{\lambda}})^{-1} \sqrt{I^{[a]}} z^{[a]}\]</span> where <span class="math inline">\(z^{[a]} = \sqrt{I^{[a]}} \theta^{[a]} + \epsilon^{[a]}\)</span></p></li>
<li><p><strong>Step 2:</strong> Given <span class="math inline">\(\theta\)</span>, update <span class="math inline">\(\lambda\)</span> by minimizing UBRE.</p></li>
<li><p>Iterate until convergence: <span class="math inline">\(\max|\theta^{[a+1]} - \theta^{[a]}| &lt; \delta\)</span></p></li>
</ol>
</section>
<section id="fisher-information-approximation" class="level4">
<h4 class="anchored" data-anchor-id="fisher-information-approximation">Fisher Information Approximation</h4>
<p>They use an <strong>approximation</strong> to the Fisher information matrix that only requires <strong>first-order derivatives</strong> of the log-likelihood. This is because computing second derivatives of transition probabilities is intractable via their approach.</p>
</section>
<section id="confidence-intervals" class="level4">
<h4 class="anchored" data-anchor-id="confidence-intervals">Confidence Intervals</h4>
<p>Use the Bayesian posterior approximation <span class="math inline">\(\hat{\theta} \sim N(\theta, V_\theta)\)</span> where <span class="math inline">\(V_\theta\)</span> is the inverse of the penalized information matrix. For nonlinear functions (hazards, transition probabilities): 1. Draw <span class="math inline">\(n\)</span> samples from <span class="math inline">\(N(\hat{\theta}, V_\theta)\)</span> 2. Evaluate the function at each sample 3. Take quantiles for confidence intervals</p>
</section>
<section id="limitations" class="level4">
<h4 class="anchored" data-anchor-id="limitations">Limitations</h4>
<ul>
<li>Uses approximate Fisher information (1st derivatives only)</li>
<li>UBRE assumes independent residuals ‚Üí undersmoothing with correlated data</li>
<li>No support for tensor products or time-varying effects</li>
</ul>
<hr>
</section>
</section>
<section id="a.2-eletti-marra-radice-2024" class="level3">
<h3 class="anchored" data-anchor-id="a.2-eletti-marra-radice-2024">A.2 Eletti, Marra &amp; Radice (2024)</h3>
<p><strong>‚ÄúSpline-Based Multi-State Models for Analyzing Disease Progression‚Äù</strong> (R package <code>flexmsm</code>)</p>
<p><strong>Context:</strong> Frequentist penalized maximum likelihood with <strong>exact analytical Hessian</strong> for general multistate models.</p>
<section id="hazard-representation-1" class="level4">
<h4 class="anchored" data-anchor-id="hazard-representation-1">Hazard Representation</h4>
<p>Additive predictor framework:</p>
<p><span class="math display">\[q^{(rr')}(t_\iota) = \exp\left(\eta_\iota^{(rr')}(t_\iota, x_\iota; \beta^{(rr')})\right)\]</span></p>
<p>where the additive predictor can include: - Overall intercept <span class="math inline">\(\beta_0^{(rr')}\)</span> - Smooth functions of time <span class="math inline">\(s_k(t)\)</span> - Parametric covariate effects - <strong>Tensor product interactions</strong> (e.g., time-varying effects <span class="math inline">\(s_k(\text{age}, t)\)</span>)</p>
<p>Each smooth term is represented as: <span class="math display">\[s_k^{(rr')}(\tilde{x}_{k\iota}) = b_k^{(rr')}(\tilde{x}_{k\iota})^T \beta_k^{(rr')}\]</span></p>
</section>
<section id="penalty-structure-2" class="level4">
<h4 class="anchored" data-anchor-id="penalty-structure-2">Penalty Structure</h4>
<p>Each smooth term has a quadratic penalty: <span class="math display">\[\lambda_k^{(rr')} \beta_k^{(rr')T} D_k^{(rr')} \beta_k^{(rr')}\]</span></p>
<p>The overall penalty matrix is block-diagonal: <span class="math display">\[S_\lambda = \text{diag}\{S_{\lambda^{(rr')}} : (r, r') \in A\}\]</span></p>
<p>where each block is: <span class="math display">\[S_{\lambda^{(rr')}} = \text{diag}(0, \lambda_1^{(rr')} D_1^{(rr')}, \ldots, \lambda_{K^{(rr')}}^{(rr')} D_{K^{(rr')}}^{(rr')})\]</span></p>
</section>
<section id="key-innovation-analytical-hessian" class="level4">
<h4 class="anchored" data-anchor-id="key-innovation-analytical-hessian">Key Innovation: Analytical Hessian</h4>
<p>Unlike Machado, they derive and implement the <strong>exact analytical Hessian</strong> using results from Kosorok &amp; Chao (1996).</p>
<p>For transition probability matrix via eigendecomposition <span class="math inline">\(Q = A\Gamma A^{-1}\)</span>:</p>
<p><span class="math display">\[P(\delta t) = A \text{diag}(\exp(\gamma_1 \delta t), \ldots, \exp(\gamma_C \delta t)) A^{-1}\]</span></p>
<p><span class="math display">\[\frac{\partial P(\delta t)}{\partial \theta_w} = A U_w A^{-1}\]</span></p>
<p><span class="math display">\[\frac{\partial^2 P(\delta t)}{\partial \theta_w \partial \theta_{w'}} = A(\check{U}_{ww'} + \dot{U}_{ww'} + \dot{U}_{w'w}) A^{-1}\]</span></p>
<p>where: - <span class="math inline">\(U_w = G^{(w)} \circ E\)</span> with <span class="math inline">\(G^{(w)} = A^{-1} \frac{\partial Q}{\partial \theta_w} A\)</span> - <span class="math inline">\(E[l,m] = \frac{\exp(\gamma_l \delta t) - \exp(\gamma_m \delta t)}{\gamma_l - \gamma_m}\)</span> when <span class="math inline">\(\gamma_l \neq \gamma_m\)</span> - <span class="math inline">\(E[l,m] = \delta t \exp(\gamma_l \delta t)\)</span> when <span class="math inline">\(\gamma_l = \gamma_m\)</span></p>
<p>The second derivative terms <span class="math inline">\(\check{U}_{ww'}\)</span> and <span class="math inline">\(\dot{U}_{ww'}\)</span> have more complex expressions involving products of first-derivative quantities.</p>
</section>
<section id="estimation" class="level4">
<h4 class="anchored" data-anchor-id="estimation">Estimation</h4>
<p>Uses a <strong>trust region algorithm</strong> (not line search) which ‚Äúsignificantly outperforms its line search counterparts‚Äù when given analytical first and second derivatives.</p>
</section>
<section id="smoothing-parameter-selection-1" class="level4">
<h4 class="anchored" data-anchor-id="smoothing-parameter-selection-1">Smoothing Parameter Selection</h4>
<p>Uses REML-like methods following Marra &amp; Radice (2020), requiring the analytical observed information matrix.</p>
</section>
<section id="confidence-intervals-1" class="level4">
<h4 class="anchored" data-anchor-id="confidence-intervals-1">Confidence Intervals</h4>
<p>Same Bayesian approximation: <span class="math inline">\(\theta \sim N(\hat{\theta}, V_\theta)\)</span> where <span class="math inline">\(V_\theta = I_p(\hat{\theta})^{-1}\)</span> and <span class="math inline">\(I_p = -H_p\)</span> is the penalized Fisher information.</p>
<p>This gives ‚Äúclose to across-the-function frequentist coverage probabilities because it accounts for both sampling variability and smoothing bias.‚Äù</p>
</section>
<section id="model-selection" class="level4">
<h4 class="anchored" data-anchor-id="model-selection">Model Selection</h4>
<ul>
<li>AIC: <span class="math inline">\(-2\ell(\theta) + 2 \cdot \text{edf}\)</span></li>
<li>BIC: <span class="math inline">\(-2\ell(\theta) + \log(\check{n}) \cdot \text{edf}\)</span></li>
<li>Effective degrees of freedom (simple): <span class="math inline">\(\text{edf} = \text{tr}(I \cdot I_p^{-1})\)</span> where <span class="math inline">\(I = -H\)</span> is unpenalized Fisher info</li>
<li>Note: Eletti uses a more complex formula; we implement the simple version initially</li>
</ul>
</section>
<section id="advantages-over-machado" class="level4">
<h4 class="anchored" data-anchor-id="advantages-over-machado">Advantages over Machado</h4>
<ul>
<li>Exact Hessian enables stable convergence for complex models</li>
<li>Supports tensor products for time-varying effects</li>
<li>Trust region optimization is more robust</li>
<li>Can fit models that fail to converge with approximate methods</li>
</ul>
<hr>
</section>
</section>
<section id="a.3-wood-2016" class="level3">
<h3 class="anchored" data-anchor-id="a.3-wood-2016">A.3 Wood (2016)</h3>
<p><strong>‚ÄúP-splines with derivative based penalties and tensor product smoothing of unevenly distributed data‚Äù</strong></p>
<p><strong>Context:</strong> Efficient computation of derivative-based penalties for B-splines, with application to tensor product smoothing.</p>
<section id="motivation-3" class="level4">
<h4 class="anchored" data-anchor-id="motivation-3">Motivation</h4>
<p>P-splines (Eilers &amp; Marx 1996) use discrete difference penalties on coefficients. However: 1. B-spline bases arise from variational problems with <strong>derivative-based</strong> penalties 2. Discrete penalties are ‚Äúless interpretable in terms of function shape‚Äù 3. Discrete penalties only approximate derivative penalties ‚Äúin the limit of large basis size‚Äù ‚Äî but P-splines intentionally use small bases</p>
<p>Wood shows that derivative-based penalties can be computed with the <strong>same efficiency</strong> as P-splines.</p>
</section>
<section id="derivative-based-penalty" class="level4">
<h4 class="anchored" data-anchor-id="derivative-based-penalty">Derivative-Based Penalty</h4>
<p>For a spline <span class="math inline">\(f(x) = \sum_{j=1}^k \beta_j B_{m_1,j}(x)\)</span> with penalty based on the <span class="math inline">\(m_2\)</span>-th derivative:</p>
<p><span class="math display">\[J = \int_a^b [f^{(m_2)}(x)]^2 dx = \beta^T S \beta\]</span></p>
<p>where <span class="math inline">\(S\)</span> is a <strong>banded</strong> (sparse) penalty matrix.</p>
</section>
<section id="algorithm-for-computing-s" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-for-computing-s">Algorithm for Computing <span class="math inline">\(S\)</span></h4>
<p>Given B-splines of order <span class="math inline">\(m_1\)</span> with penalty order <span class="math inline">\(m_2\)</span> (where <span class="math inline">\(m_2 \leq m_1\)</span>):</p>
<p>Let <span class="math inline">\(p = m_1 - m_2\)</span> (order of piecewise polynomial for the derivative).</p>
<ol type="1">
<li><p><strong>Generate evaluation points:</strong> For each knot interval <span class="math inline">\([x_j, x_{j+1}]\)</span>, generate <span class="math inline">\(p+1\)</span> evenly spaced points.</p></li>
<li><p><strong>Compute derivative matrix <span class="math inline">\(G\)</span>:</strong> Maps spline coefficients <span class="math inline">\(\beta\)</span> to the <span class="math inline">\(m_2\)</span>-th derivative at evaluation points. (Use standard B-spline derivative recursions.)</p></li>
<li><p><strong>Compute weight matrix <span class="math inline">\(W\)</span>:</strong></p>
<ul>
<li>If <span class="math inline">\(p = 0\)</span>: <span class="math inline">\(W = \text{diag}(h)\)</span> where <span class="math inline">\(h_j = x_{j+1} - x_j\)</span></li>
<li>If <span class="math inline">\(p &gt; 0\)</span>: <span class="math inline">\(\tilde{W} = P^{-T} H P^{-1}\)</span> where:
<ul>
<li><span class="math inline">\(P_{ij} = (-1 + 2(i-1)/p)^j\)</span></li>
<li><span class="math inline">\(H_{ij} = (1 + (-1)^{i+j-2})/(i+j-1)\)</span></li>
</ul></li>
<li>Then <span class="math inline">\(W = \bigoplus_q (h_q/2) \tilde{W}\)</span> (block diagonal)</li>
</ul></li>
<li><p><strong>Penalty matrix:</strong> <span class="math inline">\(S = G^T W G\)</span> (banded, sparse)</p></li>
<li><p><strong>Optional square root:</strong> Compute <span class="math inline">\(R^T R = W\)</span> (Cholesky), then <span class="math inline">\(D = RG\)</span>, so <span class="math inline">\(S = D^T D\)</span>.</p></li>
</ol>
</section>
<section id="key-properties" class="level4">
<h4 class="anchored" data-anchor-id="key-properties">Key Properties</h4>
<ul>
<li><span class="math inline">\(S\)</span> is <strong>banded</strong> with <span class="math inline">\(2(m_1 - 1) + 1\)</span> non-zero diagonals</li>
<li><strong>Mix-and-match:</strong> Basis order <span class="math inline">\(m_1\)</span> and penalty order <span class="math inline">\(m_2\)</span> are independent</li>
<li>Cost: <span class="math inline">\(O(bk)\)</span> where <span class="math inline">\(b\)</span> = bandwidth, <span class="math inline">\(k\)</span> = basis dimension</li>
</ul>
</section>
<section id="tensor-product-smoothing" class="level4">
<h4 class="anchored" data-anchor-id="tensor-product-smoothing">Tensor Product Smoothing</h4>
<p>For a 3D smooth <span class="math inline">\(f(z_1, z_2, z_3)\)</span>:</p>
<p><span class="math display">\[f(z) = \sum_{ijl} \beta_{ijl} B_{1i}(z_1) B_{2j}(z_2) B_{3l}(z_3)\]</span></p>
<p>With coefficients in column-major order, the three penalties are <span class="math inline">\(\beta^T S_j \beta\)</span> where:</p>
<p><span class="math display">\[S_j = \tilde{D}_j^T \tilde{D}_j\]</span></p>
<p>with: - <span class="math inline">\(\tilde{D}_1 = D_1 \otimes I_{k_2} \otimes I_{k_3}\)</span> - <span class="math inline">\(\tilde{D}_2 = I_{k_1} \otimes D_2 \otimes I_{k_3}\)</span> - <span class="math inline">\(\tilde{D}_3 = I_{k_1} \otimes I_{k_2} \otimes D_3\)</span></p>
</section>
<section id="sparse-handling-for-partial-domains" class="level4">
<h4 class="anchored" data-anchor-id="sparse-handling-for-partial-domains">Sparse Handling for Partial Domains</h4>
<p>When data only covers part of the tensor product domain: 1. Identify coefficients <span class="math inline">\(\beta_\iota\)</span> where the basis function is zero at all data points 2. Drop rows <span class="math inline">\(\kappa\)</span> from <span class="math inline">\(\tilde{D}_j\)</span> where <span class="math inline">\(\tilde{D}_{j,\kappa\iota} \neq 0\)</span></p>
<p>This preserves the penalty structure while reducing dimensionality.</p>
</section>
<section id="handling-unevenly-spaced-knots" class="level4">
<h4 class="anchored" data-anchor-id="handling-unevenly-spaced-knots">Handling Unevenly Spaced Knots</h4>
<p>The algorithm naturally handles non-uniform knot spacing. The weight matrix <span class="math inline">\(W\)</span> accounts for variable knot intervals:</p>
<p>For penalty order <span class="math inline">\(m_2 = m_1\)</span> (so <span class="math inline">\(p = 0\)</span>): <span class="math display">\[W = \text{diag}(h_1, h_2, \ldots, h_{n_k})\]</span></p>
<p>where <span class="math inline">\(h_q = x_{q+1} - x_q\)</span> is the width of knot interval <span class="math inline">\(q\)</span>.</p>
<p>For <span class="math inline">\(p &gt; 0\)</span>, the block-diagonal structure becomes: <span class="math display">\[W = \bigoplus_{q=1}^{n_k} \frac{h_q}{2} \tilde{W}\]</span></p>
<p><strong>Key insight:</strong> The penalty matrix <span class="math inline">\(S = G^T W G\)</span> automatically adapts to non-uniform knot spacing.</p>
<hr>
</section>
</section>
<section id="a.4-wood-2024" class="level3">
<h3 class="anchored" data-anchor-id="a.4-wood-2024">A.4 Wood (2024)</h3>
<p><strong>‚ÄúOn Neighbourhood Cross Validation‚Äù</strong></p>
<p><strong>Context:</strong> Robust smoothing parameter selection for penalized regression when data has short-range autocorrelation.</p>
<section id="the-problem" class="level4">
<h4 class="anchored" data-anchor-id="the-problem">The Problem</h4>
<p>Standard CV/GCV/REML/UBRE assume that ‚Äúleave-one-out‚Äù residuals are approximately independent. In longitudinal/clustered data: - Observations within a subject are correlated - Leaving out one observation still ‚Äúleaks‚Äù information from correlated neighbors - Result: <strong>Undersmoothing</strong> (fitting noise as signal)</p>
</section>
<section id="ncv-solution" class="level4">
<h4 class="anchored" data-anchor-id="ncv-solution">NCV Solution</h4>
<p>Leave out an entire <strong>neighbourhood</strong> (e.g., all observations from one subject) instead of single observations.</p>
<p>The NCV criterion: <span class="math display">\[V = \sum_k \sum_{i \in \delta(k)} D(y_i, \hat{\theta}_i^{-\alpha(k)})\]</span></p>
<p>where: - <span class="math inline">\(\delta(k)\)</span> is neighbourhood <span class="math inline">\(k\)</span> - <span class="math inline">\(\alpha(k)\)</span> is the set of indices for neighbourhood <span class="math inline">\(k\)</span> - <span class="math inline">\(\hat{\theta}^{-\alpha(k)}\)</span> is the estimate with neighbourhood <span class="math inline">\(k\)</span> removed</p>
</section>
<section id="efficient-computation-via-pijcv" class="level4">
<h4 class="anchored" data-anchor-id="efficient-computation-via-pijcv">Efficient Computation via PIJCV</h4>
<p>Exact NCV would require refitting the model <span class="math inline">\(m\)</span> times (once per neighbourhood). Wood‚Äôs key contribution is an efficient <strong>approximation</strong> using a single Newton step from the full-data estimate.</p>
<p>The ‚Äúleave-out‚Äù parameter perturbation is approximated as:</p>
<p><span class="math display">\[\hat{\theta}^{-\alpha(k)} \approx \hat{\theta} + \Delta_{-\alpha(k)}\]</span></p>
<p>where:</p>
<p><span class="math display">\[\Delta_{-\alpha(k)} = H_{\lambda,\alpha(k)}^{-1} g_{\alpha(k)}\]</span></p>
<p>with: - <span class="math inline">\(H_{\lambda,\alpha(k)} = H_\lambda - H_{\alpha(k),\alpha(k)}\)</span> (penalized Hessian minus neighbourhood contribution) - <span class="math inline">\(g_{\alpha(k)}\)</span> is the gradient contribution from neighbourhood <span class="math inline">\(k\)</span></p>
<p>This is the <strong>Predictive Infinitesimal Jackknife Cross-Validation (PIJCV)</strong>.</p>
</section>
<section id="relationship-to-standard-infinitesimal-jackknife" class="level4">
<h4 class="anchored" data-anchor-id="relationship-to-standard-infinitesimal-jackknife">Relationship to Standard Infinitesimal Jackknife</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 46%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Standard IJ</th>
<th style="text-align: left;">PIJCV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Leave-out unit</td>
<td style="text-align: left;">Single observation</td>
<td style="text-align: left;">Neighbourhood (subject)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Approximation</td>
<td style="text-align: left;"><span class="math inline">\(\hat{\theta}^{[-i]} \approx \hat{\theta} - H^{-1} \psi_i\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\hat{\theta}^{-\alpha(k)} \approx \hat{\theta} + H_{\lambda,\alpha(k)}^{-1} g_{\alpha(k)}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hessian used</td>
<td style="text-align: left;">Full <span class="math inline">\(H\)</span></td>
<td style="text-align: left;"><strong>Downdated</strong> <span class="math inline">\(H_{\lambda,\alpha(k)}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Accuracy</td>
<td style="text-align: left;"><span class="math inline">\(O(n^{-1})\)</span></td>
<td style="text-align: left;"><span class="math inline">\(O(n^{-2})\)</span></td>
</tr>
</tbody>
</table>
<p><strong>Key refinement:</strong> The downdated Hessian is closer to the true leave-out Hessian, improving approximation accuracy.</p>
<p>Using <strong>Cholesky downdating</strong>, PIJCV can be computed in <span class="math inline">\(O(mp^2)\)</span> time rather than <span class="math inline">\(O(m)\)</span> refits.</p>
</section>
<section id="requirements-for-implementation" class="level4">
<h4 class="anchored" data-anchor-id="requirements-for-implementation">Requirements for Implementation</h4>
<ol type="1">
<li><strong>Penalized Hessian <span class="math inline">\(H_\lambda\)</span>:</strong> Must be exact (not approximate)</li>
<li><strong>Per-neighbourhood gradients <span class="math inline">\(g_{\alpha(k)}\)</span>:</strong> Must be extractable</li>
<li><strong>Per-neighbourhood Hessian contributions <span class="math inline">\(H_{\alpha(k),\alpha(k)}\)</span>:</strong> For the downdate</li>
</ol>
</section>
<section id="degeneracy-protections" class="level4">
<h4 class="anchored" data-anchor-id="degeneracy-protections">Degeneracy Protections</h4>
<ul>
<li>Cholesky downdate with indefiniteness detection</li>
<li>Woodbury identity fallback for indefinite cases</li>
<li>Quadratic approximation (QNCV) for finite deviance robustness</li>
</ul>
<hr>
</section>
</section>
</section>
<section id="appendix-b-detailed-explanation-of-classical-cv-methods" class="level2">
<h2 class="anchored" data-anchor-id="appendix-b-detailed-explanation-of-classical-cv-methods">Appendix B: Detailed Explanation of Classical CV Methods</h2>
<section id="the-starting-point-leave-one-out-cross-validation" class="level3">
<h3 class="anchored" data-anchor-id="the-starting-point-leave-one-out-cross-validation">The Starting Point: Leave-One-Out Cross-Validation</h3>
<p>The ideal criterion would be true leave-one-out CV: <span class="math display">\[\text{CV} = \frac{1}{n} \sum_{i=1}^n (y_i - \hat{f}^{[-i]}(x_i))^2\]</span></p>
<p>where <span class="math inline">\(\hat{f}^{[-i]}\)</span> is the fit with observation <span class="math inline">\(i\)</span> removed. This requires <span class="math inline">\(n\)</span> refits‚Äîexpensive. GCV, UBRE, and GACV are efficient approximations.</p>
</section>
<section id="ubre-unbiased-risk-estimator" class="level3">
<h3 class="anchored" data-anchor-id="ubre-unbiased-risk-estimator">UBRE (Unbiased Risk Estimator)</h3>
<p><strong>When scale <span class="math inline">\(\sigma^2\)</span> is known</strong>, there‚Äôs a shortcut. The expected prediction error is:</p>
<p><span class="math display">\[\text{EPE} = E\|y - \hat{f}\|^2 = \sigma^2(n - 2\cdot\text{tr}(A) + \text{tr}(A^TA))\]</span></p>
<p>where <span class="math inline">\(A\)</span> is the ‚Äúhat matrix‚Äù (<span class="math inline">\(\hat{y} = Ay\)</span>). This leads to:</p>
<p><span class="math display">\[\text{UBRE} = \frac{1}{n}\|y - \hat{f}\|^2 - \sigma^2 + \frac{2\sigma^2}{n}\text{tr}(A)\]</span></p>
<p>This is algebraically equivalent to <strong>Mallows‚Äô <span class="math inline">\(C_p\)</span></strong> and to <strong>AIC</strong> (up to constants): <span class="math display">\[\text{UBRE} = \frac{\text{RSS}}{n} + \frac{2\sigma^2 \cdot \text{edf}}{n} - \sigma^2\]</span></p>
<p><strong>Key insight</strong>: The <span class="math inline">\(2\cdot\text{edf}\)</span> term corrects for the optimism of training error.</p>
</section>
<section id="gcv-generalized-cross-validation" class="level3">
<h3 class="anchored" data-anchor-id="gcv-generalized-cross-validation">GCV (Generalized Cross-Validation)</h3>
<p><strong>When scale <span class="math inline">\(\sigma^2\)</span> is unknown</strong>, UBRE doesn‚Äôt work. Craven &amp; Wahba (1979) proposed:</p>
<p><span class="math display">\[\text{GCV} = \frac{n \cdot \text{RSS}}{(n - \text{tr}(A))^2} = \frac{\|y - \hat{f}\|^2 / n}{(1 - \text{edf}/n)^2}\]</span></p>
<p><strong>Where does this come from?</strong></p>
<ol type="1">
<li><p>True leave-one-out CV can be computed without refitting using: <span class="math display">\[\text{CV} = \frac{1}{n}\sum_{i=1}^n \left(\frac{y_i - \hat{f}(x_i)}{1 - A_{ii}}\right)^2\]</span></p></li>
<li><p>GCV replaces each <span class="math inline">\(A_{ii}\)</span> with the average <span class="math inline">\(\text{tr}(A)/n\)</span>: <span class="math display">\[\text{GCV} = \frac{1}{n}\sum_{i=1}^n \left(\frac{y_i - \hat{f}(x_i)}{1 - \text{tr}(A)/n}\right)^2\]</span></p></li>
</ol>
<p><strong>Why ‚Äúgeneralized‚Äù?</strong> The averaging makes GCV invariant to rotations of the coordinate system.</p>
</section>
<section id="gacv-generalized-approximate-cv" class="level3">
<h3 class="anchored" data-anchor-id="gacv-generalized-approximate-cv">GACV (Generalized Approximate CV)</h3>
<p>For <strong>non-Gaussian likelihoods</strong> (Poisson, binomial, etc.), there‚Äôs no simple hat matrix. GACV extends GCV:</p>
<p><span class="math display">\[\text{GACV} = \frac{\sum_i D(y_i, \hat{\mu}_i)}{n - \text{tr}(\tilde{A})}\]</span></p>
<p>where <span class="math inline">\(D\)</span> is the deviance contribution and <span class="math inline">\(\tilde{A}\)</span> is an ‚Äúinfluence matrix.‚Äù</p>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 18%">
<col style="width: 36%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Method</th>
<th style="text-align: left;">Scale</th>
<th style="text-align: left;">Distribution</th>
<th style="text-align: left;">Formula</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>UBRE</strong></td>
<td style="text-align: left;">Known</td>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: left;"><span class="math inline">\(\text{RSS}/n + 2\sigma^2\cdot\text{edf}/n\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>GCV</strong></td>
<td style="text-align: left;">Unknown</td>
<td style="text-align: left;">Gaussian</td>
<td style="text-align: left;"><span class="math inline">\(\text{RSS}/n \cdot (1 - \text{edf}/n)^{-2}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>GACV</strong></td>
<td style="text-align: left;">Unknown</td>
<td style="text-align: left;">Any (GLM)</td>
<td style="text-align: left;">Deviance/(n - edf)</td>
</tr>
</tbody>
</table>
</section>
<section id="why-these-are-suboptimal-for-multistate-models" class="level3">
<h3 class="anchored" data-anchor-id="why-these-are-suboptimal-for-multistate-models">Why These Are Suboptimal for Multistate Models</h3>
<p>All three assume: 1. <strong>Observation-level independence</strong>: Each <span class="math inline">\(y_i\)</span> contributes independently. 2. <strong>Hat matrix exists</strong>: <span class="math inline">\(\hat{y} = Ay\)</span>.</p>
<p>In multistate models with panel data: - <strong>Correlation:</strong> Observations within a subject are correlated. - <strong>Undersmoothing:</strong> Treating correlated observations as independent leads to undersmoothing (fitting noise).</p>
<p>Machado et al.&nbsp;(2018) showed that you <em>can</em> mechanically apply UBRE by constructing a working linear model. However, Wood (2024) argues that for correlated data, criteria that respect the correlation structure (like NCV) are theoretically superior.</p>
<hr>
</section>
</section>
<section id="appendix-c-comparison-table" class="level2">
<h2 class="anchored" data-anchor-id="appendix-c-comparison-table">Appendix C: Comparison Table</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 23%">
<col style="width: 21%">
<col style="width: 18%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Machado (2018)</th>
<th style="text-align: left;">Eletti (2024)</th>
<th style="text-align: left;">Wood (2016)</th>
<th style="text-align: left;">Wood (2024) NCV</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Focus</strong></td>
<td style="text-align: left;">Multistate models</td>
<td style="text-align: left;">Multistate models</td>
<td style="text-align: left;">Penalty computation</td>
<td style="text-align: left;">Smoothing selection</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Penalty Type</strong></td>
<td style="text-align: left;">Unspecified</td>
<td style="text-align: left;">Flexible</td>
<td style="text-align: left;"><strong>Derivative-based</strong></td>
<td style="text-align: left;">Any</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Penalty Matrix</strong></td>
<td style="text-align: left;">Block-diagonal</td>
<td style="text-align: left;">Block-diagonal</td>
<td style="text-align: left;">Banded/sparse</td>
<td style="text-align: left;">Any</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Tensor Products</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: left;"><strong>Yes</strong></td>
<td style="text-align: left;">Compatible</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Hessian</strong></td>
<td style="text-align: left;">Approximate (1st order)</td>
<td style="text-align: left;"><strong>Exact</strong> (2nd order)</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;">Requires exact</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Smoothing Selection</strong></td>
<td style="text-align: left;">UBRE</td>
<td style="text-align: left;">REML</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;"><strong>NCV</strong></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Autocorrelation Robust</strong></td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">No</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;"><strong>Yes</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Optimization</strong></td>
<td style="text-align: left;">Scoring</td>
<td style="text-align: left;">Trust region</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;">N/A</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Key Marra Ref</strong></td>
<td style="text-align: left;">Marra et al.&nbsp;(2017)</td>
<td style="text-align: left;">Marra &amp; Radice (2020)</td>
<td style="text-align: left;">N/A</td>
<td style="text-align: left;">Marra &amp; Wood (2012)</td>
</tr>
</tbody>
</table>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>