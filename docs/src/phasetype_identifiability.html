<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>phasetype_identifiability</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="phasetype_identifiability_files/libs/clipboard/clipboard.min.js"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/popper.min.js"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="phasetype_identifiability_files/libs/quarto-html/anchor.min.js"></script>
<link href="phasetype_identifiability_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="phasetype_identifiability_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="phasetype_identifiability_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="phasetype_identifiability_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="phasetype_identifiability_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="identifiability-in-phase-type-models-with-covariates" class="level1">
<h1>Identifiability in Phase-Type Models with Covariates</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This document provides a rigorous analysis of identifiability options for Coxian phase-type hazard models in MultistateModels.jl. We consider a spectrum from completely unstructured (maximum flexibility, potential non-identifiability) to highly structured (reduced flexibility, guaranteed identifiability), examining both <strong>hard constraints</strong> (enforced via optimization) and <strong>soft constraints</strong> (enforced via penalties/priors).</p>
<hr>
</section>
<section id="model-setup-and-notation" class="level2">
<h2 class="anchored" data-anchor-id="model-setup-and-notation">1. Model Setup and Notation</h2>
<section id="coxian-phase-type-structure" class="level3">
<h3 class="anchored" data-anchor-id="coxian-phase-type-structure">1.1 Coxian Phase-Type Structure</h3>
<p>Consider a transition from observed state <span class="math inline">\(r\)</span> to observed state <span class="math inline">\(d\)</span> (destination). The sojourn time in state <span class="math inline">\(r\)</span> follows a <strong>Coxian phase-type distribution</strong> with <span class="math inline">\(n\)</span> latent phases.</p>
<p><strong>Latent state space expansion:</strong> - Observed state <span class="math inline">\(r\)</span> expands to phases <span class="math inline">\(r_1, r_2, \ldots, r_n\)</span> - A subject enters in phase <span class="math inline">\(r_1\)</span> and progresses sequentially: <span class="math inline">\(r_1 \to r_2 \to \cdots \to r_n\)</span> - Exit to destination <span class="math inline">\(d\)</span> can occur from any phase</p>
<p><strong>Transition intensities:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 42%">
<col style="width: 25%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Transition Type</th>
<th>Notation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Progression</td>
<td><span class="math inline">\(\lambda_j\)</span></td>
<td>Rate from phase <span class="math inline">\(r_j\)</span> to phase <span class="math inline">\(r_{j+1}\)</span> for <span class="math inline">\(j = 1, \ldots, n-1\)</span></td>
</tr>
<tr class="even">
<td>Exit</td>
<td><span class="math inline">\(\mu_{j,d}\)</span></td>
<td>Rate from phase <span class="math inline">\(r_j\)</span> to destination <span class="math inline">\(d\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="eigenvalues-vs.-component-rates" class="level3">
<h3 class="anchored" data-anchor-id="eigenvalues-vs.-component-rates">1.2 Eigenvalues vs.&nbsp;Component Rates</h3>
<p><strong>Important distinction:</strong> The identifiability literature (Lindqvist, Cumani) discusses ordering constraints on <strong>eigenvalues</strong> of the sub-generator matrix. For an upper-triangular Coxian generator, the eigenvalues equal the <strong>total exit rates</strong> from each phase (the diagonal elements), not the individual component rates.</p>
<p>Define the <strong>total rate out of phase <span class="math inline">\(j\)</span></strong>: <span class="math display">\[
\nu_j = \lambda_j + \mu_j^{\text{total}} = \lambda_j + \sum_{d} \mu_{j,d}
\]</span></p>
<p>where <span class="math inline">\(\nu_n = \mu_n^{\text{total}}\)</span> for the final phase (no progression).</p>
<p>These <span class="math inline">\(\nu_j\)</span> are the eigenvalues of the sub-generator and appear on the diagonal. The canonical representation theorem orders these <strong>total rates</strong>, not the progression rates alone: <span class="math display">\[
\nu_1 \geq \nu_2 \geq \cdots \geq \nu_n
\]</span></p>
<p>This couples progression and exit rates in the identifiability constraint.</p>
<p>The generator matrix for the expanded state space (for a single destination) is:</p>
<p><span class="math display">\[
\mathbf{Q} = \begin{pmatrix}
-(\lambda_1 + \mu_{1,d}) &amp; \lambda_1 &amp; 0 &amp; \cdots &amp; 0 &amp; \mu_{1,d} \\
0 &amp; -(\lambda_2 + \mu_{2,d}) &amp; \lambda_2 &amp; \cdots &amp; 0 &amp; \mu_{2,d} \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; -(\lambda_{n-1} + \mu_{n-1,d}) &amp; \lambda_{n-1} &amp; \mu_{n-1,d} \\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\mu_{n,d} &amp; \mu_{n,d} \\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0
\end{pmatrix}
\]</span></p>
</section>
<section id="multiple-destinations" class="level3">
<h3 class="anchored" data-anchor-id="multiple-destinations">1.3 Multiple Destinations</h3>
<p>When state <span class="math inline">\(r\)</span> has <span class="math inline">\(K\)</span> possible destination states <span class="math inline">\(d_1, \ldots, d_K\)</span>, the total exit rate from phase <span class="math inline">\(j\)</span> is:</p>
<p><span class="math display">\[
\mu_j^{\text{total}} = \sum_{k=1}^{K} \mu_{j,d_k}
\]</span></p>
<p>The probability of exiting to destination <span class="math inline">\(d_k\)</span> given exit from phase <span class="math inline">\(j\)</span> is:</p>
<p><span class="math display">\[
P(d_k \mid \text{exit from phase } j) = \frac{\mu_{j,d_k}}{\mu_j^{\text{total}}}
\]</span></p>
</section>
<section id="covariate-effects" class="level3">
<h3 class="anchored" data-anchor-id="covariate-effects">1.4 Covariate Effects</h3>
<p>For a subject with covariate vector <span class="math inline">\(\mathbf{x}\)</span>, we model rates via log-linear effects:</p>
<p><strong>Progression rates:</strong> <span class="math display">\[
\lambda_j(\mathbf{x}) = \lambda_j^{(0)} \exp(\boldsymbol{\beta}^{(\lambda_j)\top} \mathbf{x})
\]</span></p>
<p><strong>Exit rates:</strong> <span class="math display">\[
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(\mu_{j,d})\top} \mathbf{x})
\]</span></p>
<p>where superscript <span class="math inline">\((0)\)</span> denotes baseline parameters.</p>
</section>
<section id="parameter-count-unstructured-model" class="level3">
<h3 class="anchored" data-anchor-id="parameter-count-unstructured-model">1.5 Parameter Count (Unstructured Model)</h3>
<p>For <span class="math inline">\(n\)</span> phases and <span class="math inline">\(K\)</span> destinations:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr class="header">
<th>Component</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Progression baselines <span class="math inline">\(\lambda_j^{(0)}\)</span></td>
<td><span class="math inline">\(n - 1\)</span></td>
</tr>
<tr class="even">
<td>Exit baselines <span class="math inline">\(\mu_{j,d}^{(0)}\)</span></td>
<td><span class="math inline">\(n \times K\)</span></td>
</tr>
<tr class="odd">
<td><strong>Total baseline</strong></td>
<td><span class="math inline">\((K+1)n - 1\)</span></td>
</tr>
<tr class="even">
<td>Progression covariates <span class="math inline">\(\boldsymbol{\beta}^{(\lambda_j)}\)</span></td>
<td><span class="math inline">\((n-1) \times p\)</span></td>
</tr>
<tr class="odd">
<td>Exit covariates <span class="math inline">\(\boldsymbol{\beta}^{(\mu_{j,d})}\)</span></td>
<td><span class="math inline">\(n \times K \times p\)</span></td>
</tr>
<tr class="even">
<td><strong>Total covariate</strong></td>
<td><span class="math inline">\(((K+1)n - 1) \times p\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math inline">\(p\)</span> is the number of covariates.</p>
<hr>
</section>
</section>
<section id="the-identifiability-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-identifiability-problem">2. The Identifiability Problem</h2>
<section id="non-uniqueness-of-representations-lindqvist-2022" class="level3">
<h3 class="anchored" data-anchor-id="non-uniqueness-of-representations-lindqvist-2022">2.1 Non-Uniqueness of Representations (Lindqvist 2022)</h3>
<p><strong>Theorem (Telek &amp; Horváth 2007):</strong> Two nonredundant phase-type representations <span class="math inline">\((\mathbf{p}^{(a)}, \mathbf{Q}^{(a)})\)</span> and <span class="math inline">\((\mathbf{p}^{(b)}, \mathbf{Q}^{(b)})\)</span> of the same dimension yield the same distribution if and only if there exists an invertible matrix <span class="math inline">\(\mathbf{B}\)</span> with <span class="math inline">\(\mathbf{B}\mathbf{1} = \mathbf{1}\)</span> such that:</p>
<p><span class="math display">\[
\mathbf{p}^{(b)} = \mathbf{p}^{(a)\top} \mathbf{B}, \quad \mathbf{Q}^{(b)} = \mathbf{B}^{-1} \mathbf{Q}^{(a)} \mathbf{B}
\]</span></p>
<p><strong>Implication:</strong> Different parameter values can yield identical likelihoods, making MLEs non-unique.</p>
</section>
<section id="coxian-identifiability-cumani-1982-rizk-et-al.-2019" class="level3">
<h3 class="anchored" data-anchor-id="coxian-identifiability-cumani-1982-rizk-et-al.-2019">2.2 Coxian Identifiability (Cumani 1982, Rizk et al.&nbsp;2019)</h3>
<p><strong>Theorem (Canonical Representation):</strong> Any upper-triangular phase-type distribution has a unique canonical representation with <strong>eigenvalues</strong> (total rates out of each phase) ordered as:</p>
<p><span class="math display">\[
\nu_1 \geq \nu_2 \geq \cdots \geq \nu_n
\]</span></p>
<p>where <span class="math inline">\(\nu_j = \lambda_j + \mu_j^{\text{total}}\)</span> is the total rate out of phase <span class="math inline">\(j\)</span>.</p>
<p><strong>Theorem (Rizk et al.&nbsp;2019):</strong> For Coxian models with fixed initial distribution <span class="math inline">\(\mathbf{p} = (1, 0, \ldots, 0)^\top\)</span> and the same diagonal ordering, the representation is unique.</p>
<p><strong>Note on initial distribution:</strong> The <span class="math inline">\(\mathbf{p} = (1, 0, \ldots, 0)^\top\)</span> assumption holds when transitions into the state are observed exactly. With panel data where entry times are unknown, the initial phase distribution must be inferred, complicating identifiability.</p>
</section>
<section id="why-covariates-complicate-matters" class="level3">
<h3 class="anchored" data-anchor-id="why-covariates-complicate-matters">2.3 Why Covariates Complicate Matters</h3>
<p>Covariates introduce subject-specific rates. For identifiability: 1. The ordering <span class="math inline">\(\nu_1(\mathbf{x}) \geq \nu_2(\mathbf{x}) \geq \cdots\)</span> must hold <strong>for all</strong> <span class="math inline">\(\mathbf{x}\)</span> 2. Different covariate effects on component rates can violate the total-rate ordering for some subjects 3. Proportional hazards effects (same <span class="math inline">\(\boldsymbol{\beta}\)</span> for all rates) preserve ordering</p>
<hr>
</section>
</section>
<section id="spectrum-of-model-structures" class="level2">
<h2 class="anchored" data-anchor-id="spectrum-of-model-structures">3. Spectrum of Model Structures</h2>
<p>We organize constraints along two dimensions: <strong>baseline hazards</strong> and <strong>covariate effects</strong>.</p>
<section id="baseline-hazard-structures" class="level3">
<h3 class="anchored" data-anchor-id="baseline-hazard-structures">3.1 Baseline Hazard Structures</h3>
<section id="level-b0-completely-unstructured" class="level4">
<h4 class="anchored" data-anchor-id="level-b0-completely-unstructured">Level B0: Completely Unstructured</h4>
<p><strong>Parameters:</strong> All <span class="math inline">\(\lambda_j^{(0)}\)</span> and <span class="math inline">\(\mu_{j,d}^{(0)}\)</span> are free.</p>
<p><strong>Count:</strong> <span class="math inline">\((K+1)n - 1\)</span> baseline parameters.</p>
<p><strong>Identifiability:</strong> ❌ Not guaranteed. Equivalent representations exist.</p>
<p><strong>Implementation:</strong> None required — this is the default.</p>
<p><strong>Practicality:</strong> ✅ Trivial. Current MultistateModels.jl default for <code>:pt</code> hazards.</p>
<p><strong>Use case:</strong> Exploratory analysis with abundant data.</p>
<hr>
</section>
<section id="level-b1-eigenvalue-ordering-lindqvist-canonical" class="level4">
<h4 class="anchored" data-anchor-id="level-b1-eigenvalue-ordering-lindqvist-canonical">Level B1: Eigenvalue Ordering (Lindqvist Canonical)</h4>
<p><strong>Constraint:</strong> The <strong>total rates</strong> (eigenvalues) must be ordered: <span class="math display">\[
\nu_1^{(0)} \geq \nu_2^{(0)} \geq \cdots \geq \nu_n^{(0)}
\]</span></p>
<p>where <span class="math inline">\(\nu_j^{(0)} = \lambda_j^{(0)} + \mu_j^{\text{total},(0)}\)</span> for <span class="math inline">\(j &lt; n\)</span> and <span class="math inline">\(\nu_n^{(0)} = \mu_n^{\text{total},(0)}\)</span>.</p>
<p><strong>Important:</strong> This constraint couples progression rates <span class="math inline">\(\lambda_j\)</span> with exit rates <span class="math inline">\(\mu_{j,d}\)</span>. It is <strong>not</strong> simply an ordering on the progression rates alone.</p>
<p><strong>Count:</strong> <span class="math inline">\((K+1)n - 1\)</span> parameters (unchanged, but constrained).</p>
<p><strong>Identifiability:</strong> ✅ Guaranteed for baseline (single-covariate-value).</p>
<p><strong>Implementation options:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 20%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>How</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Inequality constraints</strong></td>
<td>Add <span class="math inline">\(\nu_j \leq \nu_{j-1}\)</span> to optimizer</td>
<td>Moderate — requires constrained optimization</td>
</tr>
<tr class="even">
<td><strong>Reparameterization</strong></td>
<td>Work with <span class="math inline">\(\nu_j\)</span> directly, derive <span class="math inline">\(\lambda_j = \nu_j - \mu_j^{\text{total}}\)</span></td>
<td>High — complex bookkeeping</td>
</tr>
<tr class="odd">
<td><strong>Soft penalty</strong></td>
<td>Add <span class="math inline">\(\rho \sum_j \max(0, \nu_j - \nu_{j-1})^2\)</span> to objective</td>
<td>Low — unconstrained optimization</td>
</tr>
</tbody>
</table>
<p><strong>Practicality:</strong> ⚠️ Moderate difficulty. The constraint couples all parameters, making it awkward to implement cleanly. The reparameterization approach requires tracking derived quantities. <strong>Recommend soft penalty as simplest option.</strong></p>
<hr>
</section>
<section id="level-b2-sctp-stationary-conditional-transition-probabilities" class="level4">
<h4 class="anchored" data-anchor-id="level-b2-sctp-stationary-conditional-transition-probabilities">Level B2: SCTP (Stationary Conditional Transition Probabilities)</h4>
<p><strong>Constraint:</strong> Exit rates from each phase scale by a common <strong>phase effect</strong> <span class="math inline">\(\tau_j\)</span>:</p>
<p><span class="math display">\[
\mu_{j,d}^{(0)} = \tau_j \cdot \mu_{1,d}^{(0)} \quad \text{for all } d, \quad \tau_1 \equiv 1
\]</span></p>
<p><strong>Equivalent formulation (log scale):</strong> <span class="math display">\[
\log \mu_{j,d}^{(0)} - \log \mu_{1,d}^{(0)} = \log \tau_j \quad \text{(constant across } d \text{)}
\]</span></p>
<p><strong>Parameter reduction:</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Before SCTP</th>
<th>After SCTP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(nK\)</span> exit baselines</td>
<td><span class="math inline">\(K\)</span> baseline rates + <span class="math inline">\((n-1)\)</span> phase effects</td>
</tr>
</tbody>
</table>
<p><strong>New count:</strong> <span class="math inline">\((n-1) + K + (n-1) = n + K - 1\)</span> baseline parameters.</p>
<p><strong>Identifiability:</strong> ✅ Better conditioned. Preserves exit probability stationarity.</p>
<p><strong>Implementation options:</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 32%">
<col style="width: 20%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>How</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Equality constraints</strong></td>
<td>Add <span class="math inline">\((n-1)(K-1)\)</span> constraints: <span class="math inline">\(\log \mu_{j,d_1} - \log \mu_{1,d_1} = \log \mu_{j,d_2} - \log \mu_{1,d_2}\)</span></td>
<td>Moderate</td>
</tr>
<tr class="even">
<td><strong>Reparameterization</strong></td>
<td>Store <span class="math inline">\(\mu_{1,d}\)</span> and <span class="math inline">\(\tau_j\)</span>; compute <span class="math inline">\(\mu_{j,d} = \tau_j \mu_{1,d}\)</span></td>
<td>Low — <strong>recommended</strong></td>
</tr>
<tr class="odd">
<td><strong>Soft penalty</strong></td>
<td>Penalize variance of <span class="math inline">\(\log(\mu_{j,d}/\mu_{1,d})\)</span> across <span class="math inline">\(d\)</span></td>
<td>Low</td>
</tr>
</tbody>
</table>
<p><strong>Practicality:</strong> ✅ <strong>Already implemented</strong> in MultistateModels.jl via <code>_generate_sctp_constraints()</code> in <code>expansion_constraints.jl</code>. Uses equality constraints approach.</p>
<p><strong>Interpretation:</strong> The probability of exiting to each destination is constant regardless of phase (hence “stationary” in sojourn time).</p>
<hr>
</section>
<section id="level-b3-b1-b2-combined-ordered-sctp" class="level4">
<h4 class="anchored" data-anchor-id="level-b3-b1-b2-combined-ordered-sctp">Level B3: B1 + B2 Combined (Ordered + SCTP)</h4>
<p><strong>Constraints:</strong> 1. <span class="math inline">\(\nu_1^{(0)} \geq \nu_2^{(0)} \geq \cdots \geq \nu_n^{(0)}\)</span> (total rate ordering) 2. <span class="math inline">\(\mu_{j,d}^{(0)} = \tau_j \cdot \mu_{1,d}^{(0)}\)</span> (SCTP)</p>
<p><strong>Count:</strong> <span class="math inline">\((n-1) + K + (n-1) = n + K - 1\)</span> baseline parameters (ordered + SCTP).</p>
<p><strong>Identifiability:</strong> ✅ Strong.</p>
<p><strong>Implementation:</strong> Combine B1 and B2 approaches. With SCTP reparameterization, the total rate simplifies to: <span class="math display">\[
\nu_j = \lambda_j + \tau_j \sum_d \mu_{1,d}
\]</span> so ordering constraint becomes a function of <span class="math inline">\(\lambda_j\)</span>, <span class="math inline">\(\tau_j\)</span>, and the phase-1 exit rates.</p>
<p><strong>Practicality:</strong> ⚠️ Moderate. SCTP is implemented; eigenvalue ordering adds complexity. For soft constraint version, add ordering penalty to existing SCTP implementation.</p>
<hr>
</section>
<section id="level-b4-erlang-structure-equal-progression-rates" class="level4">
<h4 class="anchored" data-anchor-id="level-b4-erlang-structure-equal-progression-rates">Level B4: Erlang Structure (Equal Progression Rates)</h4>
<p><strong>Constraint:</strong> All progression rates equal: <span class="math display">\[
\lambda_1^{(0)} = \lambda_2^{(0)} = \cdots = \lambda_{n-1}^{(0)} \equiv \lambda^{(0)}
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(1 + nK\)</span> baseline parameters (or <span class="math inline">\(1 + K + (n-1) = n + K\)</span> with SCTP).</p>
<p><strong>Identifiability:</strong> ✅ Strongly identified. The sojourn distribution becomes a generalized Erlang mixture.</p>
<p><strong>Implementation:</strong> - <strong>Reparameterization:</strong> Use single <span class="math inline">\(\lambda\)</span> parameter; all progression hazards reference same parameter name. - In <code>_build_progression_hazard()</code>, use shared parameter name <code>h{from}_lambda</code> instead of <code>h{from}_{a}{b}_rate</code>.</p>
<p><strong>Practicality:</strong> ✅ Easy. Simple change to parameter naming in hazard expansion. Automatically satisfies eigenvalue ordering (all <span class="math inline">\(\lambda_j\)</span> equal, so ordering determined by exit rates only).</p>
<p><strong>Note:</strong> Very restrictive; may not fit data well. Use when data are limited or for hypothesis testing.</p>
<hr>
</section>
</section>
<section id="covariate-effect-structures" class="level3">
<h3 class="anchored" data-anchor-id="covariate-effect-structures">3.2 Covariate Effect Structures</h3>
<section id="level-c0-completely-unstructured" class="level4">
<h4 class="anchored" data-anchor-id="level-c0-completely-unstructured">Level C0: Completely Unstructured</h4>
<p><strong>Parameters:</strong> Each rate has its own covariate vector: - <span class="math inline">\(\boldsymbol{\beta}^{(\lambda_j)}\)</span> for <span class="math inline">\(j = 1, \ldots, n-1\)</span> - <span class="math inline">\(\boldsymbol{\beta}^{(\mu_{j,d})}\)</span> for <span class="math inline">\(j = 1, \ldots, n\)</span>, <span class="math inline">\(d = 1, \ldots, K\)</span></p>
<p><strong>Count:</strong> <span class="math inline">\(((K+1)n - 1) \times p\)</span> covariate parameters.</p>
<p><strong>Identifiability:</strong> ❌ Poor. Covariates can break eigenvalue ordering.</p>
<p><strong>Implementation:</strong> None required — this is what happens with independent parameter names per phase.</p>
<p><strong>Practicality:</strong> ✅ Trivial. <strong>Partially implemented</strong>: Current MultistateModels.jl puts independent covariate effects on exit rates (<code>h12_a_x</code>, <code>h12_b_x</code>), but does <strong>not</strong> put covariates on progression rates. This is the default behavior (<code>:per_phase</code>).</p>
<p><strong>Current state:</strong> Exit rates have phase-specific covariates (C0 for exits); progression rates have no covariates.</p>
<hr>
</section>
<section id="level-c1-shared-covariate-effects-across-phases-per-destination" class="level4">
<h4 class="anchored" data-anchor-id="level-c1-shared-covariate-effects-across-phases-per-destination">Level C1: Shared Covariate Effects Across Phases (per destination)</h4>
<p><strong>Constraint:</strong> All phases share the same covariate effect for a given destination: <span class="math display">\[
\boldsymbol{\beta}^{(\mu_{j,d})} = \boldsymbol{\beta}^{(d)} \quad \text{for all } j
\]</span></p>
<p><strong>Exit rate model:</strong> <span class="math display">\[
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(d)\top} \mathbf{x})
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(K \times p\)</span> covariate parameters for exits (no covariates on progression).</p>
<p><strong>Identifiability:</strong> ✅ Good. Substantial improvement over C0.</p>
<p><strong>Preserves:</strong> SCTP property (if baseline satisfies SCTP) — the phase effect ratios <span class="math inline">\(\tau_j = \mu_{j,d}/\mu_{1,d}\)</span> remain constant across <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p><strong>Does NOT preserve:</strong> Eigenvalue ordering. Different <span class="math inline">\(\boldsymbol{\beta}^{(d)}\)</span> for different destinations can reorder total rates <span class="math inline">\(\nu_j(\mathbf{x})\)</span> for some subjects. See Section 7.4 for details.</p>
<p><strong>Implementation:</strong> Available as option via <code>covariate_constraints=:C1</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># C0 (default): phase-specific covariates</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> x), <span class="op">:</span>pt, <span class="fl">1</span>, <span class="fl">2</span>; n_phases<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter names: h12_a_x, h12_b_x (independent per phase)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># C1: destination-specific shared covariates</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> x), <span class="op">:</span>pt, <span class="fl">1</span>, <span class="fl">2</span>; n_phases<span class="op">=</span><span class="fl">2</span>, covariate_constraints<span class="op">=:</span>C1)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter names: h12_x (shared across phases a,b for destination 2)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>In <code>_build_exit_hazard()</code>, this changes parameter naming:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># C0 (covariate_constraints=:C0, default): phase-specific</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="sc">$</span>(to)<span class="st">_</span><span class="sc">$</span>(phase_letter)<span class="st">_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h12_a_x, h12_b_x</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># C1 (covariate_constraints=:C1): destination-specific  </span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="sc">$</span>(to)<span class="st">_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h12_x (shared across phases a,b for destination 2)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">#       h13_x (shared across phases a,b for destination 3)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Practicality:</strong> ✅ <strong>Easy to implement and recommended for most applications.</strong> Simple change to parameter naming. Reduces parameters from <span class="math inline">\(nKp\)</span> to <span class="math inline">\(Kp\)</span>. Allows biologically meaningful destination-specific effects (e.g., different covariate effects for recovery vs death).</p>
<hr>
</section>
<section id="level-c2-shared-covariate-effects-across-destinations-per-phase" class="level4">
<h4 class="anchored" data-anchor-id="level-c2-shared-covariate-effects-across-destinations-per-phase">Level C2: Shared Covariate Effects Across Destinations (per phase)</h4>
<p><strong>Constraint:</strong> All destinations share the same covariate effect for a given phase: <span class="math display">\[
\boldsymbol{\beta}^{(\mu_{j,d})} = \boldsymbol{\beta}^{(j)} \quad \text{for all } d
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(n \times p\)</span> covariate parameters for exits.</p>
<p><strong>Implementation:</strong> Use phase-based covariate parameter names:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Proposed (C2): phase-specific, destination-agnostic</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="st">_</span><span class="sc">$</span>(phase_letter)<span class="st">_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h1_a_x (shared across destinations 2,3 for phase a)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#       h1_b_x (shared across destinations 2,3 for phase b)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Practicality:</strong> ✅ Easy. Same implementation pattern as C1 with different naming scheme.</p>
<p><strong>Note:</strong> This is a different structure from C1. May be appropriate when phase represents disease severity affecting all outcomes similarly. Less common in practice than C1 or C3.</p>
<hr>
</section>
<section id="level-c3-shared-covariate-effects-across-all-exit-rates" class="level4">
<h4 class="anchored" data-anchor-id="level-c3-shared-covariate-effects-across-all-exit-rates">Level C3: Shared Covariate Effects Across All Exit Rates</h4>
<p><strong>Constraint:</strong> A single covariate vector for all exit rates: <span class="math display">\[
\boldsymbol{\beta}^{(\mu_{j,d})} = \boldsymbol{\beta}^{(\mu)} \quad \text{for all } j, d
\]</span></p>
<p><strong>Exit rate model:</strong> <span class="math display">\[
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(\mu)\top} \mathbf{x})
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(p\)</span> covariate parameters for exits.</p>
<p><strong>Identifiability:</strong> ✅ Strong. This is the Titman &amp; Sharples approach.</p>
<p><strong>Preserves:</strong> SCTP property (if baseline satisfies SCTP).</p>
<p><strong>Does NOT preserve:</strong> Eigenvalue ordering. Since progression rates have no covariates, the ordering <span class="math inline">\(\nu_j(\mathbf{x}) = \lambda_j + e^{\boldsymbol{\beta}^\top \mathbf{x}} \mu_j^{\text{total},(0)}\)</span> can still be violated.</p>
<p><strong>Implementation:</strong> Use state-based covariate parameter names (no phase, no destination):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Proposed (C3): fully shared across phases and destinations</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="st">_exit_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h1_exit_x (shared across all exit hazards from state 1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Practicality:</strong> ✅ Easy. Dramatically reduces parameters (<span class="math inline">\(nKp \to p\)</span>).</p>
<p><strong>Note:</strong> More restrictive than C1 — assumes all destinations have identical covariate effects. May be too strong if destinations represent qualitatively different outcomes.</p>
<hr>
</section>
<section id="level-c4-fully-shared-proportional-hazards-on-all-rates" class="level4">
<h4 class="anchored" data-anchor-id="level-c4-fully-shared-proportional-hazards-on-all-rates">Level C4: Fully Shared (Proportional Hazards on All Rates)</h4>
<p><strong>Constraint:</strong> A single covariate vector affects <strong>all</strong> rates (progression + exit): <span class="math display">\[
\lambda_j(\mathbf{x}) = \lambda_j^{(0)} \exp(\boldsymbol{\beta}^\top \mathbf{x}), \quad
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^\top \mathbf{x})
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(p\)</span> covariate parameters total.</p>
<p><strong>Interpretation:</strong> Accelerated failure time on the phase-type time scale. Covariates speed up or slow down the entire Coxian process.</p>
<p><strong>Identifiability:</strong> ✅ Strongest. Total-rate ordering <span class="math inline">\(\nu_1(\mathbf{x}) \geq \cdots \geq \nu_n(\mathbf{x})\)</span> preserved for all subjects because all rates scale by the same factor.</p>
<p><strong>Implementation:</strong> Requires adding covariates to progression hazards (not currently supported) with shared parameter names:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># All hazards (progression and exit) use same covariate names</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="st">_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h1_x (shared across ALL hazards originating from state 1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Practicality:</strong> ⚠️ <strong>Requires new functionality.</strong> Current implementation does not put covariates on progression rates. Would need to: 1. Add covariate support to <code>_build_progression_hazard()</code> 2. Use shared parameter naming across progression and exit hazards</p>
<p><strong>When to use:</strong> When you believe covariates uniformly accelerate/decelerate the entire disease process.</p>
<hr>
</section>
<section id="level-c5-separate-progression-and-exit-effects" class="level4">
<h4 class="anchored" data-anchor-id="level-c5-separate-progression-and-exit-effects">Level C5: Separate Progression and Exit Effects</h4>
<p><strong>Constraint:</strong> One effect for all progression, one for all exits: <span class="math display">\[
\lambda_j(\mathbf{x}) = \lambda_j^{(0)} \exp(\boldsymbol{\beta}^{(\lambda)\top} \mathbf{x}), \quad
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(\mu)\top} \mathbf{x})
\]</span></p>
<p><strong>Count:</strong> <span class="math inline">\(2p\)</span> covariate parameters.</p>
<p><strong>Interpretation:</strong> Covariates can differentially affect “how fast you progress through phases” vs “how fast you exit.”</p>
<p><strong>Identifiability:</strong> ✅ Good. Does <strong>not</strong> automatically preserve total-rate ordering because different <span class="math inline">\(\boldsymbol{\beta}^{(\lambda)}\)</span> and <span class="math inline">\(\boldsymbol{\beta}^{(\mu)}\)</span> can reorder <span class="math inline">\(\nu_j(\mathbf{x}) = \lambda_j(\mathbf{x}) + \mu_j^{\text{total}}(\mathbf{x})\)</span> for different <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p><strong>Implementation:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Progression hazards use one set of names</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>progression_covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="st">_prog_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h1_prog_x</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Exit hazards use another set</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>exit_covar_parnames <span class="op">=</span> [<span class="fu">Symbol</span>(<span class="st">"h</span><span class="sc">$</span>(from)<span class="st">_exit_</span><span class="sc">$</span>(c)<span class="st">"</span>) for c <span class="kw">in</span> covars]  </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># e.g., h1_exit_x</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Practicality:</strong> ⚠️ <strong>Requires new functionality</strong> (covariates on progression). Less restrictive than C4 but still requires the same infrastructure changes.</p>
<p><strong>When to use:</strong> When you believe progression speed and exit propensity respond differently to covariates (e.g., treatment delays progression but doesn’t affect exit probability).</p>
<hr>
</section>
</section>
<section id="summary-table-model-structures" class="level3">
<h3 class="anchored" data-anchor-id="summary-table-model-structures">3.3 Summary Table: Model Structures</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 18%">
<col style="width: 13%">
<col style="width: 28%">
<col style="width: 23%">
</colgroup>
<thead>
<tr class="header">
<th>Baseline</th>
<th>Covariate</th>
<th>Params</th>
<th>Identifiability</th>
<th>Practicality</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B0 (free)</td>
<td>C0 (free)</td>
<td><span class="math inline">\((K+1)n - 1 + nKp\)</span></td>
<td>❌ Poor</td>
<td>✅ Current default</td>
</tr>
<tr class="even">
<td>B0 (free)</td>
<td>C1 (shared/dest)</td>
<td><span class="math inline">\((K+1)n - 1 + Kp\)</span></td>
<td>⚠️ Marginal</td>
<td>✅ Easy</td>
</tr>
<tr class="odd">
<td>B2 (SCTP)</td>
<td>C0 (free)</td>
<td><span class="math inline">\(n + K - 1 + nKp\)</span></td>
<td>⚠️ Marginal</td>
<td>✅ Implemented</td>
</tr>
<tr class="even">
<td><strong>B2 (SCTP)</strong></td>
<td><strong>C1 (shared/dest)</strong></td>
<td><span class="math inline">\(n + K - 1 + Kp\)</span></td>
<td>✅ <strong>Good</strong></td>
<td>✅ <strong>Recommended</strong></td>
</tr>
<tr class="odd">
<td>B3 (ordered+SCTP)</td>
<td>C1 (shared/dest)</td>
<td><span class="math inline">\(n + K - 1 + Kp\)</span></td>
<td>✅ Strong</td>
<td>✅ Easy</td>
</tr>
<tr class="even">
<td>B4 (Erlang+SCTP)</td>
<td>C1 (shared/dest)</td>
<td><span class="math inline">\(K + 1 + Kp\)</span></td>
<td>✅ Strongest</td>
<td>✅ Easy</td>
</tr>
</tbody>
</table>
<p><strong>Notes:</strong> - Parameter counts assume <span class="math inline">\(n\)</span> phases, <span class="math inline">\(K\)</span> destinations, <span class="math inline">\(p\)</span> covariates, no covariates on progression - Current implementation: B0 baseline + C0 (default) or C1 (<code>covariate_constraints=:C1</code>) - <strong>Recommended</strong>: B2 (SCTP) + C1 — good identifiability, interpretable, practical - <strong>Default for surrogates</strong>: B2 + C1 (can override via <code>baseline_constraints</code>, <code>covariate_constraints</code>) - B3 adds eigenvalue ordering via inequality constraints (<code>:ordered_sctp</code>) - C0 is default for user-specified hazards; C1 available via <code>covariate_constraints=:C1</code></p>
<hr>
</section>
</section>
<section id="hard-vs.-soft-constraints" class="level2">
<h2 class="anchored" data-anchor-id="hard-vs.-soft-constraints">4. Hard vs.&nbsp;Soft Constraints</h2>
<section id="hard-constraints-optimization" class="level3">
<h3 class="anchored" data-anchor-id="hard-constraints-optimization">4.1 Hard Constraints (Optimization)</h3>
<p>Hard constraints are enforced exactly via constrained optimization (e.g., Optimization.jl with constraints).</p>
<p><strong>Equality constraints:</strong> <span class="math display">\[
c(\boldsymbol{\theta}) = 0
\]</span></p>
<p><strong>Inequality constraints:</strong> <span class="math display">\[
g(\boldsymbol{\theta}) \leq 0
\]</span></p>
<section id="eigenvalue-ordering-b1" class="level4">
<h4 class="anchored" data-anchor-id="eigenvalue-ordering-b1">Eigenvalue Ordering (B1)</h4>
<p><strong>Implementation:</strong> Transform to unconstrained space: <span class="math display">\[
\nu_j^{(0)} = \nu_{j+1}^{(0)} + \exp(\delta_j), \quad \delta_j \in \mathbb{R}
\]</span></p>
<p>where <span class="math inline">\(\nu_j = \lambda_j + \mu_j^{\text{total}}\)</span>. Or use inequality constraints: <span class="math inline">\(\nu_j \leq \nu_{j-1}\)</span>.</p>
<p><strong>Note:</strong> This is more complex than constraining progression rates alone because it couples <span class="math inline">\(\lambda_j\)</span> and <span class="math inline">\(\mu_{j,d}\)</span>.</p>
</section>
<section id="sctp-b2" class="level4">
<h4 class="anchored" data-anchor-id="sctp-b2">SCTP (B2)</h4>
<p><strong>Implementation:</strong> Equality constraints on log differences: <span class="math display">\[
\log \mu_{j,d_1}^{(0)} - \log \mu_{1,d_1}^{(0)} - \log \mu_{j,d_2}^{(0)} + \log \mu_{1,d_2}^{(0)} = 0
\]</span></p>
<p>This is <span class="math inline">\((n-1)(K-1)\)</span> constraints.</p>
</section>
<section id="shared-covariates-c1-c4" class="level4">
<h4 class="anchored" data-anchor-id="shared-covariates-c1-c4">Shared Covariates (C1-C4)</h4>
<p><strong>Implementation:</strong> Use the same parameter symbols in the model; no separate constraints needed.</p>
</section>
</section>
<section id="soft-constraints-penalties" class="level3">
<h3 class="anchored" data-anchor-id="soft-constraints-penalties">4.2 Soft Constraints (Penalties)</h3>
<p>Soft constraints add penalty terms to the log-likelihood: <span class="math display">\[
\ell_{\text{pen}}(\boldsymbol{\theta}) = \ell(\boldsymbol{\theta}) - \text{Penalty}(\boldsymbol{\theta})
\]</span></p>
<section id="eigenvalue-ordering-penalty" class="level4">
<h4 class="anchored" data-anchor-id="eigenvalue-ordering-penalty">Eigenvalue Ordering Penalty</h4>
<p><span class="math display">\[
P_{\text{order}}(\boldsymbol{\nu}) = \rho \sum_{j=2}^{n} \left[ \max(0, \nu_j^{(0)} - \nu_{j-1}^{(0)}) \right]^2
\]</span></p>
<p>where <span class="math inline">\(\nu_j = \lambda_j + \mu_j^{\text{total}}\)</span>.</p>
<p><strong>Behavior:</strong> Zero when total-rate ordering is satisfied; quadratic penalty when violated.</p>
</section>
<section id="sctp-deviation-penalty" class="level4">
<h4 class="anchored" data-anchor-id="sctp-deviation-penalty">SCTP Deviation Penalty</h4>
<p>Let <span class="math inline">\(\hat{\tau}_j^{(d)} = \mu_{j,d}^{(0)} / \mu_{1,d}^{(0)}\)</span>. Under SCTP, <span class="math inline">\(\hat{\tau}_j^{(d)}\)</span> should be constant across <span class="math inline">\(d\)</span>.</p>
<p><span class="math display">\[
P_{\text{SCTP}}(\boldsymbol{\mu}) = \rho \sum_{j=2}^{n} \sum_{d_1 &lt; d_2} \left( \log \hat{\tau}_j^{(d_1)} - \log \hat{\tau}_j^{(d_2)} \right)^2
\]</span></p>
</section>
<section id="covariate-similarity-penalty" class="level4">
<h4 class="anchored" data-anchor-id="covariate-similarity-penalty">Covariate Similarity Penalty</h4>
<p>Encourage similar covariate effects across phases: <span class="math display">\[
P_{\text{cov}}(\boldsymbol{\beta}) = \rho \sum_{j=2}^{n} \sum_{d} \left\| \boldsymbol{\beta}^{(\mu_{j,d})} - \boldsymbol{\beta}^{(\mu_{1,d})} \right\|^2
\]</span></p>
</section>
<section id="progression-rate-stability-titman-sharples-appendix" class="level4">
<h4 class="anchored" data-anchor-id="progression-rate-stability-titman-sharples-appendix">Progression Rate Stability (Titman &amp; Sharples Appendix)</h4>
<p>Penalize extreme <span class="math inline">\(\lambda\)</span> values to ensure identifiability when testing Markov vs semi-Markov: <span class="math display">\[
P_{\lambda}(\boldsymbol{\lambda}) = \sum_{j} \left( C_j \log \lambda_j - C_j \lambda_j \alpha_j \right)
\]</span></p>
<p>This is equivalent to a Gamma prior on <span class="math inline">\(\lambda_j\)</span> with shape <span class="math inline">\(C_j\)</span> and rate <span class="math inline">\(\alpha_j^{-1}\)</span>.</p>
</section>
</section>
<section id="trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="trade-offs">4.3 Trade-offs</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 27%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Hard constraints</strong></td>
<td>Exact enforcement; guarantees structure</td>
<td>Constrained optimization harder; may reduce convergence</td>
</tr>
<tr class="even">
<td><strong>Soft constraints</strong></td>
<td>Unconstrained optimization; smooth gradients</td>
<td>Structure only approximate; requires tuning <span class="math inline">\(\rho\)</span></td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="implementation-in-multistatemodels.jl" class="level2">
<h2 class="anchored" data-anchor-id="implementation-in-multistatemodels.jl">5. Implementation in MultistateModels.jl</h2>
<section id="current-capabilities" class="level3">
<h3 class="anchored" data-anchor-id="current-capabilities">5.1 Current Capabilities</h3>
<p><strong>Baseline hazards:</strong> - ✅ Unstructured (B0): Default for <code>:pt</code> hazards - ✅ SCTP (B2): Via <code>coxian_structure=:sctp</code> — implemented in <code>expansion_constraints.jl</code> - ❌ Eigenvalue ordering (B1): Not currently implemented - ❌ Erlang (B4): Not implemented</p>
<p><strong>Covariate effects:</strong> - ✅ Unstructured (C0): Each phase × destination has independent effects (default, <code>covariate_constraints=:C0</code>) - ✅ Shared per destination (C1): Via <code>covariate_constraints=:C1</code> option - ❌ Shared per phase (C2): Not implemented - ❌ Shared across all exits (C3): Not implemented - ❌ Fully shared (C4): Not implemented (requires covariates on progression)</p>
<p><strong>Constraint infrastructure:</strong> - ✅ Optimization.jl integration supports constraints - ✅ <code>constraints</code> field in <code>ProposalConfig</code> - ⚠️ Penalty infrastructure partially available (spline smoothing penalties exist)</p>
</section>
<section id="implemented-options" class="level3">
<h3 class="anchored" data-anchor-id="implemented-options">5.2 Implemented Options</h3>
<section id="covariate-constraints-c0-vs-c1" class="level4">
<h4 class="anchored" data-anchor-id="covariate-constraints-c0-vs-c1">Covariate Constraints (C0 vs C1)</h4>
<p>Control how covariate effects are constrained across phases via <code>covariate_constraints</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># C0 (default): Phase-specific covariates (no constraints)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> x), <span class="op">:</span>pt, <span class="fl">1</span>, <span class="fl">2</span>; n_phases<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter names: h12_a_x, h12_b_x (independent per phase)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># C1: Destination-specific shared covariates (equality constraints)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>h12 <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> x), <span class="op">:</span>pt, <span class="fl">1</span>, <span class="fl">2</span>; n_phases<span class="op">=</span><span class="fl">2</span>, covariate_constraints<span class="op">=:</span>C1)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameter names: h12_x (shared across phases a,b)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 17%">
<col style="width: 36%">
<col style="width: 28%">
</colgroup>
<thead>
<tr class="header">
<th>Option</th>
<th>Symbol</th>
<th>Parameter Count</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Unconstrained (C0)</td>
<td><code>:C0</code></td>
<td><span class="math inline">\(nKp\)</span></td>
<td>Each phase has independent covariate effects (default)</td>
</tr>
<tr class="even">
<td>Per-destination (C1)</td>
<td><code>:C1</code></td>
<td><span class="math inline">\(Kp\)</span></td>
<td>Shared across phases, different per destination</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation:</strong> Use <code>:C1</code> for most applications — better identifiability, fewer parameters, more interpretable.</p>
<p><strong>Default for surrogates:</strong> When building phase-type surrogates via <code>build_phasetype_surrogate()</code>, the default is B2 (SCTP) + C1 for optimal identifiability. Users can override via <code>baseline_constraints</code> and <code>covariate_constraints</code> options.</p>
</section>
</section>
<section id="future-implementations" class="level3">
<h3 class="anchored" data-anchor-id="future-implementations">5.3 Future Implementations</h3>
<section id="priority-1-eigenvalue-ordering-b1" class="level4">
<h4 class="anchored" data-anchor-id="priority-1-eigenvalue-ordering-b1">Priority 1: Eigenvalue Ordering (B1)</h4>
<p><strong>Implementation:</strong> Add ordering constraints during optimization.</p>
<p><strong>Option A (reparameterization):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Store δ_j (unconstrained), compute λ_j = λ_{n-1} + Σ_{k≥j} exp(δ_k)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Option B (bounds):</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add constraints: λ_j ≤ λ_{j-1}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>User control:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">multistatemodel</span>(h12; n_phases<span class="op">=</span><span class="fl">3</span>, coxian_structure<span class="op">=:</span>ordered)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># or</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">multistatemodel</span>(h12; n_phases<span class="op">=</span><span class="fl">3</span>, coxian_structure<span class="op">=:</span>ordered_sctp)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="priority-2-penalty-infrastructure" class="level4">
<h4 class="anchored" data-anchor-id="priority-2-penalty-infrastructure">Priority 2: Penalty Infrastructure</h4>
<p>Add generic penalty support to <code>fit()</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fit</span>(model; </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    penalty <span class="op">=</span> (</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        ordering <span class="op">=</span> (<span class="kw">type</span><span class="op">=:</span>soft, weight<span class="op">=</span><span class="fl">10.0</span>),</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        sctp <span class="op">=</span> (<span class="kw">type</span><span class="op">=:</span>soft, weight<span class="op">=</span><span class="fl">5.0</span>),</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        lambda_prior <span class="op">=</span> (<span class="kw">type</span><span class="op">=:</span>gamma, shape<span class="op">=</span><span class="fl">1.0</span>, rate<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
<section id="proposed-structure-options" class="level3">
<h3 class="anchored" data-anchor-id="proposed-structure-options">5.4 Proposed Structure Options</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> PhaseTypeHazard <span class="op">&lt;:</span><span class="dt"> HazardFunction</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... existing fields ...</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    structure<span class="op">::</span><span class="dt">Symbol  </span><span class="co"># :unstructured, :ordered, :sctp, :ordered_sctp, :erlang</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    covariate_sharing<span class="op">::</span><span class="dt">Symbol  </span><span class="co"># :none, :across_phases, :across_destinations, :full</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<table class="caption-top table">
<thead>
<tr class="header">
<th><code>structure</code></th>
<th>Baseline Constraints</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:unstructured</code></td>
<td>None (B0)</td>
</tr>
<tr class="even">
<td><code>:ordered</code></td>
<td>λ ordering (B1)</td>
</tr>
<tr class="odd">
<td><code>:sctp</code></td>
<td>SCTP (B2)</td>
</tr>
<tr class="even">
<td><code>:ordered_sctp</code></td>
<td>Both (B3)</td>
</tr>
<tr class="odd">
<td><code>:erlang</code></td>
<td>Equal λ (B4)</td>
</tr>
</tbody>
</table>
<table class="caption-top table">
<thead>
<tr class="header">
<th><code>covariate_sharing</code></th>
<th>Covariate Structure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:none</code></td>
<td>All independent (C0)</td>
</tr>
<tr class="even">
<td><code>:across_phases</code></td>
<td>Shared per destination (C1)</td>
</tr>
<tr class="odd">
<td><code>:across_destinations</code></td>
<td>Shared per phase (C2)</td>
</tr>
<tr class="even">
<td><code>:exits</code></td>
<td>Shared across all exits (C3)</td>
</tr>
<tr class="odd">
<td><code>:full</code></td>
<td>Single effect for all rates (C4)</td>
</tr>
</tbody>
</table>
<hr>
</section>
</section>
<section id="practical-recommendations" class="level2">
<h2 class="anchored" data-anchor-id="practical-recommendations">6. Practical Recommendations</h2>
<section id="default-recommendation" class="level3">
<h3 class="anchored" data-anchor-id="default-recommendation">6.1 Default Recommendation</h3>
<p>For most applications, use: - <strong>Baseline:</strong> <code>:ordered_sctp</code> (B3) - <strong>Covariates:</strong> <code>:across_phases</code> (C1) or <code>:exits</code> (C3)</p>
<p>This provides: - Identifiability guarantees (canonical representation) - Interpretable phase effects (SCTP) - Reasonable parameter count - Preserved ordering for all subjects</p>
</section>
<section id="exploratory-analysis" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-analysis">6.2 Exploratory Analysis</h3>
<p>Start with: - <strong>Baseline:</strong> <code>:unstructured</code> (B0) - <strong>Covariates:</strong> <code>:exits</code> (C3)</p>
<p>Then test whether data support more structure via likelihood ratio tests (using modified LRT from Titman &amp; Sharples if needed).</p>
</section>
<section id="limited-data" class="level3">
<h3 class="anchored" data-anchor-id="limited-data">6.3 Limited Data</h3>
<p>Use maximal structure: - <strong>Baseline:</strong> <code>:ordered_sctp</code> or <code>:erlang</code> - <strong>Covariates:</strong> <code>:full</code> (C4)</p>
</section>
<section id="testing-markov-vs-semi-markov" class="level3">
<h3 class="anchored" data-anchor-id="testing-markov-vs-semi-markov">6.4 Testing Markov vs Semi-Markov</h3>
<p>Use Titman &amp; Sharples modified LRT: 1. Fit with penalty on <span class="math inline">\(\lambda\)</span> (Gamma prior) 2. Compare penalized likelihoods 3. Use χ² approximation for degrees of freedom (excluding <span class="math inline">\(\lambda\)</span> parameters)</p>
<hr>
</section>
</section>
<section id="mathematical-proofs-and-details" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-proofs-and-details">7. Mathematical Proofs and Details</h2>
<section id="sctp-preserves-exit-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="sctp-preserves-exit-probabilities">7.1 SCTP Preserves Exit Probabilities</h3>
<p><strong>Claim:</strong> Under SCTP (<span class="math inline">\(\mu_{j,d} = \tau_j \mu_{1,d}\)</span>), the conditional exit probability is phase-invariant.</p>
<p><strong>Proof:</strong> <span class="math display">\[
P(d \mid \text{exit from phase } j) = \frac{\mu_{j,d}}{\sum_{d'} \mu_{j,d'}} = \frac{\tau_j \mu_{1,d}}{\sum_{d'} \tau_j \mu_{1,d'}} = \frac{\mu_{1,d}}{\sum_{d'} \mu_{1,d'}}
\]</span></p>
<p>which is independent of <span class="math inline">\(j\)</span>. ∎</p>
</section>
<section id="shared-covariates-preserve-sctp" class="level3">
<h3 class="anchored" data-anchor-id="shared-covariates-preserve-sctp">7.2 Shared Covariates Preserve SCTP</h3>
<p><strong>Claim:</strong> If baseline satisfies SCTP and covariates are shared across phases (C1), then SCTP holds for all <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p><strong>Proof:</strong> Let <span class="math inline">\(\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(d)\top} \mathbf{x})\)</span>.</p>
<p>The phase effect ratio: <span class="math display">\[
\frac{\mu_{j,d}(\mathbf{x})}{\mu_{1,d}(\mathbf{x})} = \frac{\mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(d)\top} \mathbf{x})}{\mu_{1,d}^{(0)} \exp(\boldsymbol{\beta}^{(d)\top} \mathbf{x})} = \frac{\mu_{j,d}^{(0)}}{\mu_{1,d}^{(0)}} = \tau_j
\]</span></p>
<p>which is independent of <span class="math inline">\(\mathbf{x}\)</span> and <span class="math inline">\(d\)</span>. ∎</p>
</section>
<section id="shared-covariates-preserve-total-rate-ordering" class="level3">
<h3 class="anchored" data-anchor-id="shared-covariates-preserve-total-rate-ordering">7.3 Shared Covariates Preserve Total-Rate Ordering</h3>
<p><strong>Claim:</strong> If baseline satisfies <span class="math inline">\(\nu_1^{(0)} \geq \nu_2^{(0)} \geq \cdots\)</span> (where <span class="math inline">\(\nu_j = \lambda_j + \mu_j^{\text{total}}\)</span>) and covariates are shared across <strong>all</strong> rates (C4), then the total-rate ordering holds for all <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p><strong>Proof:</strong> Under C4, all rates scale by the same factor: <span class="math display">\[
\lambda_j(\mathbf{x}) = \lambda_j^{(0)} \exp(\boldsymbol{\beta}^\top \mathbf{x}), \quad
\mu_{j,d}(\mathbf{x}) = \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^\top \mathbf{x})
\]</span></p>
<p>Therefore: <span class="math display">\[
\nu_j(\mathbf{x}) = \lambda_j(\mathbf{x}) + \mu_j^{\text{total}}(\mathbf{x}) = \left( \lambda_j^{(0)} + \mu_j^{\text{total},(0)} \right) \exp(\boldsymbol{\beta}^\top \mathbf{x}) = \nu_j^{(0)} \exp(\boldsymbol{\beta}^\top \mathbf{x})
\]</span></p>
<p>For any <span class="math inline">\(j\)</span>: <span class="math display">\[
\nu_{j-1}(\mathbf{x}) - \nu_j(\mathbf{x}) = \exp(\boldsymbol{\beta}^\top \mathbf{x}) \left( \nu_{j-1}^{(0)} - \nu_j^{(0)} \right) \geq 0
\]</span></p>
<p>since <span class="math inline">\(\exp(\cdot) &gt; 0\)</span> and <span class="math inline">\(\nu_{j-1}^{(0)} \geq \nu_j^{(0)}\)</span> by assumption. ∎</p>
<p><strong>Note:</strong> This proof requires C4 (all rates share the same <span class="math inline">\(\boldsymbol{\beta}\)</span>). Under C5 (separate <span class="math inline">\(\boldsymbol{\beta}^{(\lambda)}\)</span> and <span class="math inline">\(\boldsymbol{\beta}^{(\mu)}\)</span>), the total rates <span class="math inline">\(\nu_j(\mathbf{x})\)</span> can become reordered for some <span class="math inline">\(\mathbf{x}\)</span> even if baseline is ordered.</p>
</section>
<section id="c1-does-not-preserve-eigenvalue-ordering" class="level3">
<h3 class="anchored" data-anchor-id="c1-does-not-preserve-eigenvalue-ordering">7.4 C1 Does Not Preserve Eigenvalue Ordering</h3>
<p><strong>Claim:</strong> Under C1 (shared covariates per destination), eigenvalue ordering can be violated even if baseline is ordered.</p>
<p><strong>Setup:</strong> Under C1 with no covariates on progression: <span class="math display">\[
\nu_j(\mathbf{x}) = \lambda_j + \sum_d \mu_{j,d}^{(0)} \exp(\boldsymbol{\beta}^{(d)\top} \mathbf{x})
\]</span></p>
<p><strong>Counterexample:</strong> Consider 2 phases, 2 destinations <span class="math inline">\((d_1, d_2)\)</span>, 1 binary covariate <span class="math inline">\(x \in \{0, 1\}\)</span>: - <span class="math inline">\(\lambda_1 = 1, \lambda_2 = 0.5\)</span> (no final progression) - <span class="math inline">\(\mu_{1,d_1}^{(0)} = 0.3, \mu_{2,d_1}^{(0)} = 0.8\)</span> (phase 2 exits faster to <span class="math inline">\(d_1\)</span>) - <span class="math inline">\(\mu_{1,d_2}^{(0)} = 0.5, \mu_{2,d_2}^{(0)} = 0.2\)</span> (phase 1 exits faster to <span class="math inline">\(d_2\)</span>) - <span class="math inline">\(\beta^{(d_1)} = 2, \beta^{(d_2)} = -1\)</span></p>
<p>At baseline (<span class="math inline">\(x = 0\)</span>): <span class="math display">\[
\nu_1^{(0)} = 1 + 0.3 + 0.5 = 1.8, \quad \nu_2^{(0)} = 0.5 + 0.8 + 0.2 = 1.5
\]</span> Ordering satisfied: <span class="math inline">\(\nu_1^{(0)} &gt; \nu_2^{(0)}\)</span> ✓</p>
<p>At <span class="math inline">\(x = 1\)</span>: <span class="math display">\[
\nu_1(1) = 1 + 0.3 e^2 + 0.5 e^{-1} \approx 1 + 2.22 + 0.18 = 3.40
\]</span> <span class="math display">\[
\nu_2(1) = 0.5 + 0.8 e^2 + 0.2 e^{-1} \approx 0.5 + 5.91 + 0.07 = 6.48
\]</span> Ordering violated: <span class="math inline">\(\nu_2(1) &gt; \nu_1(1)\)</span> ✗</p>
<p><strong>Conclusion:</strong> C1 preserves SCTP (Theorem 7.2) but does <strong>not</strong> guarantee eigenvalue ordering. This is acceptable in practice because: 1. SCTP is the more important constraint for interpretability 2. Eigenvalue ordering primarily matters for theoretical identifiability at the boundary 3. The added flexibility of destination-specific effects (C1 vs C3/C4) is often substantively important</p>
<hr>
</section>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">8. References</h2>
<ol type="1">
<li><p><strong>Lindqvist, B.H.</strong> (2022). Phase-type models for competing risks, with emphasis on identifiability issues. <em>Lifetime Data Analysis</em>, 29, 318-341.</p></li>
<li><p><strong>Titman, A.C. &amp; Sharples, L.D.</strong> (2010). Semi-Markov models with phase-type sojourn distributions. <em>Biometrics</em>, 66, 742-752.</p></li>
<li><p><strong>Cumani, A.</strong> (1982). On the canonical representation of homogeneous Markov processes modelling failure-time distributions. <em>Microelectronics Reliability</em>, 22, 583-602.</p></li>
<li><p><strong>Rizk, J., Burke, K. &amp; Walsh, D.</strong> (2019). Identifiability and estimation of Coxian phase-type models. <em>arXiv preprint</em>.</p></li>
<li><p><strong>Telek, M. &amp; Horváth, G.</strong> (2007). A minimal representation of Markov arrival processes and a moments matching method. <em>Performance Evaluation</em>, 64, 1153-1168.</p></li>
</ol>
<hr>
</section>
<section id="appendix-a-multistatemodels.jl-parameter-naming" class="level2">
<h2 class="anchored" data-anchor-id="appendix-a-multistatemodels.jl-parameter-naming">Appendix A: MultistateModels.jl Parameter Naming</h2>
<section id="baseline-parameters" class="level3">
<h3 class="anchored" data-anchor-id="baseline-parameters">Baseline Parameters</h3>
<p>Naming convention for <span class="math inline">\(n\)</span>-phase Coxian hazard from state 1 to states 2, 3:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Parameter</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\lambda_1\)</span></td>
<td><code>h1_ab_rate</code></td>
<td>Progression 1→2 (phases a→b)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lambda_2\)</span></td>
<td><code>h1_bc_rate</code></td>
<td>Progression 2→3 (phases b→c)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mu_{1,2}\)</span></td>
<td><code>h12_a_rate</code></td>
<td>Exit from phase a to state 2</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mu_{2,2}\)</span></td>
<td><code>h12_b_rate</code></td>
<td>Exit from phase b to state 2</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mu_{3,2}\)</span></td>
<td><code>h12_c_rate</code></td>
<td>Exit from phase c to state 2</td>
</tr>
</tbody>
</table>
</section>
<section id="covariate-parameters" class="level3">
<h3 class="anchored" data-anchor-id="covariate-parameters">Covariate Parameters</h3>
<p><strong>C0 (<code>covariate_constraints=:C0</code>, default):</strong> Phase-specific (unconstrained)</p>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 20%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\beta^{(\mu_{1,2})}\)</span></td>
<td><code>h12_a_age</code></td>
<td>Age effect on exit from phase a to state 2</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta^{(\mu_{2,2})}\)</span></td>
<td><code>h12_b_age</code></td>
<td>Age effect on exit from phase b to state 2</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\beta^{(\mu_{1,3})}\)</span></td>
<td><code>h13_a_age</code></td>
<td>Age effect on exit from phase a to state 3</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta^{(\mu_{2,3})}\)</span></td>
<td><code>h13_b_age</code></td>
<td>Age effect on exit from phase b to state 3</td>
</tr>
</tbody>
</table>
<p><strong>C1 (<code>covariate_constraints=:C1</code>):</strong> Destination-specific (equality constraints across phases)</p>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 20%">
<col style="width: 43%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\beta^{(d=2)}\)</span></td>
<td><code>h12_age</code></td>
<td>Age effect on all exits to state 2 (shared across phases a,b)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\beta^{(d=3)}\)</span></td>
<td><code>h13_age</code></td>
<td>Age effect on all exits to state 3 (shared across phases a,b)</td>
</tr>
</tbody>
</table>
</section>
<section id="api-example" class="level3">
<h3 class="anchored" data-anchor-id="api-example">API Example</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># C0 (default): 2 phases × 2 destinations × 1 covariate = 4 covariate parameters</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> age), <span class="op">:</span>pt, <span class="fl">1</span>, [<span class="fl">2</span>, <span class="fl">3</span>]; n_phases<span class="op">=</span><span class="fl">2</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters: h12_a_age, h12_b_age, h13_a_age, h13_b_age</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># C1: 2 destinations × 1 covariate = 2 covariate parameters  </span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fu">Hazard</span>(<span class="pp">@formula</span>(<span class="fl">0</span> <span class="op">~</span> age), <span class="op">:</span>pt, <span class="fl">1</span>, [<span class="fl">2</span>, <span class="fl">3</span>]; n_phases<span class="op">=</span><span class="fl">2</span>, covariate_constraints<span class="op">=:</span>C1)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters: h12_age, h13_age</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Override surrogate defaults (surrogates use B2+C1 by default)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>surrogate <span class="op">=</span> <span class="fu">build_phasetype_surrogate</span>(tmat, config;</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    baseline_constraints<span class="op">=:</span>B0,      <span class="co"># Override: use unstructured baseline</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    covariate_constraints<span class="op">=:</span>C0)     <span class="co"># Override: use phase-specific covariates</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>